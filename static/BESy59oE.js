import{M as I,F as Z,N as Q,P as U,Q as W,l as R,R as k,T as M,k as h,U as O,n as Y,o as q,p as J,A as K,V as ee,W as te,S as C,I as re,X as V,f as j,Y as ie,_ as ae,j as B,t as L,m as S,s as g,c as _,Z as se,d as ne,b as oe}from"./qbpNAjKn.js";import{m as le,i as ce,b as ue,c as de,d as pe,e as me,f as fe,h as $e,j as ge,k as he,o as De}from"./1ujJLabB.js";import{n as be,a as xe}from"./B2YBZYj8.js";import{c as ye}from"./CNN2D5vW.js";const Se=({data:l=[],dataFormatter:s,chartParams:r,layout:a})=>{if(!l.length)return[];let c=[];try{const t=s.gridList[0]||I;c=l.map((o,e)=>{const n=s.gridList[e]||t;return le({data:o,dataFormatter:{type:"grid",grid:{...n},container:{...s.container}},chartParams:r,layout:a},"multiGrid",e)});let d=-1;c=c.map((o,e)=>o.map((n,u)=>(d++,n.map(p=>(p.accSeriesIndex=d,p.color=Z(d,r),p)))))}catch(t){throw Error(t)}return c},Te=({fullDataFormatter$:l,computedData$:s,layout$:r,fullChartParams$:a,event$:c})=>{function t({gridDataFormatter$:o,gridComputedData$:e,layout$:n,fullChartParams$:u,event$:p}){const f=ce({computedData$:e,fullDataFormatter$:o}).pipe(h(1)),m=ue({computedData$:e,fullDataFormatter$:o,fullChartParams$:u,layout$:n}).pipe(h(1)),$=de({fullDataFormatter$:o,layout$:n}).pipe(h(1)),b=pe({gridAxesTransform$:$}).pipe(h(1)),D=me({computedData$:e,fullDataFormatter$:o,layout$:n}).pipe(h(1)),x=fe({gridContainer$:m,gridAxesTransform$:$,gridGraphicTransform$:D}),A=$e({fullDataFormatter$:o,layout$:n}).pipe(h(1)),y=e.pipe(R(X=>X.flat())).pipe(h(1)),v=Y({datumList$:y,fullChartParams$:u,event$:p}).pipe(h(1)),i=ge({computedData$:e}),T=q({datumList$:y}).pipe(h(1)),H=J({datumList$:y}).pipe(h(1)),N=he({computedData$:e}).pipe(h(1));return{isSeriesPositionSeprate$:f,gridContainer$:m,gridAxesTransform$:$,gridAxesReverseTransform$:b,gridGraphicTransform$:D,gridGraphicReverseScale$:x,gridAxesSize$:A,gridHighlight$:v,existedSeriesLabels$:i,SeriesDataMap$:T,GroupDataMap$:H,visibleComputedData$:N}}const d=new Q;return U({fullDataFormatter:l,computedData:s}).pipe(W(async o=>o),R(o=>{d.next(void 0);const e=o.fullDataFormatter.gridList[0]??I;return o.computedData.map((n,u)=>{const f={type:"grid",grid:{...o.fullDataFormatter.gridList[u]??e},container:{...o.fullDataFormatter.container}},m=k(f).pipe(M(d),h(1)),$=k(n).pipe(M(d),h(1));return t({gridDataFormatter$:m,gridComputedData$:$,layout$:r,fullChartParams$:a,event$:c})})}))},Le=({computedData$:l,fullDataFormatter$:s,fullChartParams$:r,layout$:a})=>U({computedData:l,fullDataFormatter:s,fullChartParams:r,layout:a}).pipe(W(async t=>t),R(t=>{const d=t.fullDataFormatter.gridList[0]??I;return t.computedData.map((e,n)=>{const u=t.fullDataFormatter.gridList[n]??d;if(!!(u.seriesSlotIndexes&&u.seriesSlotIndexes.length===e.length))return e.map((f,m)=>{const $=u.seriesSlotIndexes[m]%t.fullDataFormatter.container.columnAmount,b=Math.floor(u.seriesSlotIndexes[m]/t.fullDataFormatter.container.columnAmount),{translate:D,scale:x}=O(t.layout,t.fullDataFormatter.container,b,$);return{slotIndex:u.seriesSlotIndexes[m],rowIndex:b,columnIndex:$,translate:D,scale:x}});{const f=u.slotIndex%t.fullDataFormatter.container.columnAmount,m=Math.floor(u.slotIndex/t.fullDataFormatter.container.columnAmount);return e.map(($,b)=>{const{translate:D,scale:x}=O(t.layout,t.fullDataFormatter.container,m,f);return{slotIndex:u.slotIndex,rowIndex:m,columnIndex:f,translate:D,scale:x}})}})})),ve=({subject:l,observer:s})=>{const r=Te({fullDataFormatter$:s.fullDataFormatter$,computedData$:s.computedData$,layout$:s.layout$,fullChartParams$:s.fullChartParams$,event$:l.event$}).pipe(h(1)),a=Le({computedData$:s.computedData$,fullDataFormatter$:s.fullDataFormatter$,fullChartParams$:s.fullChartParams$,layout$:s.layout$});return{fullParams$:s.fullParams$,fullChartParams$:s.fullChartParams$,fullDataFormatter$:s.fullDataFormatter$,computedData$:s.computedData$,layout$:s.layout$,multiGridEachDetail$:r,multiGridContainer$:a}};class Me extends K{constructor(s,r){super({defaultDataFormatter:ee,computedDataFn:Se,contextObserverFn:ve},s,r)}}var z={now:function(){return(z.delegate||Date).now()},delegate:void 0},_e=function(l){te(s,l);function s(r,a,c){r===void 0&&(r=1/0),a===void 0&&(a=1/0),c===void 0&&(c=z);var t=l.call(this)||this;return t._bufferSize=r,t._windowTime=a,t._timestampProvider=c,t._buffer=[],t._infiniteTimeWindow=!0,t._infiniteTimeWindow=a===1/0,t._bufferSize=Math.max(1,r),t._windowTime=Math.max(1,a),t}return s.prototype.next=function(r){var a=this,c=a.isStopped,t=a._buffer,d=a._infiniteTimeWindow,o=a._timestampProvider,e=a._windowTime;c||(t.push(r),!d&&t.push(o.now()+e)),this._trimBuffer(),l.prototype.next.call(this,r)},s.prototype._subscribe=function(r){this._throwIfClosed(),this._trimBuffer();for(var a=this._innerSubscribe(r),c=this,t=c._infiniteTimeWindow,d=c._buffer,o=d.slice(),e=0;e<o.length&&!r.closed;e+=t?1:2)r.next(o[e]);return this._checkFinalizedStatuses(r),a},s.prototype._trimBuffer=function(){var r=this,a=r._bufferSize,c=r._timestampProvider,t=r._buffer,d=r._infiniteTimeWindow,o=(d?1:2)*a;if(a<1/0&&o<t.length&&t.splice(0,t.length-o),!d){for(var e=c.now(),n=0,u=1;u<t.length&&t[u]<=e;u+=2)n=u;n&&t.splice(0,n+1)}},s}(C);function Ae(l){l===void 0&&(l={});var s=l.connector,r=s===void 0?function(){return new C}:s,a=l.resetOnError,c=a===void 0?!0:a,t=l.resetOnComplete,d=t===void 0?!0:t,o=l.resetOnRefCountZero,e=o===void 0?!0:o;return function(n){var u,p,f,m=0,$=!1,b=!1,D=function(){p==null||p.unsubscribe(),p=void 0},x=function(){D(),u=f=void 0,$=b=!1},A=function(){var y=u;x(),y==null||y.unsubscribe()};return re(function(y,v){m++,!b&&!$&&D();var i=f=f??r();v.add(function(){m--,m===0&&!b&&!$&&(p=P(A,e))}),i.subscribe(v),!u&&m>0&&(u=new V({next:function(T){return i.next(T)},error:function(T){b=!0,D(),p=P(x,c,T),i.error(T)},complete:function(){$=!0,D(),p=P(x,d),i.complete()}}),j(y).subscribe(u))})(n)}}function P(l,s){for(var r=[],a=2;a<arguments.length;a++)r[a-2]=arguments[a];if(s===!0){l();return}if(s!==!1){var c=new V({next:function(){c.unsubscribe(),l()}});return j(s.apply(void 0,ie([],ae(r)))).subscribe(c)}}function F(l,s,r){var a,c=!1;return a=l,Ae({connector:function(){return new _e(a,s,r)},resetOnError:!0,resetOnComplete:!1,resetOnRefCountZero:c})}const Ce={position:"right",justify:"end",padding:28,backgroundFill:"none",backgroundStroke:"none",gap:10,listRectWidth:14,listRectHeight:14,listRectRadius:0,gridList:[{listRectWidth:14,listRectHeight:14,listRectRadius:0}]},Oe={labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!0,axisLineColorType:"primary",tickFormat:l=>l,tickLineVisible:!0,tickPadding:20,tickFullLine:!1,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary",gridIndexes:[0]},Ee={labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!1,axisLineColorType:"primary",ticks:4,tickFormat:",.0f",tickLineVisible:!0,tickPadding:20,tickFullLine:!0,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary",gridIndexes:[0]},Pe={barWidth:0,barPadding:1,barGroupPadding:40,barRadius:!1,gridIndexes:[0]},we={lineCurve:"curveLinear",lineWidth:2,gridIndexes:[1]},Ue={radius:4,fillColorType:"white",strokeColorType:"series",strokeWidth:2,onlyShowHighlighted:!1,gridIndexes:[1]},We={firstAxis:{labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!1,axisLineColorType:"primary",ticks:4,tickFormat:",.0f",tickLineVisible:!0,tickPadding:20,tickFullLine:!0,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary"},secondAxis:{labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!1,axisLineColorType:"primary",ticks:4,tickFormat:",.0f",tickLineVisible:!0,tickPadding:20,tickFullLine:!0,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary"},gridIndexes:[0,1]},E="MultiGridLegend",Ve=B(E,Ce)(({selection:l,rootSelection:s,observer:r,subject:a})=>{const c=new C,t=r.multiGridEachDetail$.pipe(L(c),S(n=>n.map((p,f)=>p.SeriesDataMap$.pipe(S(m=>Array.from(m.keys()))))),g(n=>_(n)),S(n=>n.flat())),d=_({fullParams:r.fullParams$,multiGrid:r.multiGridEachDetail$,computedData:r.computedData$}).pipe(L(c),g(async n=>n),S(n=>n.computedData.map((u,p)=>{const f=se(n.fullParams.gridList[p]??{},{listRectWidth:n.fullParams.listRectWidth,listRectHeight:n.fullParams.listRectHeight,listRectRadius:n.fullParams.listRectRadius});return u.map(m=>f)}).flat())),o=_({fullParams:r.fullParams$,seriesList:d}).pipe(L(c),g(async n=>n),S(n=>({...n.fullParams,seriesList:n.seriesList}))),e=be(E,{rootSelection:s,seriesLabels$:t,fullParams$:o,layout$:r.layout$,fullChartParams$:r.fullChartParams$});return()=>{c.next(void 0),e()}}),Fe=l=>{const s=l.fullParams$.pipe(S(a=>a.gridIndexes),ne(),F(1)),r=new C;return s.pipe(S(a=>a.map(c=>{r.next(void 0);const t=De(c).pipe(L(r),F(1)),d=_({computedData:l.computedData$,gridIndex:t}).pipe(L(r),S(i=>i.computedData[i.gridIndex]??i.computedData[0])),o=_({fullDataFormatter:l.fullDataFormatter$,gridIndex:t}).pipe(L(r),S(i=>{const T=i.fullDataFormatter.gridList[0];return{type:"grid",grid:{...i.fullDataFormatter.gridList[i.gridIndex]??T},container:{...i.fullDataFormatter.container}}})),e=_({multiGridEachDetail:l.multiGridEachDetail$,gridIndex:t}).pipe(L(r),g(async i=>i),S(i=>i.multiGridEachDetail[i.gridIndex]??i.multiGridEachDetail[0]),F(1)),n=e.pipe(g(i=>i.isSeriesPositionSeprate$)),u=e.pipe(g(i=>i.gridContainer$)),p=e.pipe(g(i=>i.gridAxesTransform$)),f=e.pipe(g(i=>i.gridAxesReverseTransform$)),m=e.pipe(g(i=>i.gridAxesSize$)),$=e.pipe(g(i=>i.gridGraphicTransform$)),b=e.pipe(g(i=>i.gridGraphicReverseScale$)),D=e.pipe(g(i=>i.gridHighlight$)),x=e.pipe(g(i=>i.existedSeriesLabels$)),A=e.pipe(g(i=>i.SeriesDataMap$)),y=e.pipe(g(i=>i.GroupDataMap$)),v=e.pipe(g(i=>i.visibleComputedData$));return{gridComputedData$:d,gridDataFormatter$:o,gridAxesTransform$:p,gridGraphicTransform$:$,gridGraphicReverseScale$:b,gridAxesReverseTransform$:f,gridAxesSize$:m,gridHighlight$:D,existedSeriesLabels$:x,SeriesDataMap$:A,GroupDataMap$:y,visibleComputedData$:v,isSeriesPositionSeprate$:n,gridContainer$:u}})))},G="MultiBars",w=xe(G,"grid"),je=B(G,Pe)(({selection:l,name:s,subject:r,observer:a})=>{const c=new C,t=[];return Fe(a).subscribe(o=>{t.forEach(e=>e()),l.selectAll(`g.${w}`).data(o).join("g").attr("class",w).each((e,n,u)=>{const p=oe(u[n]);t[n]=ye(G,{selection:p,computedData$:e.gridComputedData$,visibleComputedData$:e.visibleComputedData$,existedSeriesLabels$:e.existedSeriesLabels$,SeriesDataMap$:e.SeriesDataMap$,GroupDataMap$:e.GroupDataMap$,fullParams$:a.fullParams$,fullChartParams$:a.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridGraphicTransform$:e.gridGraphicTransform$,gridGraphicReverseScale$:e.gridGraphicReverseScale$,gridAxesSize$:e.gridAxesSize$,gridHighlight$:e.gridHighlight$,gridContainer$:e.gridContainer$,isSeriesPositionSeprate$:e.isSeriesPositionSeprate$,event$:r.event$})})}),()=>{c.next(void 0),t.forEach(o=>o())}}),Be=[[[1205,850,930,1111,1500],[735,900,880,1035,1120]],[[55,60,50,70,75],[35,40,45,65,80]]];export{Ue as D,Me as M,je as a,Ve as b,Fe as c,Ee as d,we as e,Oe as f,We as g,Be as m};
