import{S as W,f as x,e as B,t as a,s as u,d as D,g as _,O as Y,h as H,a6 as J}from"./C-r1ajy-.js";import{a as L,k as K,p as q,g as P,n as Q,o as Z}from"./BeiEZ8Ba.js";const X=6;function N({selection:g,xAxisClassName:b,groupingLabelClassName:d,params:s,tickTextAlign:c,axisLabelAlign:k,gridAxesSize:T,fullDataFormatter:M,chartParams:n,groupScale:y,textTransform:v}){const r=g.selectAll(`g.${b}`).data([s]).join("g").classed(b,!0);g.selectAll(`g.${d}`).data([s]).join("g").classed(d,!0).each((A,$,R)=>{_(R[$]).selectAll("text").data([A]).join(l=>l.append("text").style("font-weight","bold"),l=>l,l=>l.remove()).attr("text-anchor",k.textAnchor).attr("dominant-baseline",k.dominantBaseline).attr("font-size",n.styles.textSize).style("fill",L(s.labelColorType,n)).style("transform",v).text(l=>M.grid.groupAxis.label)}).attr("transform",A=>`translate(${T.width+A.tickPadding+s.labelOffset[0]}, ${-A.tickPadding-X-s.labelOffset[1]})`);const h=K(y).scale(y).tickSize(s.tickFullLine==!0?-T.height:X).tickSizeOuter(0).tickFormat(A=>q(A,s.tickFormat)).tickPadding(s.tickPadding),p=r.transition().duration(100).call(h);return p.selectAll("line").style("fill","none").style("stroke",s.tickLineVisible==!0?L(s.tickColorType,n):"none").style("stroke-dasharray",s.tickFullLineDasharray).attr("pointer-events","none"),p.selectAll("path").style("fill","none").style("stroke",s.axisLineVisible==!0?L(s.axisLineColorType,n):"none").style("shape-rendering","crispEdges"),r.selectAll("text").attr("font-size",n.styles.textSize).style("color",L(s.tickTextColorType,n)).attr("text-anchor",c.textAnchor).attr("dominant-baseline",c.dominantBaseline).attr("transform-origin",`0 -${s.tickPadding+X}`).style("transform",v),r}const se=(g,{selection:b,computedData$:d,fullParams$:s,fullDataFormatter$:c,fullChartParams$:k,gridAxesTransform$:T,gridAxesReverseTransform$:M,gridAxesSize$:n,gridContainerPosition$:y,isSeriesSeprate$:v})=>{const r=new W,h=P(g,"container"),p=P(g,"xAxisG"),A=P(g,"xAxis"),$=P(g,"groupingLabel"),R=x({computedData:d.pipe(B((t,e)=>t.length===e.length)),isSeriesSeprate:v}).pipe(a(r),u(async t=>t),D(t=>t.isSeriesSeprate?t.computedData:[t.computedData[0]]),D((t,e)=>b.selectAll(`g.${h}`).data(t,i=>i[0]?i[0].seriesIndex:e).join("g").classed(h,!0))),l=R.pipe(a(r),D((t,e)=>t.selectAll(`g.${p}`).data([p]).join("g").classed(p,!0)));x({containerSelection:R,gridContainerPosition:y}).pipe(a(r),u(async t=>t)).subscribe(t=>{t.containerSelection.attr("transform",(e,i)=>{const o=t.gridContainerPosition[i]??t.gridContainerPosition[0],f=o.translate,m=o.scale;return`translate(${f[0]}, ${f[1]}) scale(${m[0]}, ${m[1]})`})}),x({axisSelection:l,gridAxesTransform:T}).pipe(a(r),u(async t=>t)).subscribe(t=>{t.axisSelection.style("transform",t.gridAxesTransform.value)});const V=x({fullParams:s,fullDataFormatter:c,gridAxesReverseTransform:M,gridContainerPosition:y}).pipe(a(r),u(async t=>t),D(t=>{const e=`translate(${t.gridAxesReverseTransform.translate[0]}px, ${t.gridAxesReverseTransform.translate[1]}px)`,i=`rotate(${t.gridAxesReverseTransform.rotate}deg) rotateX(${t.gridAxesReverseTransform.rotateX}deg) rotateY(${t.gridAxesReverseTransform.rotateY}deg)`,o=`scale(${1/t.gridContainerPosition[0].scale[0]}, ${1/t.gridContainerPosition[0].scale[1]})`,m=`rotate(${t.fullDataFormatter.grid.groupAxis.position==="left"&&t.fullDataFormatter.grid.valueAxis.position==="top"||t.fullDataFormatter.grid.groupAxis.position==="right"&&t.fullDataFormatter.grid.valueAxis.position==="bottom"?t.fullParams.tickTextRotate+180:t.fullParams.tickTextRotate}deg)`;return`${e} ${i} ${o} ${m}`}),B()),z=new Y(t=>{x({fullDataFormatter:c,gridAxesSize:n,computedData:d}).pipe(a(r),u(async e=>e)).subscribe(e=>{const o=e.computedData[0]?e.computedData[0].length-1:0,f=e.fullDataFormatter.grid.groupAxis.scaleDomain[0]==="auto"?0-e.fullDataFormatter.grid.groupAxis.scalePadding:e.fullDataFormatter.grid.groupAxis.scaleDomain[0]-e.fullDataFormatter.grid.groupAxis.scalePadding,m=e.fullDataFormatter.grid.groupAxis.scaleDomain[1]==="auto"?o+e.fullDataFormatter.grid.groupAxis.scalePadding:e.fullDataFormatter.grid.groupAxis.scaleDomain[1]+e.fullDataFormatter.grid.groupAxis.scalePadding,C=e.computedData[0]?e.computedData[0].length:0;let w=(e.computedData[0]??[]).map(j=>j.groupLabel);const G=new Array(C).fill(0).map((j,F)=>w[F]!=null?w[F]:String(F)).filter((j,F)=>F>=f&&F<=m),E=e.fullDataFormatter.grid.groupAxis.scalePadding,I=H({axisLabels:G,axisWidth:e.gridAxesSize.width,padding:E});t.next(I)})}),S=x({fullDataFormatter:c,fullParams:s}).pipe(a(r),u(async t=>t),D(t=>{let e="middle",i="hanging";return t.fullDataFormatter.grid.groupAxis.position==="bottom"?(e=t.fullParams.tickTextRotate?"end":"middle",i="hanging"):t.fullDataFormatter.grid.groupAxis.position==="top"?(e=t.fullParams.tickTextRotate?"end":"middle",i="auto"):t.fullDataFormatter.grid.groupAxis.position==="left"?(e="end",i="middle"):t.fullDataFormatter.grid.groupAxis.position==="right"&&(e="start",i="middle"),{textAnchor:e,dominantBaseline:i}})),O=c.pipe(a(r),D(t=>{let e="start",i="hanging";return t.grid.groupAxis.position==="bottom"?i="hanging":t.grid.groupAxis.position==="top"?i="auto":t.grid.groupAxis.position==="left"?e="end":t.grid.groupAxis.position==="right"&&(e="start"),t.grid.valueAxis.position==="left"?e="start":t.grid.valueAxis.position==="right"?e="end":t.grid.valueAxis.position==="bottom"?i="auto":t.grid.valueAxis.position==="top"&&(i="hanging"),{textAnchor:e,dominantBaseline:i}}));return x({axisSelection:l,params:s,tickTextAlign:S,axisLabelAlign:O,gridAxesSize:n,fullDataFormatter:c,chartParams:k,groupScale:z,textTransform:V}).pipe(a(r),u(async t=>t)).subscribe(t=>{N({selection:t.axisSelection,xAxisClassName:A,groupingLabelClassName:$,params:t.params,tickTextAlign:t.tickTextAlign,axisLabelAlign:t.axisLabelAlign,gridAxesSize:t.gridAxesSize,fullDataFormatter:t.fullDataFormatter,chartParams:t.chartParams,groupScale:t.groupScale,textTransform:t.textTransform})}),()=>{r.next(void 0)}},U=6;function ee({selection:g,yAxisClassName:b,textClassName:d,fullParams:s,tickTextAlign:c,axisLabelAlign:k,gridAxesSize:T,fullDataFormatter:M,fullChartParams:n,valueScale:y,textTransform:v,minAndMax:r}){const h=g.selectAll(`g.${b}`).data([s]).join("g").classed(b,!0);g.selectAll(`g.${d}`).data([s]).join("g").classed(d,!0).each((l,V,z)=>{_(z[V]).selectAll("text").data([l]).join(S=>S.append("text").style("font-weight","bold"),S=>S,S=>S.remove()).attr("text-anchor",k.textAnchor).attr("dominant-baseline",k.dominantBaseline).attr("font-size",n.styles.textSize).style("fill",L(s.labelColorType,n)).style("transform",v).text(S=>M.grid.valueAxis.label)}).attr("transform",l=>`translate(${-l.tickPadding+s.labelOffset[0]}, ${T.height+l.tickPadding+s.labelOffset[1]})`);const p=r[1]-r[0],A=Q(y).scale(y).ticks(p>s.ticks?s.ticks:r[0]===0&&r[1]===0?1:Math.ceil(p)).tickFormat(l=>q(l,s.tickFormat)).tickSize(s.tickFullLine==!0?-T.width:U).tickPadding(s.tickPadding),$=h.transition().duration(100).call(A);return $.selectAll("line").style("fill","none").style("stroke",s.tickLineVisible==!0?L(s.tickColorType,n):"none").style("stroke-dasharray",s.tickFullLineDasharray).attr("pointer-events","none"),$.selectAll("path").style("fill","none").style("stroke",s.axisLineVisible==!0?L(s.axisLineColorType,n):"none").style("shape-rendering","crispEdges"),h.selectAll("text").attr("font-size",n.styles.textSize).style("color",L(s.tickTextColorType,n)).attr("text-anchor",c.textAnchor).attr("dominant-baseline",c.dominantBaseline).attr("transform-origin",`-${s.tickPadding+U} 0`).style("transform",v),h}const re=(g,{selection:b,computedData$:d,fullParams$:s,fullDataFormatter$:c,fullChartParams$:k,gridAxesTransform$:T,gridAxesReverseTransform$:M,gridAxesSize$:n,gridContainerPosition$:y,isSeriesSeprate$:v})=>{const r=new W,h=P(g,"container"),p=P(g,"yAxisG"),A=P(g,"yAxis"),$=P(g,"text"),R=x({computedData:d.pipe(B((e,i)=>e.length===i.length)),isSeriesSeprate:v}).pipe(a(r),u(async e=>e),D(e=>e.isSeriesSeprate?e.computedData:[e.computedData[0]]),D((e,i)=>b.selectAll(`g.${h}`).data(e,o=>o[0]?o[0].seriesIndex:i).join("g").classed(h,!0))),l=R.pipe(a(r),D((e,i)=>e.selectAll(`g.${p}`).data([p]).join("g").classed(p,!0)));x({containerSelection:R,gridContainerPosition:y}).pipe(a(r),u(async e=>e)).subscribe(e=>{e.containerSelection.attr("transform",(i,o)=>{const f=e.gridContainerPosition[o]??e.gridContainerPosition[0],m=f.translate,C=f.scale;return`translate(${m[0]}, ${m[1]}) scale(${C[0]}, ${C[1]})`})}),x({axisSelection:l,gridAxesTransform:T}).pipe(a(r),u(async e=>e)).subscribe(e=>{e.axisSelection.style("transform",e.gridAxesTransform.value)});const V=x({fullParams:s,fullDataFormatter:c,gridAxesReverseTransform:M,gridContainerPosition:y}).pipe(a(r),u(async e=>e),D(e=>{const i=`translate(${e.gridAxesReverseTransform.translate[0]}px, ${e.gridAxesReverseTransform.translate[1]}px)`,o=`rotate(${e.gridAxesReverseTransform.rotate}deg) rotateX(${e.gridAxesReverseTransform.rotateX}deg) rotateY(${e.gridAxesReverseTransform.rotateY}deg)`,f=`scale(${1/e.gridContainerPosition[0].scale[0]}, ${1/e.gridContainerPosition[0].scale[1]})`,C=`rotate(${e.fullDataFormatter.grid.groupAxis.position==="left"&&e.fullDataFormatter.grid.valueAxis.position==="top"||e.fullDataFormatter.grid.groupAxis.position==="right"&&e.fullDataFormatter.grid.valueAxis.position==="bottom"?e.fullParams.tickTextRotate+180:e.fullParams.tickTextRotate}deg)`;return`${i} ${o} ${f} ${C}`}),B()),z=new Y(e=>{x({fullDataFormatter:c,gridAxesSize:n,computedData:d}).pipe(a(r),u(async i=>i)).subscribe(i=>{const f=i.computedData[0]?i.computedData[0].length-1:0,m=i.fullDataFormatter.grid.groupAxis.scaleDomain[0]==="auto"?0-i.fullDataFormatter.grid.groupAxis.scalePadding:i.fullDataFormatter.grid.groupAxis.scaleDomain[0]-i.fullDataFormatter.grid.groupAxis.scalePadding,C=i.fullDataFormatter.grid.groupAxis.scaleDomain[1]==="auto"?f+i.fullDataFormatter.grid.groupAxis.scalePadding:i.fullDataFormatter.grid.groupAxis.scaleDomain[1]+i.fullDataFormatter.grid.groupAxis.scalePadding,w=i.computedData.map((E,I)=>E.filter((j,F)=>F>=m&&F<=C)),G=Z(w.flat());e.next(G)})}),S=new Y(e=>{x({fullDataFormatter:c,gridAxesSize:n,minAndMax:z}).pipe(a(r),u(async i=>i)).subscribe(i=>{const o=J({maxValue:i.minAndMax[1],minValue:i.minAndMax[0],axisWidth:i.gridAxesSize.height,scaleDomain:i.fullDataFormatter.grid.valueAxis.scaleDomain,scaleRange:i.fullDataFormatter.grid.valueAxis.scaleRange});e.next(o)})}),O=c.pipe(a(r),D(e=>{let i="start",o="hanging";return e.grid.valueAxis.position==="left"?(i="end",o="middle"):e.grid.valueAxis.position==="right"?(i="start",o="middle"):e.grid.valueAxis.position==="bottom"?(i="middle",o="hanging"):e.grid.valueAxis.position==="top"&&(i="middle",o="auto"),{textAnchor:i,dominantBaseline:o}})),t=c.pipe(a(r),D(e=>{let i="start",o="hanging";return e.grid.groupAxis.position==="bottom"?o="auto":e.grid.groupAxis.position==="top"?o="hanging":e.grid.groupAxis.position==="left"?i="start":e.grid.groupAxis.position==="right"&&(i="end"),e.grid.valueAxis.position==="left"?i="end":e.grid.valueAxis.position==="right"?i="start":e.grid.valueAxis.position==="bottom"?o="hanging":e.grid.valueAxis.position==="top"&&(o="auto"),{textAnchor:i,dominantBaseline:o}}));return x({axisSelection:l,fullParams:s,tickTextAlign:O,axisLabelAlign:t,computedData:d,gridAxesSize:n,fullDataFormatter:c,fullChartParams:k,valueScale:S,textTransform:V,minAndMax:z}).pipe(a(r),u(async e=>e)).subscribe(e=>{ee({selection:e.axisSelection,yAxisClassName:A,textClassName:$,fullParams:e.fullParams,tickTextAlign:e.tickTextAlign,axisLabelAlign:e.axisLabelAlign,gridAxesSize:e.gridAxesSize,fullDataFormatter:e.fullDataFormatter,fullChartParams:e.fullChartParams,valueScale:e.valueScale,textTransform:e.textTransform,minAndMax:e.minAndMax})}),()=>{r.next(void 0)}};export{se as a,re as c};
