import{av as he,br as Ae,az as Se,ax as ve,bs as De,aC as E,aD as H,aE as Y,aA as te,aH as ee,bt as ie,aG as re,aK as ce,bu as ye,bv as ue,bw as Le,m as v,a as j,j as T,k as $,s as O,d as V,S as Q,ar as q,t as P,bx as ge,g as W,o as Te,bf as $e,bc as Re,bj as B,by as ke,bz as xe,bk as Pe,bl as Ce,bh as me,bA as Ge,bo as Me}from"./CUAujy1K.js";import{c as K,d as Ie}from"./Ctxu_kSH.js";function we(p,n){if(!p.length)return[];try{const t=p.reduce((x,a)=>a.length>x?a.length:x,0),g=p.map((x,a)=>{if(x.length===t)return x;const r=Object.assign([],x);for(let u=r.length;u<t;u++)r[u]=null;return r}).map((x,a)=>x.map((r,u)=>r==null?{id:"",label:"",data:{},value:null}:typeof r=="number"?{id:"",label:"",data:{},value:r}:{id:r.id??"",label:r.label??"",data:r.data??{},value:r.value}));return De(n.seriesDirection,g)}catch{return[]}}const Ne=p=>{const{data:n=[],dataFormatter:t,chartParams:l}=p;if(!n.length)return[];let g;try{const e=we(n,t),x=he({transposedDataGrid:e,dataFormatterGrid:t,chartType:"grid"}),a=Ae({transposedDataGrid:e,dataFormatterGrid:t,chartType:"grid"});let r=0;g=e.map((u,b)=>u.map((m,o)=>{const h=Se("grid",0,b,o),d=a[o],S={id:m.id?m.id:h,index:r,label:m.label?m.label:h,description:m.description??"",data:m.data,value:m.value,gridIndex:0,seriesIndex:b,seriesLabel:x[b],groupIndex:o,groupLabel:d,color:ve(b,l),visible:!0};return S.visible=t.visibleFilter(S,p),r++,S}))}catch(e){throw Error(e)}return g},_e=({computedData$:p,fullDataFormatter$:n,layout$:t})=>{function l(e,x,a){const r=x.groupAxis.position==="top"||x.groupAxis.position==="bottom"?a.width:a.height,u=e[0]?e[0].length-1:0;return K({maxValue:u,minValue:0,axisWidth:r,scaleDomain:[0,u],scaleRange:[0,1]})}function g(e,x,a){const r=x.valueAxis.position==="left"||x.valueAxis.position==="right"?a.height:a.width,u=e.flat();let[b,m]=Le(u);return b===m&&m===0&&(m=1),K({maxValue:m,minValue:b,axisWidth:r,scaleDomain:["auto","auto"],scaleRange:[0,1]})}return E({computedData:p,fullDataFormatter:n,layout:t}).pipe(H(async e=>e),Y(e=>{const x=l(e.computedData,e.fullDataFormatter,e.layout),a=g(e.computedData,e.fullDataFormatter,e.layout),r=a(0);return e.computedData.map((u,b)=>u.map((m,o)=>{const h=x(o),d=a(m.value??0);return{...m,axisX:h,axisY:d,axisYFromZero:d-r}}))}))},ze=({fullDataFormatter$:p,layout$:n})=>{const t=new te;function l({xAxisPosition:x,yAxisPosition:a,width:r,height:u}){return(x==="bottom"||x==="top")&&(a==="left"||a==="right")?{width:r,height:u}:(x==="left"||x==="right")&&(a==="bottom"||a==="top")?{width:u,height:r}:{width:r,height:u}}const g=p.pipe(Y(x=>x.groupAxis.position),ee()),e=p.pipe(Y(x=>x.valueAxis.position),ee());return new ie(x=>{E({groupAxisPosition:g,valueAxisPosition:e,layout:n}).pipe(re(t),H(async a=>a)).subscribe(a=>{const r=l({xAxisPosition:a.groupAxisPosition,yAxisPosition:a.valueAxisPosition,width:a.layout.width,height:a.layout.height});return x.next(r),function(){t.next(void 0)}})})},et=({fullDataFormatter$:p,containerSize$:n})=>ze({fullDataFormatter$:p,layout$:n}),tt=({computedData$:p})=>p.pipe(Y(n=>n.filter(t=>t.length).map(t=>t[0].seriesLabel)),ee((n,t)=>JSON.stringify(n)===JSON.stringify(t))),it=({computedData$:p})=>p.pipe(Y(n=>n.map(l=>l.filter(g=>g.visible==!0)).filter(l=>l.length))),rt=({computedAxesData$:p})=>p.pipe(Y(n=>n.map(l=>l.filter(g=>g.visible==!0)).filter(l=>l.length))),ot=({computedData$:p,fullDataFormatter$:n,layout$:t})=>E({computedData:p,fullDataFormatter:n,layout:t}).pipe(H(async g=>g),Y(g=>{if(g.computedData.length===0)return[{slotIndex:0,rowIndex:0,columnIndex:0,translate:[0,0],scale:[1,1]}];if(g.fullDataFormatter.separateSeries)return ce(g.layout,g.fullDataFormatter.container,g.computedData.length);{const e=ce(g.layout,g.fullDataFormatter.container,1);return g.computedData.map((x,a)=>e[0])}})),st=({isSeriesSeprate$:p,computedData$:n})=>{const t=n.pipe(Y(l=>{const g=new Array(l[0]?l[0].length:0).fill(null).map((x,a)=>l.reduce((r,u)=>{if(u&&u[a]){const b=u[a].value==null||u[a].visible==!1?0:u[a].value;return r+b}return r},0));return l.map((x,a)=>x.map((r,u)=>({...r,value:g[u]})))}));return p.pipe(H(l=>ye(()=>l,n,t)))},nt=({computedData$:p,fullDataFormatter$:n})=>E({computedData:p,fullDataFormatter:n}).pipe(H(async t=>t),Y(t=>{const l=t.fullDataFormatter.groupAxis,g=t.computedData[0]?t.computedData[0].length-1:0,e=l.scaleDomain[0]-l.scalePadding,x=l.scaleDomain[1]==="max"?g+l.scalePadding:l.scaleDomain[1]+l.scalePadding;return[e,x]})),at=({computedData$:p,groupScaleDomainValue$:n})=>E({computedData:p,groupScaleDomainValue:n}).pipe(Y(t=>{const l=t.computedData.map((e,x)=>e.filter((a,r)=>r>=t.groupScaleDomainValue[0]&&r<=t.groupScaleDomainValue[1]&&a.visible==!0));return ue(l)})),lt=({fullDataFormatter$:p,layout$:n})=>{const t=new te;function l({xAxis:g,yAxis:e,width:x,height:a}){if(!g||!e)return{translate:[0,0],scale:[1,1],rotate:0,rotateX:0,rotateY:0,value:""};let r=0,u=0,b=0,m=0,o=0;return g.position==="bottom"?e.position==="left"?(m=180,u=a):e.position==="right"?(m=180,o=180,r=x,u=a):(m=180,u=a):g.position==="top"?e.position==="left"||(e.position==="right"?(o=180,r=x):(m=180,u=a)):g.position==="left"?e.position==="bottom"?(b=-90,u=a):e.position==="top"?(b=-90,o=180):(m=180,u=a):g.position==="right"?e.position==="bottom"?(b=-90,m=180,u=a,r=x):e.position==="top"?(b=-90,m=180,o=180,r=x):(m=180,u=a):(m=180,u=a),{translate:[r,u],scale:[1,1],rotate:b,rotateX:m,rotateY:o,value:`translate(${r}px, ${u}px) rotate(${b}deg) rotateX(${m}deg) rotateY(${o}deg)`}}return new ie(g=>(E({fullDataFormatter:p,layout:n}).pipe(re(t),H(async e=>e)).subscribe(e=>{const x=l({xAxis:e.fullDataFormatter.groupAxis,yAxis:e.fullDataFormatter.valueAxis,width:e.layout.width,height:e.layout.height});g.next(x)}),function(){t.next(void 0)}))},ct=({gridAxesTransform$:p})=>p.pipe(Y(n=>{const t=[0,0],l=[1/n.scale[0],1/n.scale[1]],g=n.rotate*-1,e=n.rotateX*-1,x=n.rotateY*-1;return{translate:t,scale:l,rotate:g,rotateX:e,rotateY:x,value:`translate(${t[0]}px, ${t[1]}px) rotateX(${e}deg) rotateY(${x}deg) rotate(${g}deg)`}})),pt=({computedData$:p,groupScaleDomainValue$:n,filteredMinMaxValue$:t,fullDataFormatter$:l,layout$:g})=>{const e=new te;function x({data:a,groupAxis:r,valueAxis:u,groupScaleDomainValue:b,filteredMinMaxValue:m,width:o,height:h}){let d=0,S=0,s=0,D=0;const A=r.position==="top"||r.position==="bottom"?o:h,y=0,R=a[0]?a[0].length-1:0,z=K({maxValue:R,minValue:y,axisWidth:A,scaleDomain:b,scaleRange:[0,1]}),w=z(y),f=z(R);y==R?(d=0,s=1):(d=w,s=(f-w)/A),m[0]===m[1]&&m[1]===0&&(m[1]=1);const C=u.position==="left"||u.position==="right"?h:o,G=K({maxValue:m[1],minValue:m[0],axisWidth:C,scaleDomain:u.scaleDomain,scaleRange:u.scaleRange}),F=ue(a);F[0]===F[1]&&F[1]===0&&(F[1]=1);const i=G(F[0]>0?0:F[0]),M=G(F[1]<0?0:F[1]);return S=i,D=(M-i)/C,{translate:[d,S],scale:[s,D],rotate:0,rotateX:0,rotateY:0,value:`translate(${d}px, ${S}px) scale(${s}, ${D})`}}return new ie(a=>(E({computedData:p,groupScaleDomainValue:n,filteredMinMaxValue:t,fullDataFormatter:l,layout:g}).pipe(re(e),H(async r=>r)).subscribe(r=>{const u=x({data:r.computedData,groupAxis:r.fullDataFormatter.groupAxis,valueAxis:r.fullDataFormatter.valueAxis,groupScaleDomainValue:r.groupScaleDomainValue,filteredMinMaxValue:r.filteredMinMaxValue,width:r.layout.width,height:r.layout.height});a.next(u)}),function(){e.next(void 0)}))},ut=({gridContainerPosition$:p,gridAxesTransform$:n,gridGraphicTransform$:t})=>E({gridContainerPosition:p,gridAxesTransform:n,gridGraphicTransform:t}).pipe(H(async l=>l),Y(l=>l.gridAxesTransform.rotate==0||l.gridAxesTransform.rotate==180?l.gridContainerPosition.map((g,e)=>[1/l.gridGraphicTransform.scale[0]/l.gridContainerPosition[e].scale[0],1/l.gridGraphicTransform.scale[1]/l.gridContainerPosition[e].scale[1]]):l.gridContainerPosition.map((g,e)=>[1/l.gridGraphicTransform.scale[0]/l.gridContainerPosition[e].scale[1],1/l.gridGraphicTransform.scale[1]/l.gridContainerPosition[e].scale[0]]))),Fe=({selection:p,pluginName:n,clipPathID:t,seriesLabels$:l,gridContainerPosition$:g,gridAxesTransform$:e,gridGraphicTransform$:x})=>{const a=W(n,"series"),r=W(n,"axes"),u=W(n,"graphic"),b=l.pipe(v((d,S)=>p.selectAll(`g.${a}`).data(d,s=>s).join(s=>s.append("g").classed(a,!0).each((D,A,y)=>{O(y[A]).selectAll(`g.${r}`).data([A]).join(R=>R.append("g").classed(r,!0).attr("clip-path",`url(#${t})`).each((z,w,f)=>{O(f[w]).selectAll("defs").data([w]).join("defs"),O(f[w]).selectAll("g").data([w]).join("g").classed(u,!0)}),R=>R,R=>R.remove())}),s=>s,s=>s.remove())),j(1));T({seriesSelection:b,gridContainerPosition:g}).pipe($(async d=>d)).subscribe(d=>{d.seriesSelection.transition().attr("transform",(S,s)=>{const D=d.gridContainerPosition[s]??d.gridContainerPosition[0],A=D.translate,y=D.scale;return`translate(${A[0]}, ${A[1]}) scale(${y[0]}, ${y[1]})`})});const m=T({seriesSelection:b,gridAxesTransform:e}).pipe($(async d=>d),v(d=>d.seriesSelection.select(`g.${r}`).style("transform",d.gridAxesTransform.value)),j(1)),o=m.pipe(v(d=>d.select("defs")),j(1)),h=T({axesSelection:m,gridGraphicTransform:x}).pipe($(async d=>d),v(d=>{const S=d.axesSelection.select(`g.${u}`);return S.transition().duration(50).style("transform",d.gridGraphicTransform.value),S}),j(1));return{seriesSelection$:b,axesSelection$:m,defsSelection$:o,graphicGSelection$:h}},Ve=({selection:p,pluginName:n,computedData$:t,gridContainerPosition$:l,isSeriesSeprate$:g})=>{const e=W(n,"container"),x=T({computedData:t.pipe(V((a,r)=>a.length===r.length)),isSeriesSeprate:g}).pipe($(async a=>a),v(a=>a.isSeriesSeprate?a.computedData:[a.computedData[0]]),v((a,r)=>p.selectAll(`g.${e}`).data(a,u=>u&&u[0]?u[0].seriesIndex:r).join("g").classed(e,!0)),j(1));return T({containerSelection:x,gridContainerPosition:l}).pipe($(async a=>a)).subscribe(a=>{a.containerSelection.attr("transform",(r,u)=>{const b=a.gridContainerPosition[u]??a.gridContainerPosition[0],m=b.translate,o=b.scale;return`translate(${m[0]}, ${m[1]}) scale(${o[0]}, ${o[1]})`})}),x},gt=({fullDataFormatter$:p,gridAxesSize$:n,computedData$:t,fullChartParams$:l,gridContainerPosition$:g,layout$:e})=>{const x=new Q,a=T({fullDataFormatter:p,gridAxesSize:n,computedData:t}).pipe($(async o=>o),v(o=>{const h=o.computedData[0]?o.computedData[0].length-1:0,d=o.fullDataFormatter.groupAxis.scaleDomain[0]-o.fullDataFormatter.groupAxis.scalePadding,S=o.fullDataFormatter.groupAxis.scaleDomain[1]==="max"?h+o.fullDataFormatter.groupAxis.scalePadding:o.fullDataFormatter.groupAxis.scaleDomain[1]+o.fullDataFormatter.groupAxis.scalePadding;return[d,S]}),j(1)),r=T({fullDataFormatter:p,computedData:t}).pipe($(async o=>o),v(o=>o.fullDataFormatter.seriesDirection==="row"?(o.computedData[0]??[]).map(h=>h.groupLabel):o.computedData.map(h=>h[0].groupLabel))),u=T({groupScaleDomain:a,groupLabels:r}).pipe($(async o=>o),v(o=>o.groupLabels.filter((h,d)=>d>=o.groupScaleDomain[0]&&d<=o.groupScaleDomain[1]))),b=g.pipe(v(o=>o.reduce((d,S)=>S.columnIndex>d?S.columnIndex:d,0)+1),V()),m=g.pipe(v(o=>o.reduce((d,S)=>S.rowIndex>d?S.rowIndex:d,0)+1),V());return new q(o=>{T({dataFormatter:p,axisSize:n,fullChartParams:l,scaleRangeGroupLabels:u,groupLabels:r,groupScaleDomain:a,columnAmount:b,rowAmount:m,layout:e}).pipe(P(x),$(async h=>h)).subscribe(h=>{const d=h.dataFormatter.valueAxis.position==="right"||h.dataFormatter.valueAxis.position==="bottom",S=ge({axisLabels:h.scaleRangeGroupLabels,axisWidth:h.axisSize.width,padding:h.dataFormatter.groupAxis.scalePadding,reverse:d}),s=A=>h.dataFormatter.groupAxis.position==="bottom"||h.dataFormatter.groupAxis.position==="top"?A.offsetX-h.fullChartParams.padding.left:A.offsetY-h.fullChartParams.padding.top,D=A=>{const y={offsetX:A.offsetX*h.columnAmount%h.layout.rootWidth,offsetY:A.offsetY*h.rowAmount%h.layout.rootHeight},R=s(y),z=S(R),w=Math.ceil(h.groupScaleDomain[0]),f=z+w;return{groupIndex:f,groupLabel:h.groupLabels[f]??""}};return o.next(D),function(){x.next(void 0)}})})},xt=({rootSelection:p,fullDataFormatter$:n,containerSize$:t,gridAxesContainerSize$:l,computedData$:g,gridContainerPosition$:e,layout$:x})=>{const a=Ie(p,"mousemove"),r=T({fullDataFormatter:n,computedData:g}).pipe($(async s=>s),v(s=>{const D=s.computedData[0]?s.computedData[0].length-1:0,A=s.fullDataFormatter.groupAxis.scaleDomain[0]-s.fullDataFormatter.groupAxis.scalePadding,y=s.fullDataFormatter.groupAxis.scaleDomain[1]==="max"?D+s.fullDataFormatter.groupAxis.scalePadding:s.fullDataFormatter.groupAxis.scaleDomain[1]+s.fullDataFormatter.groupAxis.scalePadding;return[A,y]}),j(1)),u=T({fullDataFormatter:n,computedData:g}).pipe($(async s=>s),v(s=>s.fullDataFormatter.seriesDirection==="row"?(s.computedData[0]??[]).map(D=>D.groupLabel):s.computedData.map(D=>D[0].groupLabel))),b=T({groupScaleDomain:r,groupLabels:u}).pipe($(async s=>s),v(s=>s.groupLabels.filter((D,A)=>A>=s.groupScaleDomain[0]&&A<=s.groupScaleDomain[1]))),m=n.pipe(v(s=>s.valueAxis.position==="right"||s.valueAxis.position==="bottom")),o=T({reverse:m,gridAxesContainerSize:l,scaleRangeGroupLabels:b,fullDataFormatter:n}).pipe($(async s=>s),v(s=>ge({axisLabels:s.scaleRangeGroupLabels,axisWidth:s.gridAxesContainerSize.width,padding:s.fullDataFormatter.groupAxis.scalePadding,reverse:s.reverse}))),h=T({fullDataFormatter:n,rootMousemove:a,gridContainerPosition:e,layout:x}).pipe($(async s=>s),v(s=>{if(s.fullDataFormatter.groupAxis.position==="bottom"||s.fullDataFormatter.groupAxis.position==="top"){let D=s.rootMousemove.offsetX;const y=s.gridContainerPosition.map((R,z)=>{var w;return[R.translate[0],((w=s.gridContainerPosition[z+1])==null?void 0:w.translate[0])??s.layout.rootWidth]}).filter(R=>R[0]<R[1]).find(R=>D>=R[0]&&D<=R[1]);return y&&(D=D-y[0]),D-s.layout.left}else{let D=s.rootMousemove.offsetY;const y=s.gridContainerPosition.map((R,z)=>{var w;return[R.translate[1],((w=s.gridContainerPosition[z+1])==null?void 0:w.translate[1])??s.layout.rootHeight]}).filter(R=>R[0]<R[1]).find(R=>D>=R[0]&&D<=R[1]);return y&&(D=D-y[0]),D-s.layout.top}})),d=T({xIndexScale:o,axisValue:h,groupScaleDomain:r}).pipe($(async s=>s),v(s=>{const D=s.xIndexScale(s.axisValue),A=Math.ceil(s.groupScaleDomain[0]);return D+A})),S=T({groupIndex:d,groupLabels:u}).pipe($(async s=>s),v(s=>s.groupLabels[s.groupIndex]??""));return T({groupIndex:d,groupLabel:S}).pipe($(async s=>s),v(s=>({groupIndex:s.groupIndex,groupLabel:s.groupLabel})))},fe=.3;function pe({axisWidth:p,groupAmount:n,barAmountOfGroup:t,barPadding:l=0,barGroupPadding:g=0}){const x=((n>1?p/(n-1):p)-g)/t-l;return x>1?x:1}function We(p,n,t){const l=p/2,g=p*n.length+t.barPadding*n.length;return $e().domain(n).range([-g/2+l,g/2-l])}function Ye(p,n){return p<=1?0:n/(p-1)*fe}function Oe(p,n){return p<=1?n:n*(1-fe)}function Xe({graphicGSelection:p,rectClassName:n,visibleComputedAxesData:t,zeroYArr:l,groupLabels:g,barScale:e,params:x,chartParams:a,barWidth:r,transformedBarRadius:u,delayGroup:b,transitionItem:m,isSeriesSeprate:o}){const h=r/2;return p.each((S,s,D)=>{O(D[s]).selectAll(`rect.${n}`).data(t[s]??[],A=>A.id).join(A=>A.append("rect").classed(n,!0).attr("cursor","pointer").attr("height",y=>1),A=>A,A=>A.remove()).attr("transform",(A,y)=>`translate(${(A?A.axisX:0)-h}, 0)`).attr("fill",A=>A.color).attr("y",A=>A.axisY<l[s]?A.axisY:l[s]).attr("x",A=>o?0:e(A.seriesLabel)).attr("width",r).attr("rx",u[s][0]??1).attr("ry",u[s][1]??1).transition().duration(m).ease(Re(a.transitionEase)).delay((A,y)=>A.groupIndex*b).attr("height",A=>Math.abs(A.axisYFromZero)||1)}),p.selectAll(`rect.${n}`)}function je({defsSelection:p,clipPathData:n}){p.selectAll("clipPath").data(n).join(t=>t.append("clipPath"),t=>t,t=>t.remove()).attr("id",t=>t.id).each((t,l,g)=>{O(g[l]).selectAll("rect").data([t]).join(e=>e.append("rect"),e=>e,e=>e.remove()).attr("x",0).attr("y",0).attr("width",e=>e.width).attr("height",e=>e.height)})}function Be({selection:p,ids:n,fullChartParams:t}){if(p.interrupt("highlight"),!n.length){p.transition("highlight").duration(200).style("opacity",1);return}p.each((l,g,e)=>{n.includes(l.id)?O(e[g]).style("opacity",1):O(e[g]).style("opacity",t.styles.unhighlightedOpacity)})}const mt=(p,{selection:n,computedData$:t,computedAxesData$:l,visibleComputedData$:g,visibleComputedAxesData$:e,seriesLabels$:x,SeriesDataMap$:a,GroupDataMap$:r,fullParams$:u,fullChartParams$:b,gridAxesTransform$:m,gridGraphicTransform$:o,gridGraphicReverseScale$:h,gridAxesSize$:d,gridHighlight$:S,gridContainerPosition$:s,isSeriesSeprate$:D,event$:A})=>{const y=new Q,R=Te(p,"clipPath-box"),z=W(p,"rect"),{seriesSelection$:w,axesSelection$:f,defsSelection$:C,graphicGSelection$:G}=Fe({selection:n,pluginName:p,clipPathID:R,seriesLabels$:x,gridContainerPosition$:s,gridAxesTransform$:m,gridGraphicTransform$:o}),F=e.pipe(P(y),v(c=>c.map(k=>k[0]?k[0].axisY-k[0].axisYFromZero:0)),V()),i=T({computedData:t,visibleComputedData:g,params:u,gridAxesSize:d,isSeriesSeprate:D}).pipe(P(y),$(async c=>c),v(c=>c.params.barWidth?c.params.barWidth:c.isSeriesSeprate?pe({axisWidth:c.gridAxesSize.width,groupAmount:c.computedData[0]?c.computedData[0].length:0,barAmountOfGroup:1,barPadding:c.params.barPadding,barGroupPadding:c.params.barGroupPadding}):pe({axisWidth:c.gridAxesSize.width,groupAmount:c.computedData[0]?c.computedData[0].length:0,barAmountOfGroup:c.visibleComputedData.length,barPadding:c.params.barPadding,barGroupPadding:c.params.barGroupPadding})),V()),M=T({computedData:t,barWidth:i,params:u,gridGraphicReverseScale:h}).pipe(P(y),$(async c=>c),v(c=>{const k=c.barWidth/2,L=c.params.barRadius===!0?k:c.params.barRadius===!1?0:typeof c.params.barRadius=="number"?c.params.barRadius:0;return c.computedData.map((ne,be)=>{const ae=c.gridGraphicReverseScale[be]??c.gridGraphicReverseScale[0];let Z=L*ae[0],N=L*ae[1];if(Z>k){const le=k/Z;Z=Z*le,N=N*le}return[Z,N]})})),I=g.pipe(P(y),v(c=>{const k=new Set;return c.forEach(L=>{L.forEach(ne=>{k.add(ne.groupLabel)})}),Array.from(k)})),X=T({seriesLabels:x,barWidth:i,params:u}).pipe(P(y),$(async c=>c),v(c=>We(c.barWidth,c.seriesLabels,c.params))),U=b.pipe(P(y),v(c=>c.transitionDuration),V()),J=new q(c=>{T({groupLabels:I,transitionDuration:U}).pipe($(async k=>k)).subscribe(k=>{const L=Ye(k.groupLabels.length,k.transitionDuration);c.next(L)})}).pipe(P(y),V()),de=new q(c=>{T({groupLabels:I,transitionDuration:U}).pipe($(async k=>k)).subscribe(k=>{const L=Oe(k.groupLabels.length,k.transitionDuration);c.next(L)})}).pipe(P(y),V());T({defsSelection:C,gridAxesSize:d}).pipe(P(y),$(async c=>c)).subscribe(c=>{const k=[{id:R,width:c.gridAxesSize.width,height:c.gridAxesSize.height}];je({defsSelection:c.defsSelection,clipPathData:k})});const oe=b.pipe(P(y),v(c=>c.highlightTarget),V()),se=T({graphicGSelection:G,visibleComputedAxesData:e,zeroYArr:F,groupLabels:I,barScale:X,params:u,chartParams:b,highlightTarget:oe,barWidth:i,transformedBarRadius:M,delayGroup:J,transitionItem:de,isSeriesSeprate:D}).pipe(P(y),$(async c=>c),v(c=>Xe({graphicGSelection:c.graphicGSelection,rectClassName:z,visibleComputedAxesData:c.visibleComputedAxesData,zeroYArr:c.zeroYArr,groupLabels:c.groupLabels,barScale:c.barScale,params:c.params,chartParams:c.chartParams,barWidth:c.barWidth,transformedBarRadius:c.transformedBarRadius,delayGroup:c.delayGroup,transitionItem:c.transitionItem,isSeriesSeprate:c.isSeriesSeprate})));return T({barSelection:se,computedData:t,highlightTarget:oe,SeriesDataMap:a,GroupDataMap:r}).pipe(P(y),$(async c=>c)).subscribe(c=>{c.barSelection.on("mouseover",(k,L)=>{k.stopPropagation(),A.next({type:"grid",eventName:"mouseover",pluginName:p,highlightTarget:c.highlightTarget,datum:L,gridIndex:L.gridIndex,series:c.SeriesDataMap.get(L.seriesLabel),seriesIndex:L.seriesIndex,seriesLabel:L.seriesLabel,group:c.GroupDataMap.get(L.groupLabel),groupIndex:L.groupIndex,groupLabel:L.groupLabel,event:k,data:c.computedData})}).on("mousemove",(k,L)=>{k.stopPropagation(),A.next({type:"grid",eventName:"mousemove",pluginName:p,highlightTarget:c.highlightTarget,datum:L,gridIndex:L.gridIndex,series:c.SeriesDataMap.get(L.seriesLabel),seriesIndex:L.seriesIndex,seriesLabel:L.seriesLabel,group:c.GroupDataMap.get(L.groupLabel),groupIndex:L.groupIndex,groupLabel:L.groupLabel,event:k,data:c.computedData})}).on("mouseout",(k,L)=>{k.stopPropagation(),A.next({type:"grid",eventName:"mouseout",pluginName:p,highlightTarget:c.highlightTarget,datum:L,gridIndex:L.gridIndex,series:c.SeriesDataMap.get(L.seriesLabel),seriesIndex:L.seriesIndex,seriesLabel:L.seriesLabel,group:c.GroupDataMap.get(L.groupLabel),groupIndex:L.groupIndex,groupLabel:L.groupLabel,event:k,data:c.computedData})}).on("click",(k,L)=>{k.stopPropagation(),A.next({type:"grid",eventName:"click",pluginName:p,highlightTarget:c.highlightTarget,datum:L,gridIndex:L.gridIndex,series:c.SeriesDataMap.get(L.seriesLabel),seriesIndex:L.seriesIndex,seriesLabel:L.seriesLabel,group:c.GroupDataMap.get(L.groupLabel),groupIndex:L.groupIndex,groupLabel:L.groupLabel,event:k,data:c.computedData})})}),T({barSelection:se,highlight:S.pipe(v(c=>c.map(k=>k.id))),fullChartParams:b}).pipe(P(y),$(async c=>c)).subscribe(c=>{Be({selection:c.barSelection,ids:c.highlight,fullChartParams:c.fullChartParams})}),()=>{y.next(void 0)}},_=6;function Ee(p,n){return p.map((t,l)=>{const g=me(t,n),e=typeof g=="string"?g.split(`
`):[g];return{text:g,textArr:e}})}function He({selection:p,groupingLabelClassName:n,fullParams:t,axisLabelAlign:l,gridAxesSize:g,fullDataFormatter:e,chartParams:x,textReverseTransform:a}){const r=t.tickPadding+t.labelOffset[0],u=t.tickPadding+t.labelOffset[1];let b=0,m=0;e.groupAxis.position==="bottom"?(m=u,e.valueAxis.position==="left"?b=r:e.valueAxis.position==="right"&&(b=-r)):e.groupAxis.position==="top"?(m=-u,e.valueAxis.position==="left"?b=r:e.valueAxis.position==="right"&&(b=-r)):e.groupAxis.position==="left"?(b=-r,e.valueAxis.position==="bottom"?m=-u:e.valueAxis.position==="top"&&(m=u)):e.groupAxis.position==="right"&&(b=r,e.valueAxis.position==="bottom"?m=-u:e.valueAxis.position==="top"&&(m=u)),p.selectAll(`g.${n}`).data([t]).join("g").classed(n,!0).each((o,h,d)=>{O(d[h]).selectAll("text").data([o]).join(S=>S.append("text").style("font-weight","bold"),S=>S,S=>S.remove()).attr("text-anchor",l.textAnchor).attr("dominant-baseline",l.dominantBaseline).attr("font-size",x.styles.textSize).style("fill",B(t.labelColorType,x)).style("transform",a).attr("x",b).attr("y",m).text(S=>e.groupAxis.label)}).attr("transform",o=>`translate(${g.width}, 0)`)}function Ue({selection:p,xAxisClassName:n,fullParams:t,tickTextAlign:l,gridAxesSize:g,fullDataFormatter:e,chartParams:x,groupScale:a,groupScaleDomain:r,groupLabelData:u,textReverseTransformWithRotate:b,textSizePx:m}){const o=p.selectAll(`g.${n}`).data([t]).join("g").classed(n,!0),h=Math.floor(r[1])-Math.ceil(r[0])+1;let d=0,S=0;e.groupAxis.position==="left"?(d=0,S=-t.tickPadding):e.groupAxis.position==="right"?(d=0,S=t.tickPadding):e.groupAxis.position==="bottom"?(t.tickFullLine==!0?d=-t.tickPadding:d=-t.tickPadding-_,S=0):e.groupAxis.position==="top"&&(t.tickFullLine==!0?d=t.tickPadding:d=t.tickPadding-_,S=-0);const s=ke(a).scale(a).ticks(t.ticks==="all"||t.ticks>h?h:t.ticks).tickSize(t.tickFullLine==!0?-g.height:_).tickSizeOuter(0).tickFormat(y=>{var R;return((R=u[y])==null?void 0:R.text)??""}).tickPadding(d),D=o.transition().duration(100).ease(xe).call(s).on("end",(y,R)=>{o.selectAll(".tick text").each((z,w,f)=>{var G;const C=((G=u[z])==null?void 0:G.textArr)??[];Pe(O(f[w]),{textArr:C,textSizePx:m,groupAxisPosition:e.groupAxis.position,isContainerRotated:!0})})});return D.selectAll("line").style("fill","none").style("stroke",t.tickLineVisible==!0?B(t.tickColorType,x):"none").style("stroke-dasharray",t.tickFullLineDasharray).style("vector-effect","non-scaling-stroke").attr("pointer-events","none"),D.selectAll("path").style("fill","none").style("stroke",t.axisLineVisible==!0?B(t.axisLineColorType,x):"none").style("shape-rendering","crispEdges"),o.selectAll("text").attr("font-size",x.styles.textSize).attr("fill",B(t.tickTextColorType,x)).attr("text-anchor",l.textAnchor).attr("dominant-baseline",l.dominantBaseline).attr("x",S).style("transform",b).attr("dy",0),o}const ft=(p,{selection:n,computedData$:t,fullParams$:l,fullDataFormatter$:g,fullChartParams$:e,gridAxesTransform$:x,gridAxesReverseTransform$:a,gridAxesSize$:r,gridContainerPosition$:u,isSeriesSeprate$:b,textSizePx$:m})=>{const o=new Q,h=W(p,"container"),d=W(p,"xAxisG"),S=W(p,"xAxis"),s=W(p,"groupingLabel"),D=T({computedData:t.pipe(V((i,M)=>i.length===M.length)),isSeriesSeprate:b}).pipe(P(o),$(async i=>i),v(i=>i.isSeriesSeprate?i.computedData:[i.computedData[0]]),v((i,M)=>n.selectAll(`g.${h}`).data(i,I=>I&&I[0]?I[0].seriesIndex:M).join("g").classed(h,!0))),A=D.pipe(P(o),v((i,M)=>i.selectAll(`g.${d}`).data([d]).join("g").classed(d,!0)));T({containerSelection:D,gridContainerPosition:u}).pipe(P(o),$(async i=>i)).subscribe(i=>{i.containerSelection.attr("transform",(M,I)=>{const X=i.gridContainerPosition[I]??i.gridContainerPosition[0],U=X.translate,J=X.scale;return`translate(${U[0]}, ${U[1]}) scale(${J[0]}, ${J[1]})`})}),T({axisSelection:A,gridAxesTransform:x}).pipe(P(o),$(async i=>i)).subscribe(i=>{i.axisSelection.style("transform",i.gridAxesTransform.value)});const y=T({gridAxesReverseTransform:a,gridContainerPosition:u}).pipe(P(o),$(async i=>i),v(i=>{const M=`rotateX(${i.gridAxesReverseTransform.rotateX}deg) rotateY(${i.gridAxesReverseTransform.rotateY}deg)`,I=`rotate(${i.gridAxesReverseTransform.rotate}deg)`,X=`scale(${1/i.gridContainerPosition[0].scale[0]}, ${1/i.gridContainerPosition[0].scale[1]})`;return`${M} ${I} ${X}`}),V()),R=T({textReverseTransform:y,fullParams:l}).pipe(P(o),$(async i=>i),v(i=>`${i.textReverseTransform} rotate(${i.fullParams.tickTextRotate}deg)`)),z=T({fullDataFormatter:g,gridAxesSize:r,computedData:t}).pipe(P(o),$(async i=>i),v(i=>{const M=i.computedData[0]?i.computedData[0].length-1:0,I=i.fullDataFormatter.groupAxis.scaleDomain[0]-i.fullDataFormatter.groupAxis.scalePadding,X=i.fullDataFormatter.groupAxis.scaleDomain[1]==="max"?M+i.fullDataFormatter.groupAxis.scalePadding:i.fullDataFormatter.groupAxis.scaleDomain[1]+i.fullDataFormatter.groupAxis.scalePadding;return[I,X]}),j(1)),w=T({groupScaleDomain:z,gridAxesSize:r}).pipe(P(o),$(async i=>i),v(i=>Ce().domain(i.groupScaleDomain).range([0,i.gridAxesSize.width]))),f=t.pipe(v(i=>(i[0]??[]).map(M=>M.groupLabel))),C=T({fullDataFormatter:g,fullParams:l}).pipe(P(o),$(async i=>i),v(i=>{let M="middle",I="hanging";return i.fullDataFormatter.groupAxis.position==="bottom"?(M=i.fullParams.tickTextRotate?"end":"middle",I="hanging"):i.fullDataFormatter.groupAxis.position==="top"?(M=i.fullParams.tickTextRotate?"start":"middle",I="auto"):i.fullDataFormatter.groupAxis.position==="left"?(M="end",I="middle"):i.fullDataFormatter.groupAxis.position==="right"&&(M="start",I="middle"),{textAnchor:M,dominantBaseline:I}})),G=g.pipe(P(o),v(i=>{let M="start",I="hanging";return i.groupAxis.position==="bottom"?I="hanging":i.groupAxis.position==="top"?I="auto":i.groupAxis.position==="left"?M="end":i.groupAxis.position==="right"&&(M="start"),i.valueAxis.position==="left"?M="start":i.valueAxis.position==="right"?M="end":i.valueAxis.position==="bottom"?I="auto":i.valueAxis.position==="top"&&(I="hanging"),{textAnchor:M,dominantBaseline:I}})),F=T({groupLabels:f,fullParams:l}).pipe(P(o),$(async i=>i),v(i=>Ee(i.groupLabels,i.fullParams.tickFormat)));return T({axisSelection:A,fullParams:l,tickTextAlign:C,axisLabelAlign:G,gridAxesSize:r,fullDataFormatter:g,chartParams:e,groupScale:w,groupScaleDomain:z,groupLabelData:F,textReverseTransform:y,textReverseTransformWithRotate:R,textSizePx:m}).pipe(P(o),$(async i=>i)).subscribe(i=>{Ue({selection:i.axisSelection,xAxisClassName:S,fullParams:i.fullParams,tickTextAlign:i.tickTextAlign,gridAxesSize:i.gridAxesSize,fullDataFormatter:i.fullDataFormatter,chartParams:i.chartParams,groupScale:i.groupScale,groupScaleDomain:i.groupScaleDomain,groupLabelData:i.groupLabelData,textReverseTransformWithRotate:i.textReverseTransformWithRotate,textSizePx:i.textSizePx}),He({selection:i.axisSelection,groupingLabelClassName:s,fullParams:i.fullParams,axisLabelAlign:i.axisLabelAlign,gridAxesSize:i.gridAxesSize,fullDataFormatter:i.fullDataFormatter,chartParams:i.chartParams,textReverseTransform:i.textReverseTransform})}),()=>{o.next(void 0)}},Ze=6;function Je({selection:p,textClassName:n,fullParams:t,axisLabelAlign:l,gridAxesSize:g,fullDataFormatter:e,fullChartParams:x,textReverseTransform:a}){const r=t.tickPadding-t.labelOffset[0],u=t.tickPadding+t.labelOffset[1];let b=0,m=0;e.groupAxis.position==="bottom"?(m=-u,e.valueAxis.position==="left"?b=-r:e.valueAxis.position==="right"&&(b=r)):e.groupAxis.position==="top"?(m=u,e.valueAxis.position==="left"?b=-r:e.valueAxis.position==="right"&&(b=r)):e.groupAxis.position==="left"?(b=r,e.valueAxis.position==="bottom"?m=u:e.valueAxis.position==="top"&&(m=-u)):e.groupAxis.position==="right"&&(b=-r,e.valueAxis.position==="bottom"?m=u:e.valueAxis.position==="top"&&(m=-u)),p.selectAll(`g.${n}`).data([t]).join("g").classed(n,!0).each((o,h,d)=>{O(d[h]).selectAll("text").data([o]).join(S=>S.append("text").style("font-weight","bold"),S=>S,S=>S.remove()).attr("text-anchor",l.textAnchor).attr("dominant-baseline",l.dominantBaseline).attr("font-size",x.styles.textSize).style("fill",B(t.labelColorType,x)).style("transform",a).attr("x",b).attr("y",m).text(S=>e.valueAxis.label)}).attr("transform",o=>`translate(0, ${g.height})`)}function qe({selection:p,yAxisClassName:n,fullParams:t,tickTextAlign:l,gridAxesSize:g,fullDataFormatter:e,fullChartParams:x,valueScale:a,textReverseTransformWithRotate:r,filteredMinMaxValue:u}){const b=p.selectAll(`g.${n}`).data([t]).join("g").classed(n,!0);let m=0,o=0;e.valueAxis.position==="left"?(m=t.tickPadding,o=0):e.valueAxis.position==="right"?(m=-t.tickPadding,o=0):e.valueAxis.position==="bottom"?(m=0,o=t.tickPadding):e.valueAxis.position==="top"&&(m=0,o=-t.tickPadding);const h=Ge(a).scale(a).ticks(t.ticks).tickFormat(s=>me(s,t.tickFormat)).tickSize(t.tickFullLine==!0?-g.width:Ze).tickPadding(m),d=b.transition().duration(100).ease(xe).call(h);d.selectAll("line").style("fill","none").style("stroke",t.tickLineVisible==!0?B(t.tickColorType,x):"none").style("stroke-dasharray",t.tickFullLineDasharray).style("vector-effect","non-scaling-stroke").attr("pointer-events","none"),d.selectAll("path").style("fill","none").style("stroke",t.axisLineVisible==!0?B(t.axisLineColorType,x):"none").style("shape-rendering","crispEdges");const S=b.selectAll("text").attr("font-size",x.styles.textSize).style("color",B(t.tickTextColorType,x)).attr("text-anchor",l.textAnchor).attr("dominant-baseline",l.dominantBaseline).attr("y",o).attr("dy",0);return S.style("transform",r),(e.valueAxis.position==="bottom"||e.valueAxis.position==="top")&&S.attr("dy",0),b}const dt=(p,{selection:n,computedData$:t,filteredMinMaxValue$:l,fullParams$:g,fullDataFormatter$:e,fullChartParams$:x,gridAxesSize$:a,gridAxesTransform$:r,gridAxesReverseTransform$:u,gridContainerPosition$:b,isSeriesSeprate$:m})=>{const o=new Q,h=W(p,"yAxisG"),d=W(p,"yAxis"),S=W(p,"text"),D=Ve({selection:n,pluginName:p,computedData$:t,gridContainerPosition$:b,isSeriesSeprate$:m}).pipe(P(o),v((f,C)=>f.selectAll(`g.${h}`).data([h]).join("g").classed(h,!0)));T({axisSelection:D,gridAxesTransform:r}).pipe(P(o),$(async f=>f)).subscribe(f=>{f.axisSelection.style("transform",f.gridAxesTransform.value)});const A=T({gridAxesReverseTransform:u,gridContainerPosition:b}).pipe(P(o),$(async f=>f),v(f=>{const C=`rotateX(${f.gridAxesReverseTransform.rotateX}deg) rotateY(${f.gridAxesReverseTransform.rotateY}deg)`,G=`rotate(${f.gridAxesReverseTransform.rotate}deg)`,F=`scale(${1/f.gridContainerPosition[0].scale[0]}, ${1/f.gridContainerPosition[0].scale[1]})`;return`${C} ${G} ${F}`}),V()),y=T({textReverseTransform:A,fullParams:g}).pipe(P(o),$(async f=>f),v(f=>`${f.textReverseTransform} rotate(${f.fullParams.tickTextRotate}deg)`)),R=new q(f=>{T({fullDataFormatter:e,gridAxesSize:a,filteredMinMaxValue:l}).pipe(P(o),$(async C=>C)).subscribe(C=>{let G=C.filteredMinMaxValue[1],F=C.filteredMinMaxValue[0];G===F&&G===0&&(G=1);const i=Me({maxValue:G,minValue:F,axisWidth:C.gridAxesSize.height,scaleDomain:C.fullDataFormatter.valueAxis.scaleDomain,scaleRange:C.fullDataFormatter.valueAxis.scaleRange});f.next(i)})}),z=T({fullDataFormatter:e,fullParams:g}).pipe(P(o),$(async f=>f),v(f=>{let C="start",G="hanging";return f.fullDataFormatter.valueAxis.position==="left"?(C="end",G="middle"):f.fullDataFormatter.valueAxis.position==="right"?(C="start",G="middle"):f.fullDataFormatter.valueAxis.position==="bottom"?(C=f.fullParams.tickTextRotate?"end":"middle",G="hanging"):f.fullDataFormatter.valueAxis.position==="top"&&(C=f.fullParams.tickTextRotate?"start":"middle",G="auto"),{textAnchor:C,dominantBaseline:G}})),w=e.pipe(P(o),v(f=>{let C="start",G="hanging";return f.groupAxis.position==="bottom"?G="auto":f.groupAxis.position==="top"?G="hanging":f.groupAxis.position==="left"?C="start":f.groupAxis.position==="right"&&(C="end"),f.valueAxis.position==="left"?C="end":f.valueAxis.position==="right"?C="start":f.valueAxis.position==="bottom"?G="hanging":f.valueAxis.position==="top"&&(G="auto"),{textAnchor:C,dominantBaseline:G}}));return T({axisSelection:D,fullParams:g,tickTextAlign:z,axisLabelAlign:w,computedData:t,gridAxesSize:a,fullDataFormatter:e,fullChartParams:x,valueScale:R,textReverseTransform:A,textReverseTransformWithRotate:y,filteredMinMaxValue:l}).pipe(P(o),$(async f=>f)).subscribe(f=>{qe({selection:f.axisSelection,yAxisClassName:d,fullParams:f.fullParams,tickTextAlign:f.tickTextAlign,gridAxesSize:f.gridAxesSize,fullDataFormatter:f.fullDataFormatter,fullChartParams:f.fullChartParams,valueScale:f.valueScale,textReverseTransformWithRotate:f.textReverseTransformWithRotate,filteredMinMaxValue:f.filteredMinMaxValue}),Je({selection:f.axisSelection,textClassName:S,fullParams:f.fullParams,axisLabelAlign:f.axisLabelAlign,gridAxesSize:f.gridAxesSize,fullDataFormatter:f.fullDataFormatter,fullChartParams:f.fullChartParams,textReverseTransform:f.textReverseTransform})}),()=>{o.next(void 0)}};export{dt as a,we as b,mt as c,et as d,tt as e,it as f,ze as g,_e as h,rt as i,st as j,nt as k,at as l,lt as m,ct as n,pt as o,ut as p,ft as q,Fe as r,gt as s,xt as t,ot as u,Ne as v};
