import{S as U,o as ee,t as x,m as b,d as z,k as B,l as M,s as N,b9 as ge,ar as de,ba as me,bb as he,g as X,E as Y,K as xe,h as $e,y as fe,q as ye,ae as De,j as Ae,G as Se,bc as Te,bd as be,be as J,bf as Pe,bg as Le,bh as Ce}from"./ZOIXw5Nq.js";import{o as ae,p as Ie,q as Ge}from"./wO7_YHzT.js";import{f as Re}from"./BbzAf_0F.js";import{c as Me}from"./BxnsOsQw.js";import{c as Be}from"./BhhwBwE2.js";import{m as we}from"./PF0ULQt1.js";import{d as te}from"./B67HsDFx.js";function _e(o="curveLinear",n){return me().x(e=>e.axisX).y0(e=>n).y1(e=>e.axisY).curve(he[o])}function Fe(o){let n=[[]],e=0;for(let r in o){if(o[r].visible==!1||o[r].value===void 0||o[r].value===null){n[e].length&&(e++,n[e]=[]);continue}n[e].push(o[r])}return n}function Ee({selection:o,pathClassName:n,segmentData:e,areaPath:r,linearGradientIds:i,params:s}){return o.selectAll("path").data(e,(l,p)=>l.length?`${l[0].id}_${l[l.length-1].id}`:p).join(l=>l.append("path").classed(n,!0).attr("fill","none").style("vector-effect","non-scaling-stroke").style("cursor","pointer"),l=>l,l=>l.remove()).attr("fill",(l,p)=>l[0]?`url(#${i[l[0].seriesIndex]})`:"").attr("d",l=>r(l))}function Oe({selection:o,seriesLabel:n,fullChartParams:e}){if(o.interrupt("highlight"),!n){o.transition("highlight").duration(200).style("opacity",1);return}o.each((r,i,s)=>{r===n?N(s[i]).style("opacity",1):N(s[i]).style("opacity",e.styles.unhighlightedOpacity)})}function ke({defsSelection:o,computedData:n,linearGradientIds:e,params:r}){o.selectAll("linearGradient").data(n??[]).join(i=>i.append("linearGradient").attr("x1","0%").attr("x2","0%").attr("y1","100%").attr("y2","0%").attr("spreadMethod","pad"),i=>i,i=>i.remove()).attr("id",(i,s)=>i[0]?e[i[0].seriesIndex]:"").html((i,s)=>{const $=i[0]?i[0].color:"";return`
        <stop offset="0%"   stop-color="${$}" stop-opacity="${r.linearGradientOpacity[0]}"/>
        <stop offset="100%" stop-color="${$}" stop-opacity="${r.linearGradientOpacity[1]}"/>
      `})}function ze({defsSelection:o,clipPathData:n,transitionDuration:e,transitionEase:r}){o.selectAll("clipPath").data(n).join(i=>i.append("clipPath"),i=>i,i=>i.remove()).attr("id",i=>i.id).each((i,s,$)=>{N($[s]).selectAll("rect").data([i]).join(l=>{const p=l.append("rect");return p.transition().duration(e).ease(ge(r)).tween("tween",(g,I,S)=>P=>{const y=g.width*P;p.attr("x",0).attr("y",0).attr("width",D=>y).attr("height",D=>D.height)}),p},l=>l.attr("x",0).attr("y",0).attr("width",p=>p.width).attr("height",p=>p.height),l=>l.remove())})}const Ne=(o,{selection:n,computedData$:e,computedAxesData$:r,visibleComputedData$:i,visibleComputedAxesData$:s,seriesLabels$:$,SeriesDataMap$:l,GroupDataMap$:p,fullParams$:g,fullDataFormatter$:I,fullChartParams$:S,gridAxesTransform$:P,gridGraphicTransform$:y,gridAxesSize$:D,gridHighlight$:L,gridContainerPosition$:R,layout$:G,event$:_})=>{const T=new U,F=ee(o,"clipPath-box"),a=X(o,"path"),{seriesSelection$:c,axesSelection$:d,defsSelection$:f,graphicGSelection$:V}=ae({selection:n,pluginName:o,clipPathID:F,seriesLabels$:$,gridContainerPosition$:R,gridAxesTransform$:P,gridGraphicTransform$:y}),E=y.pipe(x(T),b(t=>-t.translate[1]/t.scale[1])),Z=new de(t=>{const A=B({fullParams:g,valueAxisStart:E}).pipe(x(T)).subscribe(h=>{const m=_e(h.fullParams.lineCurve,h.valueAxisStart);t.next(m)});return()=>{A.unsubscribe()}}),C=S.pipe(b(t=>t.transitionDuration),z()),v=S.pipe(b(t=>t.transitionEase),z());B({defsSelection:f,seriesLabels:$,axisSize:D,transitionDuration:C,transitionEase:v}).pipe(x(T),M(async t=>t)).subscribe(t=>{const h=[{id:F,width:t.axisSize.width,height:t.axisSize.height}].concat(t.seriesLabels.map(m=>({id:`orbcharts__clipPath_${m}`,width:t.axisSize.width,height:t.axisSize.height})));ze({defsSelection:t.defsSelection,clipPathData:h,transitionDuration:t.transitionDuration,transitionEase:t.transitionEase})});const se=e.pipe(b(t=>{const A=new Map;return t.flat().forEach(h=>A.set(h.id,h)),A})),le=Ie({fullDataFormatter$:I,gridAxesSize$:D,computedData$:e,fullChartParams$:S,gridContainerPosition$:R,layout$:G}),pe=S.pipe(x(T),b(t=>t.highlightTarget),z()),ue=$.pipe(x(T),b(t=>t.map((A,h)=>ee(o,`lineargradient-${A}`)))),ce=B({graphicGSelection:V,defsSelection:f,visibleComputedAxesData:s,linearGradientIds:ue,areaPath:Z,params:g}).pipe(x(T),M(async t=>t),b(t=>{let A=[];return t.graphicGSelection.each((h,m,w)=>{const H=Fe(t.visibleComputedAxesData[m]??[]);A[m]=Ee({selection:N(w[m]),pathClassName:a,areaPath:t.areaPath,segmentData:H,linearGradientIds:t.linearGradientIds,params:t.params}),ke({defsSelection:t.defsSelection,computedData:t.visibleComputedAxesData,linearGradientIds:t.linearGradientIds,params:t.params})}),A}));return B({pathSelectionArr:ce,computedData:e,SeriesDataMap:l,GroupDataMap:p,highlightTarget:pe,gridGroupPositionFn:le}).pipe(x(T),M(async t=>t)).subscribe(t=>{t.pathSelectionArr.forEach(A=>{A.on("mouseover",(h,m)=>{const w=m[0]?m[0].seriesLabel:"",{groupIndex:H,groupLabel:O}=t.gridGroupPositionFn(h),u=t.GroupDataMap.get(O).find(k=>k.seriesLabel===w)??m[0];_.next({type:"grid",eventName:"mouseover",pluginName:o,highlightTarget:t.highlightTarget,datum:u,gridIndex:u.gridIndex,series:t.SeriesDataMap.get(u.seriesLabel),seriesIndex:u.seriesIndex,seriesLabel:u.seriesLabel,group:t.GroupDataMap.get(u.groupLabel),groupIndex:u.groupIndex,groupLabel:u.groupLabel,event:h,data:t.computedData})}).on("mousemove",(h,m)=>{const w=m[0]?m[0].seriesLabel:"",{groupIndex:H,groupLabel:O}=t.gridGroupPositionFn(h),u=t.GroupDataMap.get(O).find(k=>k.seriesLabel===w)??m[0];_.next({type:"grid",eventName:"mousemove",pluginName:o,highlightTarget:t.highlightTarget,datum:u,gridIndex:u.gridIndex,series:t.SeriesDataMap.get(u.seriesLabel),seriesIndex:u.seriesIndex,seriesLabel:u.seriesLabel,group:t.GroupDataMap.get(u.groupLabel),groupIndex:u.groupIndex,groupLabel:u.groupLabel,event:h,data:t.computedData})}).on("mouseout",(h,m)=>{const w=m[0]?m[0].seriesLabel:"",{groupIndex:H,groupLabel:O}=t.gridGroupPositionFn(h),u=t.GroupDataMap.get(O).find(k=>k.seriesLabel===w)??m[0];_.next({type:"grid",eventName:"mouseout",pluginName:o,highlightTarget:t.highlightTarget,datum:u,gridIndex:u.gridIndex,series:t.SeriesDataMap.get(u.seriesLabel),seriesIndex:u.seriesIndex,seriesLabel:u.seriesLabel,group:t.GroupDataMap.get(u.groupLabel),groupIndex:u.groupIndex,groupLabel:u.groupLabel,event:h,data:t.computedData})}).on("click",(h,m)=>{const w=m[0]?m[0].seriesLabel:"",{groupIndex:H,groupLabel:O}=t.gridGroupPositionFn(h),u=t.GroupDataMap.get(O).find(k=>k.seriesLabel===w)??m[0];_.next({type:"grid",eventName:"click",pluginName:o,highlightTarget:t.highlightTarget,datum:u,gridIndex:u.gridIndex,series:t.SeriesDataMap.get(u.seriesLabel),seriesIndex:u.seriesIndex,seriesLabel:u.seriesLabel,group:t.GroupDataMap.get(u.groupLabel),groupIndex:u.groupIndex,groupLabel:u.groupLabel,event:h,data:t.computedData})})})}),S.pipe(x(T),Re(t=>t.highlightTarget==="series"),M(t=>B({graphicGSelection:V,gridHighlight:L,DataMap:se,fullChartParams:S}).pipe(x(T),M(async A=>A)))).subscribe(t=>{const A=t.gridHighlight[0]?t.gridHighlight[0].seriesLabel:null;Oe({selection:t.graphicGSelection,seriesLabel:A,fullChartParams:t.fullChartParams})}),()=>{T.next(void 0)}},re="LineAreas",Ve={name:re,defaultParams:xe,layerIndex:$e,validator:(o,{validateColumns:n})=>n(o,{lineCurve:{toBeTypes:["string"]},linearGradientOpacity:{toBe:"[number, number]",test:r=>Array.isArray(r)&&r.length===2&&typeof r[0]=="number"&&typeof r[1]=="number"}})},rt=Y(Ve)(({selection:o,name:n,observer:e,subject:r})=>{const i=new U,s=Ne(re,{selection:o,computedData$:e.computedData$,visibleComputedData$:e.visibleComputedData$,computedAxesData$:e.computedAxesData$,visibleComputedAxesData$:e.visibleComputedAxesData$,seriesLabels$:e.seriesLabels$,SeriesDataMap$:e.SeriesDataMap$,GroupDataMap$:e.GroupDataMap$,fullParams$:e.fullParams$,fullDataFormatter$:e.fullDataFormatter$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridGraphicTransform$:e.gridGraphicTransform$,gridAxesSize$:e.gridAxesSize$,gridHighlight$:e.gridHighlight$,gridContainerPosition$:e.gridContainerPosition$,allContainerPosition$:e.gridContainerPosition$,layout$:e.layout$,event$:r.event$});return()=>{i.next(void 0),s()}}),oe="Dots",ve={name:oe,defaultParams:fe,layerIndex:ye,validator:(o,{validateColumns:n})=>n(o,{radius:{toBeTypes:["number"]},fillColorType:{toBeOption:"ColorType"},strokeColorType:{toBeOption:"ColorType"},strokeWidth:{toBeTypes:["number"]},onlyShowHighlighted:{toBeTypes:["boolean"]}})},ot=Y(ve)(({selection:o,name:n,subject:e,observer:r})=>{const i=new U,s=Me(oe,{selection:o,computedData$:r.computedData$,computedAxesData$:r.computedAxesData$,visibleComputedData$:r.visibleComputedData$,visibleComputedAxesData$:r.visibleComputedAxesData$,seriesLabels$:r.seriesLabels$,SeriesDataMap$:r.SeriesDataMap$,GroupDataMap$:r.GroupDataMap$,fullParams$:r.fullParams$,fullChartParams$:r.fullChartParams$,gridAxesTransform$:r.gridAxesTransform$,gridGraphicTransform$:r.gridGraphicTransform$,gridGraphicReverseScale$:r.gridGraphicReverseScale$,gridAxesSize$:r.gridAxesSize$,gridHighlight$:r.gridHighlight$,gridContainerPosition$:r.gridContainerPosition$,event$:e.event$});return()=>{i.next(void 0),s()}}),ne="StackedValueAxis",He={name:ne,defaultParams:De,layerIndex:Ae,validator:(o,{validateColumns:n})=>n(o,{labelOffset:{toBe:"[number, number]",test:r=>Array.isArray(r)&&r.length===2&&typeof r[0]=="number"&&typeof r[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBeTypes:["number","null"]},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}})},nt=Y(He)(({selection:o,name:n,observer:e,subject:r})=>{const i=new U,s=Be(ne,{selection:o,computedData$:e.computedStackedData$,filteredMinMaxValue$:e.filteredMinMaxValue$,fullParams$:e.fullParams$,fullDataFormatter$:e.fullDataFormatter$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridAxesReverseTransform$:e.gridAxesReverseTransform$,gridAxesSize$:e.gridAxesSize$,gridContainerPosition$:e.gridContainerPosition$,isSeriesSeprate$:e.isSeriesSeprate$});return()=>{i.next(void 0),s()}}),W="GroupAux",Q=X(W,"label-box"),K=6,ie=3,Ue={name:W,defaultParams:Se,layerIndex:Te,validator:(o,{validateColumns:n})=>n(o,{showLine:{toBeTypes:["boolean"]},showLabel:{toBeTypes:["boolean"]},lineDashArray:{toBeTypes:["string"]},lineColorType:{toBeOption:"ColorType"},labelColorType:{toBeOption:"ColorType"},labelTextColorType:{toBeOption:"ColorType"},labelTextFormat:{toBeTypes:["string","Function"]},labelPadding:{toBeTypes:["number"]},labelRotate:{toBeTypes:["number"]}})};function We({groupLabel:o,axisX:n,axisHeight:e,fullParams:r}){return r.showLine&&o?[{id:o,x1:n,x2:n,y1:0,y2:e}]:[]}function Xe({groupLabel:o,axisX:n,fullParams:e,textSizePx:r,rowAmount:i}){const s=be(o,e.labelTextFormat),$=s.split(`
`),l=$.reduce((I,S)=>S.length>I.length?S:I,""),p=we(l,r),g=r*$.length;return e.showLabel&&o?[{id:o,x:n,y:-e.labelPadding*i,text:s,textArr:$,textWidth:p,textHeight:g}]:[]}function Ye({selection:o,pluginName:n,lineData:e,fullParams:r,fullChartParams:i}){const s=X(n,"auxline");return o.selectAll(`line.${s}`).data(e).join(l=>l.append("line").classed(s,!0).style("stroke-width",1).style("pointer-events","none").style("vector-effect","non-scaling-stroke").attr("x1",p=>p.x1).attr("y1",p=>p.y1).attr("x2",p=>p.x2).attr("y2",p=>p.y2),l=>l.transition().duration(50).attr("x1",g=>g.x1).attr("y1",g=>g.y1).attr("x2",g=>g.x2).attr("y2",g=>g.y2),l=>l.remove()).style("stroke",l=>J(r.lineColorType,i)).style("stroke-dasharray",r.lineDashArray??"none")}function je(o){o.selectAll("line").data([]).exit().remove()}function qe({selection:o,labelData:n,fullParams:e,fullDataFormatter:r,fullChartParams:i,textReverseTransformWithRotate:s,textSizePx:$}){return o.selectAll(`g.${Q}`).data(n).join(p=>p.append("g").classed(Q,!0).style("cursor","pointer").attr("transform",(g,I)=>`translate(${g.x}, ${g.y})`),p=>p.transition().duration(50).attr("transform",(I,S)=>`translate(${I.x}, ${I.y})`),p=>p.remove()).each((p,g,I)=>{const S=N(I[g]),P=p.textWidth+K*2,y=p.textHeight+ie*2;let D=-P/2,L=-2,R=D,G=L-3;r.groupAxis.position==="bottom"?(D=e.labelRotate?-P+y:-P/2,L=2,R=D,G=L-3):r.groupAxis.position==="left"?(D=-P+2,L=-y/2,R=D,G=L-3,e.labelRotate&&(G+=y)):r.groupAxis.position==="right"?(D=-2,L=-y/2,R=D,G=L-3,e.labelRotate&&(G+=y)):r.groupAxis.position==="top"&&(D=e.labelRotate?-P+y:-P/2,L=-y+6,R=-y,G=L-3);const _=S.selectAll("rect").data([p]).join(c=>c.append("rect").style("cursor","pointer").attr("rx",5).attr("ry",5),c=>c,c=>c.remove()).attr("width",c=>`${P}px`).attr("height",`${y}px`).attr("fill",c=>J(e.labelColorType,i)).attr("x",R).attr("y",G).style("transform",s),T=S.selectAll("text").data([p]).join(c=>c.append("text").style("dominant-baseline","hanging").style("cursor","pointer"),c=>c,c=>c.remove()).style("transform",s).attr("fill",c=>J(e.labelTextColorType,i)).attr("font-size",i.styles.textSize).attr("x",R+K).attr("y",G+ie).each((c,d,f)=>{Pe(N(f[d]),{textArr:p.textArr,textSizePx:$,groupAxisPosition:r.groupAxis.position,isContainerRotated:!1})});let F=[];T.selectAll("tspan").each((c,d,f)=>{const E=N(f[d]).node();E&&E.getBBox()&&F.push(E.getBBox().width)});const a=Math.max(...F);_.attr("width",a+K*2)})}function Ke(o){o.selectAll(`g.${Q}`).data([]).exit().remove()}const st=Y(Ue)(({selection:o,rootSelection:n,name:e,subject:r,observer:i})=>{const s=new U;let $=!1;const l=n.insert("rect","g").classed(X(W,"rect"),!0).attr("opacity",0),{seriesSelection$:p,axesSelection$:g,defsSelection$:I,graphicGSelection$:S}=ae({selection:o,pluginName:W,clipPathID:"test",seriesLabels$:i.isSeriesSeprate$.pipe(M(a=>Le(()=>a,i.seriesLabels$,i.seriesLabels$.pipe(b(c=>[c[0]]))))),gridContainerPosition$:i.gridContainerPosition$,gridAxesTransform$:i.gridAxesTransform$,gridGraphicTransform$:i.gridGraphicTransform$});i.layout$.pipe(x(s)).subscribe(a=>{l.attr("width",a.rootWidth).attr("height",a.rootHeight)});const P=B({groupScaleDomainValue:i.groupScaleDomainValue$,gridAxesSize:i.gridAxesSize$}).pipe(x(s),M(async a=>a),b(a=>Ce().domain(a.groupScaleDomainValue).range([0,a.gridAxesSize.width]))),y=i.fullChartParams$.pipe(x(s),b(a=>a.highlightTarget),z()),D=te(n,"mousemove").pipe(x(s)),L=B({gridAxesReverseTransform:i.gridAxesReverseTransform$,gridContainerPosition:i.gridContainerPosition$}).pipe(x(s),M(async a=>a),b(a=>{const c=`rotateX(${a.gridAxesReverseTransform.rotateX}deg) rotateY(${a.gridAxesReverseTransform.rotateY}deg)`,d=`rotate(${a.gridAxesReverseTransform.rotate}deg)`,f=`scale(${1/a.gridContainerPosition[0].scale[0]}, ${1/a.gridContainerPosition[0].scale[1]})`;return`${c} ${d} ${f}`}),z()),R=B({textReverseTransform:L,fullParams:i.fullParams$}).pipe(x(s),M(async a=>a),b(a=>`${a.textReverseTransform} rotate(${a.fullParams.labelRotate}deg)`)),G=i.gridContainerPosition$.pipe(x(s),b(a=>a.reduce((d,f)=>f.columnIndex>d?f.columnIndex:d,0)+1),z()),_=i.gridContainerPosition$.pipe(x(s),b(a=>a.reduce((d,f)=>f.rowIndex>d?f.rowIndex:d,0)+1),z()),T=Ge({rootSelection:n,fullDataFormatter$:i.fullDataFormatter$,containerSize$:i.containerSize$,gridAxesContainerSize$:i.gridAxesContainerSize$,computedData$:i.computedData$,gridContainerPosition$:i.gridContainerPosition$,layout$:i.layout$}).pipe(x(s));B({axesSelection:g,columnAmount:G,rowAmount:_,layout:i.layout$,rootMousemove:D,gridGroupPosition:T,computedData:i.computedData$,groupScale:P,gridAxesSize:i.gridAxesSize$,fullParams:i.fullParams$,fullDataFormatter:i.fullDataFormatter$,fullChartParams:i.fullChartParams$,highlightTarget:y,textReverseTransformWithRotate:R,GroupDataMap:i.GroupDataMap$,textSizePx:i.textSizePx$}).pipe(x(s),M(async a=>a)).subscribe(a=>{const{groupIndex:c,groupLabel:d}=a.gridGroupPosition,f=a.groupScale(c)??0,V=We({groupLabel:d,axisX:f,axisHeight:a.gridAxesSize.height,fullParams:a.fullParams});Ye({selection:a.axesSelection,pluginName:e,lineData:V,fullParams:a.fullParams,fullChartParams:a.fullChartParams});const E=Xe({groupLabel:d,axisX:f,fullParams:a.fullParams,textSizePx:a.textSizePx,rowAmount:a.rowAmount});qe({selection:a.axesSelection,labelData:E,fullParams:a.fullParams,fullDataFormatter:a.fullDataFormatter,fullChartParams:a.fullChartParams,textReverseTransformWithRotate:a.textReverseTransformWithRotate,textSizePx:a.textSizePx}).on("mouseover",(C,v)=>{C.stopPropagation(),$=!0,r.event$.next({type:"grid",pluginName:e,eventName:"mouseover",highlightTarget:a.highlightTarget,datum:null,gridIndex:0,series:[],seriesIndex:-1,seriesLabel:"",group:a.GroupDataMap.get(d)??[],groupIndex:c,groupLabel:d,event:C,data:a.computedData})}).on("mousemove",(C,v)=>{C.stopPropagation(),r.event$.next({type:"grid",pluginName:e,eventName:"mousemove",highlightTarget:a.highlightTarget,datum:null,gridIndex:0,series:[],seriesIndex:-1,seriesLabel:"",group:a.GroupDataMap.get(d)??[],groupIndex:c,groupLabel:d,event:C,data:a.computedData})}).on("mouseout",(C,v)=>{C.stopPropagation(),$=!1,r.event$.next({type:"grid",pluginName:e,eventName:"mouseout",highlightTarget:a.highlightTarget,datum:null,gridIndex:0,series:[],seriesIndex:-1,seriesLabel:"",group:a.GroupDataMap.get(d)??[],groupIndex:c,groupLabel:d,event:C,data:a.computedData})}).on("click",(C,v)=>{C.stopPropagation(),r.event$.next({type:"grid",pluginName:e,eventName:"click",highlightTarget:a.highlightTarget,datum:null,gridIndex:0,series:[],seriesIndex:-1,seriesLabel:"",group:a.GroupDataMap.get(d)??[],groupIndex:c,groupLabel:d,event:C,data:a.computedData})})});const F=te(l,"mouseout").pipe(x(s));return B({rootRectMouseout:F,axesSelection:g}).pipe(x(s),M(async a=>a)).subscribe(a=>{setTimeout(()=>{$!=!0&&(je(a.axesSelection),Ke(a.axesSelection))})}),()=>{s.next(void 0),l.remove()}});export{ot as D,st as G,rt as L,nt as S,Ne as c};
