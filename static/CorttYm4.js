import{aA as L,aB as w,aC as $,ay as X,aF as Y,br as R,aE as W,aI as E,bs as J,bt as N,bu as q,at as B,bv as Z,ax as K,av as Q,bw as _,m as h,b as I,k as S,l as A,d as M,s as T,a as ee,aT as te,t as re,bx as H,g as O}from"./Bh8imPUI.js";import{c as V,d as oe}from"./CpxqH8xq.js";const ce=({computedData$:p,fullDataFormatter$:l,layout$:i})=>{function a(r,n,t){const o=n.groupAxis.position==="top"||n.groupAxis.position==="bottom"?t.width:t.height,s=r[0]?r[0].length-1:0;return V({maxValue:s,minValue:0,axisWidth:o,scaleDomain:[0,s],scaleRange:[0,1]})}function c(r,n,t){const o=n.valueAxis.position==="left"||n.valueAxis.position==="right"?t.height:t.width,s=r.flat();let[d,m]=q(s);return d===m&&m===0&&(m=1),V({maxValue:m,minValue:d,axisWidth:o,scaleDomain:["auto","auto"],scaleRange:[0,1]})}return L({computedData:p,fullDataFormatter:l,layout:i}).pipe(w(async r=>r),$(r=>{const n=a(r.computedData,r.fullDataFormatter,r.layout),t=c(r.computedData,r.fullDataFormatter,r.layout),o=t(0);return r.computedData.map((s,d)=>s.map((m,u)=>{const f=n(u),g=t(m.value??0);return{...m,axisX:f,axisY:g,axisYFromZero:g-o}}))}))},ae=({fullDataFormatter$:p,layout$:l})=>{const i=new X;function a({xAxisPosition:n,yAxisPosition:t,width:o,height:s}){return(n==="bottom"||n==="top")&&(t==="left"||t==="right")?{width:o,height:s}:(n==="left"||n==="right")&&(t==="bottom"||t==="top")?{width:s,height:o}:{width:o,height:s}}const c=p.pipe($(n=>n.groupAxis.position),Y()),r=p.pipe($(n=>n.valueAxis.position),Y());return new R(n=>{L({groupAxisPosition:c,valueAxisPosition:r,layout:l}).pipe(W(i),w(async t=>t)).subscribe(t=>{const o=a({xAxisPosition:t.groupAxisPosition,yAxisPosition:t.valueAxisPosition,width:t.layout.width,height:t.layout.height});return n.next(o),function(){i.next(void 0)}})})},pe=({fullDataFormatter$:p,containerSize$:l})=>ae({fullDataFormatter$:p,layout$:l}),me=({computedData$:p})=>p.pipe($(l=>l.filter(i=>i.length).map(i=>i[0].seriesLabel)),Y((l,i)=>JSON.stringify(l).length===JSON.stringify(i).length)),ge=({computedData$:p})=>p.pipe($(l=>l.map(a=>a.filter(c=>c.visible==!0)).filter(a=>a.length))),fe=({computedAxesData$:p})=>p.pipe($(l=>l.map(a=>a.filter(c=>c.visible==!0)).filter(a=>a.length))),de=({computedData$:p,fullDataFormatter$:l,layout$:i})=>L({computedData:p,fullDataFormatter:l,layout:i}).pipe(w(async c=>c),$(c=>{if(c.fullDataFormatter.separateSeries)return E(c.layout,c.fullDataFormatter.container,c.computedData.length);{const r=E(c.layout,c.fullDataFormatter.container,1);return c.computedData.map((n,t)=>r[0])}})),xe=({isSeriesSeprate$:p,computedData$:l})=>{const i=l.pipe($(a=>{const c=new Array(a[0]?a[0].length:0).fill(null).map((n,t)=>a.reduce((o,s)=>{if(s&&s[t]){const d=s[t].value==null||s[t].visible==!1?0:s[t].value;return o+d}return o},0));return a.map((n,t)=>n.map((o,s)=>({...o,value:c[s]})))}));return p.pipe(w(a=>J(()=>a,l,i)))},be=({computedData$:p,fullDataFormatter$:l})=>L({computedData:p,fullDataFormatter:l}).pipe(w(async i=>i),$(i=>{const a=i.fullDataFormatter.groupAxis,c=i.computedData[0]?i.computedData[0].length-1:0,r=a.scaleDomain[0]-a.scalePadding,n=a.scaleDomain[1]==="max"?c+a.scalePadding:a.scaleDomain[1]+a.scalePadding;return[r,n]})),De=({computedData$:p,groupScaleDomainValue$:l})=>L({computedData:p,groupScaleDomainValue:l}).pipe($(i=>{const a=i.computedData.map((r,n)=>r.filter((t,o)=>o>=i.groupScaleDomainValue[0]&&o<=i.groupScaleDomainValue[1]&&t.visible==!0));return N(a)})),he=({fullDataFormatter$:p,layout$:l})=>{const i=new X;function a({xAxis:c,yAxis:r,width:n,height:t}){if(!c||!r)return{translate:[0,0],scale:[1,1],rotate:0,rotateX:0,rotateY:0,value:""};let o=0,s=0,d=0,m=0,u=0;return c.position==="bottom"?r.position==="left"?(m=180,s=t):r.position==="right"?(m=180,u=180,o=n,s=t):(m=180,s=t):c.position==="top"?r.position==="left"||(r.position==="right"?(u=180,o=n):(m=180,s=t)):c.position==="left"?r.position==="bottom"?(d=-90,s=t):r.position==="top"?(d=-90,u=180):(m=180,s=t):c.position==="right"?r.position==="bottom"?(d=-90,m=180,s=t,o=n):r.position==="top"?(d=-90,m=180,u=180,o=n):(m=180,s=t):(m=180,s=t),{translate:[o,s],scale:[1,1],rotate:d,rotateX:m,rotateY:u,value:`translate(${o}px, ${s}px) rotate(${d}deg) rotateX(${m}deg) rotateY(${u}deg)`}}return new R(c=>(L({fullDataFormatter:p,layout:l}).pipe(W(i),w(async r=>r)).subscribe(r=>{const n=a({xAxis:r.fullDataFormatter.groupAxis,yAxis:r.fullDataFormatter.valueAxis,width:r.layout.width,height:r.layout.height});c.next(n)}),function(){i.next(void 0)}))},ve=({gridAxesTransform$:p})=>p.pipe($(l=>{const i=[0,0],a=[1/l.scale[0],1/l.scale[1]],c=l.rotate*-1,r=l.rotateX*-1,n=l.rotateY*-1;return{translate:i,scale:a,rotate:c,rotateX:r,rotateY:n,value:`translate(${i[0]}px, ${i[1]}px) rotateX(${r}deg) rotateY(${n}deg) rotate(${c}deg)`}})),Se=({computedData$:p,groupScaleDomainValue$:l,filteredMinMaxValue$:i,fullDataFormatter$:a,layout$:c})=>{const r=new X;function n({data:t,groupAxis:o,valueAxis:s,groupScaleDomainValue:d,filteredMinMaxValue:m,width:u,height:f}){let g=0,x=0,v=0,C=0;const e=o.position==="top"||o.position==="bottom"?u:f,b=0,D=t[0]?t[0].length-1:0,y=V({maxValue:D,minValue:b,axisWidth:e,scaleDomain:d,scaleRange:[0,1]}),F=y(b),G=y(D);b==D?(g=0,v=1):(g=F,v=(G-F)/e),m[0]===m[1]&&m[1]===0&&(m[1]=1);const j=s.position==="left"||s.position==="right"?f:u,z=V({maxValue:m[1],minValue:m[0],axisWidth:j,scaleDomain:s.scaleDomain,scaleRange:s.scaleRange}),P=N(t);P[0]===P[1]&&P[1]===0&&(P[1]=1);const k=z(P[0]>0?0:P[0]),U=z(P[1]<0?0:P[1]);return x=k,C=(U-k)/j,{translate:[g,x],scale:[v,C],rotate:0,rotateX:0,rotateY:0,value:`translate(${g}px, ${x}px) scale(${v}, ${C})`}}return new R(t=>(L({computedData:p,groupScaleDomainValue:l,filteredMinMaxValue:i,fullDataFormatter:a,layout:c}).pipe(W(r),w(async o=>o)).subscribe(o=>{const s=n({data:o.computedData,groupAxis:o.fullDataFormatter.groupAxis,valueAxis:o.fullDataFormatter.valueAxis,groupScaleDomainValue:o.groupScaleDomainValue,filteredMinMaxValue:o.filteredMinMaxValue,width:o.layout.width,height:o.layout.height});t.next(s)}),function(){r.next(void 0)}))},Ae=({gridContainerPosition$:p,gridAxesTransform$:l,gridGraphicTransform$:i})=>L({gridContainerPosition:p,gridAxesTransform:l,gridGraphicTransform:i}).pipe(w(async a=>a),$(a=>a.gridAxesTransform.rotate==0||a.gridAxesTransform.rotate==180?a.gridContainerPosition.map((c,r)=>[1/a.gridGraphicTransform.scale[0]/a.gridContainerPosition[r].scale[0],1/a.gridGraphicTransform.scale[1]/a.gridContainerPosition[r].scale[1]]):a.gridContainerPosition.map((c,r)=>[1/a.gridGraphicTransform.scale[0]/a.gridContainerPosition[r].scale[1],1/a.gridGraphicTransform.scale[1]/a.gridContainerPosition[r].scale[0]])));function ne(p,l){if(!p.length)return[];try{const i=p.reduce((n,t)=>t.length>n?t.length:n,0),c=p.map((n,t)=>{if(n.length===i)return n;const o=Object.assign([],n);for(let s=o.length;s<i;s++)o[s]=null;return o}).map((n,t)=>n.map((o,s)=>o==null?{id:"",label:"",data:{},value:null}:typeof o=="number"?{id:"",label:"",data:{},value:o}:{id:o.id??"",label:o.label??"",data:o.data??{},value:o.value}));return _(l.seriesDirection,c)}catch{return[]}}const ye=p=>{const{data:l=[],dataFormatter:i,chartParams:a}=p;if(!l.length)return[];let c;try{const r=ne(l,i),n=B({transposedDataGrid:r,dataFormatterGrid:i,chartType:"grid"}),t=Z({transposedDataGrid:r,dataFormatterGrid:i,chartType:"grid"});let o=0;c=r.map((s,d)=>s.map((m,u)=>{const f=K("grid",0,d,u),g=t[u],x={id:m.id?m.id:f,index:o,label:m.label?m.label:f,description:m.description??"",data:m.data,value:m.value,gridIndex:0,seriesIndex:d,seriesLabel:n[d],groupIndex:u,groupLabel:g,color:Q(d,a),visible:!0};return x.visible=i.visibleFilter(x,p),o++,x}))}catch(r){throw Error(r)}return c},$e=({selection:p,pluginName:l,clipPathID:i,seriesLabels$:a,gridContainerPosition$:c,gridAxesTransform$:r,gridGraphicTransform$:n})=>{const t=O(l,"series"),o=O(l,"axes"),s=O(l,"graphic"),d=a.pipe(h((g,x)=>p.selectAll(`g.${t}`).data(g,v=>v).join(v=>v.append("g").classed(t,!0).each((C,e,b)=>{T(b[e]).selectAll(`g.${o}`).data([e]).join(D=>D.append("g").classed(o,!0).attr("clip-path",`url(#${i})`).each((y,F,G)=>{T(G[F]).selectAll("defs").data([F]).join("defs"),T(G[F]).selectAll("g").data([F]).join("g").classed(s,!0)}),D=>D,D=>D.remove())}),v=>v,v=>v.remove())),I(1));S({seriesSelection:d,gridContainerPosition:c}).pipe(A(async g=>g)).subscribe(g=>{g.seriesSelection.transition().attr("transform",(x,v)=>{const C=g.gridContainerPosition[v]??g.gridContainerPosition[0],e=C.translate,b=C.scale;return`translate(${e[0]}, ${e[1]}) scale(${b[0]}, ${b[1]})`})});const m=S({seriesSelection:d,gridAxesTransform:r}).pipe(A(async g=>g),h(g=>g.seriesSelection.select(`g.${o}`).style("transform",g.gridAxesTransform.value)),I(1)),u=m.pipe(h(g=>g.select("defs")),I(1)),f=S({axesSelection:m,gridGraphicTransform:n}).pipe(A(async g=>g),h(g=>{const x=g.axesSelection.select(`g.${s}`);return x.transition().duration(50).style("transform",g.gridGraphicTransform.value),x}),I(1));return{seriesSelection$:d,axesSelection$:m,defsSelection$:u,graphicGSelection$:f}},Ce=({selection:p,pluginName:l,computedData$:i,gridContainerPosition$:a,isSeriesSeprate$:c})=>{const r=O(l,"container"),n=S({computedData:i.pipe(M((t,o)=>t.length===o.length)),isSeriesSeprate:c}).pipe(A(async t=>t),h(t=>t.isSeriesSeprate?t.computedData:[t.computedData[0]]),h((t,o)=>p.selectAll(`g.${r}`).data(t,s=>s[0]?s[0].seriesIndex:o).join("g").classed(r,!0)),I(1));return S({containerSelection:n,gridContainerPosition:a}).pipe(A(async t=>t)).subscribe(t=>{t.containerSelection.attr("transform",(o,s)=>{const d=t.gridContainerPosition[s]??t.gridContainerPosition[0],m=d.translate,u=d.scale;return`translate(${m[0]}, ${m[1]}) scale(${u[0]}, ${u[1]})`})}),n},Fe=({fullDataFormatter$:p,gridAxesSize$:l,computedData$:i,fullChartParams$:a,gridContainerPosition$:c,layout$:r})=>{const n=new ee,t=S({fullDataFormatter:p,gridAxesSize:l,computedData:i}).pipe(A(async u=>u),h(u=>{const f=u.computedData[0]?u.computedData[0].length-1:0,g=u.fullDataFormatter.groupAxis.scaleDomain[0]-u.fullDataFormatter.groupAxis.scalePadding,x=u.fullDataFormatter.groupAxis.scaleDomain[1]==="max"?f+u.fullDataFormatter.groupAxis.scalePadding:u.fullDataFormatter.groupAxis.scaleDomain[1]+u.fullDataFormatter.groupAxis.scalePadding;return[g,x]}),I(1)),o=S({fullDataFormatter:p,computedData:i}).pipe(A(async u=>u),h(u=>u.fullDataFormatter.seriesDirection==="row"?(u.computedData[0]??[]).map(f=>f.groupLabel):u.computedData.map(f=>f[0].groupLabel))),s=S({groupScaleDomain:t,groupLabels:o}).pipe(A(async u=>u),h(u=>u.groupLabels.filter((f,g)=>g>=u.groupScaleDomain[0]&&g<=u.groupScaleDomain[1]))),d=c.pipe(h(u=>u.reduce((g,x)=>x.columnIndex>g?x.columnIndex:g,0)+1),M()),m=c.pipe(h(u=>u.reduce((g,x)=>x.rowIndex>g?x.rowIndex:g,0)+1),M());return new te(u=>{S({dataFormatter:p,axisSize:l,fullChartParams:a,scaleRangeGroupLabels:s,groupLabels:o,groupScaleDomain:t,columnAmount:d,rowAmount:m,layout:r}).pipe(re(n),A(async f=>f)).subscribe(f=>{const g=f.dataFormatter.valueAxis.position==="right"||f.dataFormatter.valueAxis.position==="bottom",x=H({axisLabels:f.scaleRangeGroupLabels,axisWidth:f.axisSize.width,padding:f.dataFormatter.groupAxis.scalePadding,reverse:g}),v=e=>f.dataFormatter.groupAxis.position==="bottom"||f.dataFormatter.groupAxis.position==="top"?e.offsetX-f.fullChartParams.padding.left:e.offsetY-f.fullChartParams.padding.top,C=e=>{const b={offsetX:e.offsetX*f.columnAmount%f.layout.rootWidth,offsetY:e.offsetY*f.rowAmount%f.layout.rootHeight},D=v(b),y=x(D),F=Math.ceil(f.groupScaleDomain[0]),G=y+F;return{groupIndex:G,groupLabel:f.groupLabels[G]??""}};return u.next(C),function(){n.next(void 0)}})})},Pe=({rootSelection:p,fullDataFormatter$:l,gridAxesSize$:i,computedData$:a,fullChartParams$:c,gridContainerPosition$:r,layout$:n})=>{const t=oe(p,"mousemove"),o=S({fullDataFormatter:l,gridAxesSize:i,computedData:a}).pipe(A(async e=>e),h(e=>{const b=e.computedData[0]?e.computedData[0].length-1:0,D=e.fullDataFormatter.groupAxis.scaleDomain[0]-e.fullDataFormatter.groupAxis.scalePadding,y=e.fullDataFormatter.groupAxis.scaleDomain[1]==="max"?b+e.fullDataFormatter.groupAxis.scalePadding:e.fullDataFormatter.groupAxis.scaleDomain[1]+e.fullDataFormatter.groupAxis.scalePadding;return[D,y]}),I(1)),s=S({fullDataFormatter:l,computedData:a}).pipe(A(async e=>e),h(e=>e.fullDataFormatter.seriesDirection==="row"?(e.computedData[0]??[]).map(b=>b.groupLabel):e.computedData.map(b=>b[0].groupLabel))),d=S({groupScaleDomain:o,groupLabels:s}).pipe(A(async e=>e),h(e=>e.groupLabels.filter((b,D)=>D>=e.groupScaleDomain[0]&&D<=e.groupScaleDomain[1]))),m=l.pipe(h(e=>e.valueAxis.position==="right"||e.valueAxis.position==="bottom")),u=S({reverse:m,gridAxesSize:i,scaleRangeGroupLabels:d,fullDataFormatter:l}).pipe(A(async e=>e),h(e=>H({axisLabels:e.scaleRangeGroupLabels,axisWidth:e.gridAxesSize.width,padding:e.fullDataFormatter.groupAxis.scalePadding,reverse:e.reverse}))),f=r.pipe(h(e=>e.reduce((D,y)=>y.columnIndex>D?y.columnIndex:D,0)+1),M()),g=r.pipe(h(e=>e.reduce((D,y)=>y.rowIndex>D?y.rowIndex:D,0)+1),M()),x=S({fullDataFormatter:l,fullChartParams:c,rootMousemove:t,columnAmount:f,rowAmount:g,layout:n}).pipe(A(async e=>e),h(e=>{const b={offsetX:e.rootMousemove.offsetX*e.columnAmount%e.layout.rootWidth,offsetY:e.rootMousemove.offsetY*e.rowAmount%e.layout.rootHeight};return e.fullDataFormatter.groupAxis.position==="bottom"||e.fullDataFormatter.groupAxis.position==="top"?b.offsetX-e.fullChartParams.padding.left:b.offsetY-e.fullChartParams.padding.top})),v=S({xIndexScale:u,axisValue:x,groupScaleDomain:o}).pipe(A(async e=>e),h(e=>{const b=e.xIndexScale(e.axisValue),D=Math.ceil(e.groupScaleDomain[0]);return b+D})),C=S({groupIndex:v,groupLabels:s}).pipe(A(async e=>e),h(e=>e.groupLabels[e.groupIndex]??""));return S({groupIndex:v,groupLabel:C}).pipe(A(async e=>e),h(e=>({groupIndex:e.groupIndex,groupLabel:e.groupLabel})))};export{pe as a,me as b,ne as c,ge as d,ce as e,fe as f,ae as g,xe as h,be as i,De as j,he as k,ve as l,Se as m,Ae as n,$e as o,Fe as p,Pe as q,de as r,ye as s,Ce as t};
