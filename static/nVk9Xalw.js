import{aB as h,bd as E,ap as T,aq as P,an as g,au as M,aE as x,ao as u,am as C,be as L,aF as A,bF as B,bG as N,S as D,t as F,m as I,a0 as S,aH as _,a1 as k,ak as w}from"./Dwexfo5s.js";import{c as v}from"./Cngx3B8B.js";import{c as H}from"./CO7k2OkK.js";const U=s=>({status:"success",columnName:"",expectToBe:""}),z=s=>{const{data:t,dataFormatter:e,chartParams:a}=s,n=E();let l=[],c=[];try{let r=[],m=[];if(t.nodes)r=t.nodes,m=t.edges;else if(t[0])r=t[0],m=t[1];else return{nodes:[],edges:[]};const f=(()=>{const o=new Set(e.categoryLabels);for(let p of r){const d=p.categoryLabel??n;o.add(d)}for(let p of m){const d=p.categoryLabel??n;o.add(d)}return Array.from(o)})(),b=new Map(f.map((o,p)=>[o,p]));l=r.map((o,p)=>{const d=o.categoryLabel??n,$=b.get(d)??0,y={id:o.id,index:p,label:o.label??"",description:o.description??"",data:o.data??{},value:o.value??0,categoryIndex:$,categoryLabel:d,color:h($,a),visible:!0};return y.visible=e.visibleFilter(y,s),y});const i=new Map(l.map(o=>[o.id,o]));c=m.map((o,p)=>{const d=o.categoryLabel??n,$=i.get(o.start),y=i.get(o.end);return{id:o.id,index:p,label:o.label??"",description:o.description??"",data:o.data??{},value:o.value??0,categoryIndex:b.get(d),categoryLabel:d,color:h(p,a),startNode:$,endNode:y,visible:$.visible&&y.visible}})}catch(r){throw Error(r)}return{nodes:l,edges:c}},V=s=>({status:"success",columnName:"",expectToBe:""}),W=(s,t)=>T({CategoryNodeMap:s,CategoryEdgeMap:t}).pipe(P(async e=>e),g(e=>[...Array.from(e.CategoryNodeMap.keys()),...Array.from(e.CategoryEdgeMap.keys())]),M((e,a)=>JSON.stringify(e).length===JSON.stringify(a).length)),G=s=>s.pipe(g(t=>{const e=new Map;return t.nodes.forEach(a=>{e.set(a.id,a)}),e})),J=s=>s.pipe(g(t=>{const e=new Map;return t.edges.forEach(a=>{e.set(a.id,a)}),e})),X=({computedData$:s,NodeMap$:t})=>T({computedData:s,NodeMap:t}).pipe(P(async e=>e),g(e=>({nodes:e.computedData.nodes.filter(a=>a.visible),edges:e.computedData.edges.filter(a=>a.visible).filter(a=>e.NodeMap.has(a.startNode.id)&&e.NodeMap.has(a.endNode.id))}))),Y=({subject:s,observer:t})=>{const e=x(t.fullChartParams$).pipe(u(1)),a=C({datumList$:t.computedData$.pipe(g(i=>i.nodes)),fullChartParams$:t.fullChartParams$,event$:s.event$}).pipe(u(1)),n=C({datumList$:t.computedData$.pipe(g(i=>i.edges)),fullChartParams$:t.fullChartParams$,event$:s.event$}).pipe(u(1)),l=L({datumList$:t.computedData$.pipe(g(i=>i.nodes))}).pipe(u(1)),c=L({datumList$:t.computedData$.pipe(g(i=>i.edges))}).pipe(u(1)),r=G(t.computedData$).pipe(u(1)),m=J(t.computedData$).pipe(u(1)),f=W(l,c).pipe(u(1)),b=X({computedData$:t.computedData$,NodeMap$:r}).pipe(u(1));return{fullParams$:t.fullParams$,fullChartParams$:t.fullChartParams$,fullDataFormatter$:t.fullDataFormatter$,computedData$:t.computedData$,layout$:t.layout$,textSizePx$:e,relationshipHighlightNodes$:a,relationshipHighlightEdges$:n,categoryLabels$:f,CategoryNodeMap$:l,CategoryEdgeMap$:c,NodeMap$:r,EdgeMap$:m,visibleComputedData$:b}};class et extends A{constructor(t,e){super({defaultDataFormatter:B,dataFormatterValidator:U,computedDataFn:z,dataValidator:V,contextObserverCallback:Y},t,e)}}const O="RelationshipLegend",j={name:O,defaultParams:S,layerIndex:_,validator:(s,{validateColumns:t})=>t(s,{placement:{toBe:'"top" | "top-start" | "top-end" | "bottom" | "bottom-start" | "bottom-end" | "left" | "left-start" | "left-end" | "right" | "right-start" | "right-end"',test:a=>["top","top-start","top-end","bottom","bottom-start","bottom-end","left","left-start","left-end","right","right-start","right-end"].includes(a)},padding:{toBeTypes:["number"]},backgroundFill:{toBeOption:"ColorType"},backgroundStroke:{toBeOption:"ColorType"},gap:{toBeTypes:["number"]},listRectWidth:{toBeTypes:["number"]},listRectHeight:{toBeTypes:["number"]},listRectRadius:{toBeTypes:["number"]},textColorType:{toBeOption:"ColorType"}})},at=N(j)(({selection:s,rootSelection:t,observer:e,subject:a})=>{const n=new D,l=e.fullParams$.pipe(F(n),I(r=>{const m=[{listRectWidth:r.listRectWidth,listRectHeight:r.listRectHeight,listRectRadius:r.listRectRadius}];return{...r,labelList:m}})),c=v(O,{rootSelection:t,legendLabels$:e.categoryLabels$,fullParams$:l,layout$:e.layout$,fullChartParams$:e.fullChartParams$,textSizePx$:e.textSizePx$});return()=>{n.next(void 0),c()}}),R="RelationshipTooltip",q={name:R,defaultParams:k,layerIndex:w,validator:(s,{validateColumns:t})=>t(s,{backgroundColorType:{toBeOption:"ColorType"},backgroundOpacity:{toBeTypes:["number"]},strokeColorType:{toBeOption:"ColorType"},offset:{toBe:"[number, number]",test:a=>Array.isArray(a)&&a.length===2&&typeof a[0]=="number"&&typeof a[1]=="number"},padding:{toBeTypes:["number"]},textColorType:{toBeOption:"ColorType"},renderFn:{toBeTypes:["Function"]}})},ot=N(q)(({selection:s,rootSelection:t,name:e,subject:a,observer:n})=>{const l=new D,c=H(R,{rootSelection:t,fullParams$:n.fullParams$,fullChartParams$:n.fullChartParams$,layout$:n.layout$,event$:a.event$});return()=>{l.next(void 0),c()}});export{at as R,ot as a,et as b};
