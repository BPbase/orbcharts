import{an as D,c as F,aJ as P,aq as g,ac as p,aj as C,ae as b,af as d,aK as y,as as L,ad as u,ab as v,ak as O,A as T,aL as A}from"./CeSasmr-.js";const B=s=>{const e=D(s,{visibleFilter:{toBeTypes:["Function"]},sort:{toBeTypes:["Function","null"]},seriesLabels:{toBeTypes:["string[]"]},container:{toBeTypes:["object"]},separateSeries:{toBeTypes:["boolean"]},sumSeries:{toBeTypes:["boolean"]}});if(s.container){const a=D(s.container,{gap:{toBeTypes:["number"]},rowAmount:{toBeTypes:["number"]},columnAmount:{toBeTypes:["number"]}});if(a.status==="error")return a}return e},q=s=>{const{data:e=[],dataFormatter:a,chartParams:o}=s;if(!e.length)return[];let r=[];try{const n=(t,i,m,l)=>{const c=F(a.type,i,m),$=a.seriesLabels[i]||P("series",i),f=g(i,o);return typeof t=="number"?{id:c,index:l,seq:0,label:c,description:"",data:{},value:t,seriesIndex:i,seriesLabel:$,color:f,visible:!0}:{id:t.id?t.id:c,index:l,seq:0,label:t.label?t.label:c,description:t.description,data:t.data??{},value:t.value,seriesIndex:i,seriesLabel:$,color:f,visible:!0}};r=e.map((t,i)=>Array.isArray(t)?t.map((m,l)=>n(m,i,l,r.length+l)):n(t,i,0,r.length)).flat().sort(a.sort??void 0).map((t,i)=>(t.seq=i,t)).map(t=>(t.visible=a.visibleFilter(t,s),t)).sort((t,i)=>t.index-i.index).reduce((t,i)=>(t[i.seriesIndex]||(t[i.seriesIndex]=[]),t[i.seriesIndex].push(i),t),[])}catch(n){throw Error(n)}return r},M=s=>D({data:s},{data:{toBe:"(DataSeriesDatum | DataSeriesValue)[][] | (DataSeriesDatum | DataSeriesValue)[]",test:a=>Array.isArray(a)}}),x=({fullDataFormatter$:s})=>s.pipe(p(e=>e.separateSeries),C()),w=({computedData$:s})=>s.pipe(p(e=>e.filter(a=>a.length).map(a=>a[0].seriesLabel)),C((e,a)=>JSON.stringify(e).length===JSON.stringify(a).length)),S=({computedData$:s})=>s.pipe(p(e=>e.map(a=>a.filter(o=>o.visible!=!1)))),E=({computedData$:s,fullDataFormatter$:e})=>b({computedData:s,fullDataFormatter:e}).pipe(d(async a=>a),p(a=>{const o=a.fullDataFormatter.sumSeries==!0?a.computedData.map(r=>[r.reduce((n,t)=>n==null?t:(n.value=n.value+t.value,n),null)]):a.computedData;return a.fullDataFormatter.separateSeries==!0?o.map(r=>r.sort((n,t)=>n.seq-t.seq)):[o.flat().sort((r,n)=>r.seq-n.seq)]})),R=({computedData$:s,fullDataFormatter$:e,layout$:a})=>b({computedData:s,fullDataFormatter:e,layout:a}).pipe(d(async r=>r),p(r=>r.fullDataFormatter.separateSeries?y(r.layout,r.fullDataFormatter.container,r.computedData.length):y(r.layout,r.fullDataFormatter.container,1))),V=({seriesContainerPosition$:s,seriesLabels$:e,separateSeries$:a})=>b({seriesContainerPosition:s,seriesLabels:e,separateSeries:a}).pipe(d(async o=>o),p(o=>o.separateSeries?new Map(o.seriesLabels.map((r,n)=>[r,o.seriesContainerPosition[n]??o.seriesContainerPosition[0]])):new Map(o.seriesLabels.map((r,n)=>[r,o.seriesContainerPosition[0]])))),J=({subject:s,observer:e})=>{const a=L(e.fullChartParams$).pipe(u(1)),o=x({fullDataFormatter$:e.fullDataFormatter$}),r=S({computedData$:e.computedData$}),n=E({computedData$:e.computedData$,fullDataFormatter$:e.fullDataFormatter$}).pipe(u(1)),t=S({computedData$:n}),i=e.computedData$.pipe(p(h=>h.flat())).pipe(u(1)),m=v({datumList$:i,fullChartParams$:e.fullChartParams$,event$:s.event$}).pipe(u(1)),l=w({computedData$:e.computedData$}),c=O({datumList$:i}).pipe(u(1)),$=R({computedData$:e.computedData$,fullDataFormatter$:e.fullDataFormatter$,layout$:e.layout$}).pipe(u(1)),f=V({seriesContainerPosition$:$,seriesLabels$:l,separateSeries$:o}).pipe(u(1));return{fullParams$:e.fullParams$,fullChartParams$:e.fullChartParams$,fullDataFormatter$:e.fullDataFormatter$,computedData$:e.computedData$,layout$:e.layout$,textSizePx$:a,visibleComputedData$:r,visibleComputedLayoutData$:t,separateSeries$:o,computedLayoutData$:n,seriesHighlight$:m,seriesLabels$:l,SeriesDataMap$:c,seriesContainerPosition$:$,SeriesContainerPositionMap$:f}};class j extends T{constructor(e,a){super({defaultDataFormatter:A,dataFormatterValidator:B,computedDataFn:q,dataValidator:M,contextObserverCallback:J},e,a)}}export{j as S};
