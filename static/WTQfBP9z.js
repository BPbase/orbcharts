import{ap as G,aq as w,an as $,al as Y,b5 as X,at as R,au as U,ax as k,b6 as q,b7 as E,b8 as J,az as B,b9 as K,aD as Z,aB as Q,ba as _,m as h,a as I,j as S,k as A,d as M,s as O,S as ee,aK as te,t as re,bb as H,g as T}from"./Dwexfo5s.js";import{c as V,d as ae}from"./B7uJrhWe.js";const ue=({computedData$:g,fullDataFormatter$:i,layout$:o})=>{function r(t,l,s){const a=l.groupAxis.position==="top"||l.groupAxis.position==="bottom"?s.width:s.height,c=t[0]?t[0].length-1:0;return V({maxValue:c,minValue:0,axisWidth:a,scaleDomain:[0,c],scaleRange:[0,1]})}function n(t,l,s){const a=l.valueAxis.position==="left"||l.valueAxis.position==="right"?s.height:s.width,c=t.flat();let[d,m]=J(c);return d===m&&m===0&&(m=1),V({maxValue:m,minValue:d,axisWidth:a,scaleDomain:["auto","auto"],scaleRange:[0,1]})}return G({computedData:g,fullDataFormatter:i,layout:o}).pipe(w(async t=>t),$(t=>{const l=r(t.computedData,t.fullDataFormatter,t.layout),s=n(t.computedData,t.fullDataFormatter,t.layout),a=s(0);return t.computedData.map((c,d)=>c.map((m,u)=>{const f=l(u),p=s(m.value??0);return{...m,axisX:f,axisY:p,axisYFromZero:p-a}}))}))},ce=({fullDataFormatter$:g,layout$:i})=>{const o=new Y;function r({xAxisPosition:n,yAxisPosition:t,width:l,height:s}){return(n==="bottom"||n==="top")&&(t==="left"||t==="right")?{width:l,height:s}:(n==="left"||n==="right")&&(t==="bottom"||t==="top")?{width:s,height:l}:{width:l,height:s}}return new X(n=>{G({fullDataFormatter:g,layout:i}).pipe(R(o),w(async t=>t)).subscribe(t=>{const l=r({xAxisPosition:t.fullDataFormatter.groupAxis.position,yAxisPosition:t.fullDataFormatter.valueAxis.position,width:t.layout.width,height:t.layout.height});return n.next(l),function(){o.next(void 0)}})})},pe=({computedData$:g})=>g.pipe($(i=>i.filter(o=>o.length).map(o=>o[0].seriesLabel)),U((i,o)=>JSON.stringify(i).length===JSON.stringify(o).length)),me=({computedData$:g})=>g.pipe($(i=>i.map(r=>r.filter(n=>n.visible==!0)).filter(r=>r.length))),ge=({computedLayoutData$:g})=>g.pipe($(i=>i.map(r=>r.filter(n=>n.visible==!0)).filter(r=>r.length))),fe=({computedData$:g,fullDataFormatter$:i,layout$:o})=>G({computedData:g,fullDataFormatter:i,layout:o}).pipe(w(async n=>n),$(n=>{if(n.fullDataFormatter.separateSeries)return k(n.layout,n.fullDataFormatter.container,n.computedData.length);{const t=k(n.layout,n.fullDataFormatter.container,1);return n.computedData.map((l,s)=>t[0])}})),de=({isSeriesSeprate$:g,computedData$:i})=>{const o=i.pipe($(r=>{const n=new Array(r[0]?r[0].length:0).fill(null).map((l,s)=>r.reduce((a,c)=>{if(c&&c[s]){const d=c[s].value==null||c[s].visible==!1?0:c[s].value;return a+d}return a},0));return r.map((l,s)=>l.map((a,c)=>({...a,value:n[c]})))}));return g.pipe(w(r=>q(()=>r,i,o)))},be=({computedData$:g,fullDataFormatter$:i})=>G({computedData:g,fullDataFormatter:i}).pipe(w(async o=>o),$(o=>{const r=o.fullDataFormatter.groupAxis,n=o.computedData[0]?o.computedData[0].length-1:0,t=r.scaleDomain[0]-r.scalePadding,l=r.scaleDomain[1]==="max"?n+r.scalePadding:r.scaleDomain[1]+r.scalePadding;return[t,l]})),xe=({computedData$:g,groupScaleDomainValue$:i})=>G({computedData:g,groupScaleDomainValue:i}).pipe($(o=>{const r=o.computedData.map((t,l)=>t.filter((s,a)=>a>=o.groupScaleDomainValue[0]&&a<=o.groupScaleDomainValue[1]&&s.visible==!0));return E(r)})),De=({fullDataFormatter$:g,layout$:i})=>{const o=new Y;function r({xAxis:n,yAxis:t,width:l,height:s}){if(!n||!t)return{translate:[0,0],scale:[1,1],rotate:0,rotateX:0,rotateY:0,value:""};let a=0,c=0,d=0,m=0,u=0;return n.position==="bottom"?t.position==="left"?(m=180,c=s):t.position==="right"?(m=180,u=180,a=l,c=s):(m=180,c=s):n.position==="top"?t.position==="left"||(t.position==="right"?(u=180,a=l):(m=180,c=s)):n.position==="left"?t.position==="bottom"?(d=-90,c=s):t.position==="top"?(d=-90,u=180):(m=180,c=s):n.position==="right"?t.position==="bottom"?(d=-90,m=180,c=s,a=l):t.position==="top"?(d=-90,m=180,u=180,a=l):(m=180,c=s):(m=180,c=s),{translate:[a,c],scale:[1,1],rotate:d,rotateX:m,rotateY:u,value:`translate(${a}px, ${c}px) rotate(${d}deg) rotateX(${m}deg) rotateY(${u}deg)`}}return new X(n=>(G({fullDataFormatter:g,layout:i}).pipe(R(o),w(async t=>t)).subscribe(t=>{const l=r({xAxis:t.fullDataFormatter.groupAxis,yAxis:t.fullDataFormatter.valueAxis,width:t.layout.width,height:t.layout.height});n.next(l)}),function(){o.next(void 0)}))},he=({gridAxesTransform$:g})=>g.pipe($(i=>{const o=[0,0],r=[1/i.scale[0],1/i.scale[1]],n=i.rotate*-1,t=i.rotateX*-1,l=i.rotateY*-1;return{translate:o,scale:r,rotate:n,rotateX:t,rotateY:l,value:`translate(${o[0]}px, ${o[1]}px) rotateX(${t}deg) rotateY(${l}deg) rotate(${n}deg)`}})),ve=({computedData$:g,groupScaleDomainValue$:i,filteredMinMaxValue$:o,fullDataFormatter$:r,layout$:n})=>{const t=new Y;function l({data:s,groupAxis:a,valueAxis:c,groupScaleDomainValue:d,filteredMinMaxValue:m,width:u,height:f}){let p=0,b=0,v=0,F=0;const e=a.position==="top"||a.position==="bottom"?u:f,x=0,D=s[0]?s[0].length-1:0,y=V({maxValue:D,minValue:x,axisWidth:e,scaleDomain:d,scaleRange:[0,1]}),L=y(x),P=y(D);x==D?(p=0,v=1):(p=L,v=(P-L)/e),m[0]===m[1]&&m[1]===0&&(m[1]=1);const W=c.position==="left"||c.position==="right"?f:u,j=V({maxValue:m[1],minValue:m[0],axisWidth:W,scaleDomain:c.scaleDomain,scaleRange:c.scaleRange}),C=E(s);C[0]===C[1]&&C[1]===0&&(C[1]=1);const z=j(C[0]>0?0:C[0]),N=j(C[1]<0?0:C[1]);return b=z,F=(N-z)/W,{translate:[p,b],scale:[v,F],rotate:0,rotateX:0,rotateY:0,value:`translate(${p}px, ${b}px) scale(${v}, ${F})`}}return new X(s=>(G({computedData:g,groupScaleDomainValue:i,filteredMinMaxValue:o,fullDataFormatter:r,layout:n}).pipe(R(t),w(async a=>a)).subscribe(a=>{const c=l({data:a.computedData,groupAxis:a.fullDataFormatter.groupAxis,valueAxis:a.fullDataFormatter.valueAxis,groupScaleDomainValue:a.groupScaleDomainValue,filteredMinMaxValue:a.filteredMinMaxValue,width:a.layout.width,height:a.layout.height});s.next(c)}),function(){t.next(void 0)}))},Se=({gridContainerPosition$:g,gridAxesTransform$:i,gridGraphicTransform$:o})=>G({gridContainerPosition:g,gridAxesTransform:i,gridGraphicTransform:o}).pipe(w(async r=>r),$(r=>r.gridAxesTransform.rotate==0||r.gridAxesTransform.rotate==180?r.gridContainerPosition.map((n,t)=>[1/r.gridGraphicTransform.scale[0]/r.gridContainerPosition[t].scale[0],1/r.gridGraphicTransform.scale[1]/r.gridContainerPosition[t].scale[1]]):r.gridContainerPosition.map((n,t)=>[1/r.gridGraphicTransform.scale[0]/r.gridContainerPosition[t].scale[1],1/r.gridGraphicTransform.scale[1]/r.gridContainerPosition[t].scale[0]])));function oe(g,i){if(!g.length)return[];try{const o=g.reduce((l,s)=>s.length>l?s.length:l,0),n=g.map((l,s)=>{if(l.length===o)return l;const a=Object.assign([],l);for(let c=a.length;c<o;c++)a[c]=null;return a}).map((l,s)=>l.map((a,c)=>a==null?{id:"",label:"",data:{},value:null}:typeof a=="number"?{id:"",label:"",data:{},value:a}:{id:a.id??"",label:a.label??"",data:a.data??{},value:a.value}));return _(i.seriesDirection,n)}catch{return[]}}const Ae=g=>{const{data:i=[],dataFormatter:o,chartParams:r}=g;if(!i.length)return[];let n;try{const t=oe(i,o),l=B({transposedDataGrid:t,dataFormatterGrid:o,chartType:"grid"}),s=K({transposedDataGrid:t,dataFormatterGrid:o,chartType:"grid"});let a=0;n=t.map((c,d)=>c.map((m,u)=>{const f=Z("grid",0,d,u),p=s[u],b={id:m.id?m.id:f,index:a,label:m.label?m.label:f,description:m.description??"",data:m.data,value:m.value,gridIndex:0,seriesIndex:d,seriesLabel:l[d],groupIndex:u,groupLabel:p,color:Q(d,r),visible:!0};return b.visible=o.visibleFilter(b,g),a++,b}))}catch(t){throw Error(t)}return n},ye=({selection:g,pluginName:i,clipPathID:o,seriesLabels$:r,gridContainerPosition$:n,gridAxesTransform$:t,gridGraphicTransform$:l})=>{const s=T(i,"series"),a=T(i,"axes"),c=T(i,"graphic"),d=r.pipe(h((p,b)=>g.selectAll(`g.${s}`).data(p,v=>v).join(v=>v.append("g").classed(s,!0).each((F,e,x)=>{O(x[e]).selectAll(`g.${a}`).data([e]).join(D=>D.append("g").classed(a,!0).attr("clip-path",`url(#${o})`).each((y,L,P)=>{O(P[L]).selectAll("defs").data([L]).join("defs"),O(P[L]).selectAll("g").data([L]).join("g").classed(c,!0)}),D=>D,D=>D.remove())}),v=>v,v=>v.remove())),I(1));S({seriesSelection:d,gridContainerPosition:n}).pipe(A(async p=>p)).subscribe(p=>{p.seriesSelection.transition().attr("transform",(b,v)=>{const F=p.gridContainerPosition[v]??p.gridContainerPosition[0],e=F.translate,x=F.scale;return`translate(${e[0]}, ${e[1]}) scale(${x[0]}, ${x[1]})`})});const m=S({seriesSelection:d,gridAxesTransform:t}).pipe(A(async p=>p),h(p=>p.seriesSelection.select(`g.${a}`).style("transform",p.gridAxesTransform.value)),I(1)),u=m.pipe(h(p=>p.select("defs")),I(1)),f=S({axesSelection:m,gridGraphicTransform:l}).pipe(A(async p=>p),h(p=>{const b=p.axesSelection.select(`g.${c}`);return b.transition().duration(50).style("transform",p.gridGraphicTransform.value),b}),I(1));return{seriesSelection$:d,axesSelection$:m,defsSelection$:u,graphicGSelection$:f}},Fe=({fullDataFormatter$:g,gridAxesSize$:i,computedData$:o,fullChartParams$:r,gridContainerPosition$:n,layout$:t})=>{const l=new ee,s=S({fullDataFormatter:g,gridAxesSize:i,computedData:o}).pipe(A(async u=>u),h(u=>{const f=u.computedData[0]?u.computedData[0].length-1:0,p=u.fullDataFormatter.groupAxis.scaleDomain[0]-u.fullDataFormatter.groupAxis.scalePadding,b=u.fullDataFormatter.groupAxis.scaleDomain[1]==="max"?f+u.fullDataFormatter.groupAxis.scalePadding:u.fullDataFormatter.groupAxis.scaleDomain[1]+u.fullDataFormatter.groupAxis.scalePadding;return[p,b]}),I(1)),a=S({fullDataFormatter:g,computedData:o}).pipe(A(async u=>u),h(u=>u.fullDataFormatter.seriesDirection==="row"?(u.computedData[0]??[]).map(f=>f.groupLabel):u.computedData.map(f=>f[0].groupLabel))),c=S({groupScaleDomain:s,groupLabels:a}).pipe(A(async u=>u),h(u=>u.groupLabels.filter((f,p)=>p>=u.groupScaleDomain[0]&&p<=u.groupScaleDomain[1]))),d=n.pipe(h(u=>u.reduce((p,b)=>b.columnIndex>p?b.columnIndex:p,0)+1),M()),m=n.pipe(h(u=>u.reduce((p,b)=>b.rowIndex>p?b.rowIndex:p,0)+1),M());return new te(u=>{S({dataFormatter:g,axisSize:i,fullChartParams:r,scaleRangeGroupLabels:c,groupLabels:a,groupScaleDomain:s,columnAmount:d,rowAmount:m,layout:t}).pipe(re(l),A(async f=>f)).subscribe(f=>{const p=f.dataFormatter.valueAxis.position==="right"||f.dataFormatter.valueAxis.position==="bottom",b=H({axisLabels:f.scaleRangeGroupLabels,axisWidth:f.axisSize.width,padding:f.dataFormatter.groupAxis.scalePadding,reverse:p}),v=e=>f.dataFormatter.groupAxis.position==="bottom"||f.dataFormatter.groupAxis.position==="top"?e.offsetX-f.fullChartParams.padding.left:e.offsetY-f.fullChartParams.padding.top,F=e=>{const x={offsetX:e.offsetX*f.columnAmount%f.layout.rootWidth,offsetY:e.offsetY*f.rowAmount%f.layout.rootHeight},D=v(x),y=b(D),L=Math.ceil(f.groupScaleDomain[0]),P=y+L;return{groupIndex:P,groupLabel:f.groupLabels[P]??""}};return u.next(F),function(){l.next(void 0)}})})},$e=({rootSelection:g,fullDataFormatter$:i,gridAxesSize$:o,computedData$:r,fullChartParams$:n,gridContainerPosition$:t,layout$:l})=>{const s=ae(g,"mousemove"),a=S({fullDataFormatter:i,gridAxesSize:o,computedData:r}).pipe(A(async e=>e),h(e=>{const x=e.computedData[0]?e.computedData[0].length-1:0,D=e.fullDataFormatter.groupAxis.scaleDomain[0]-e.fullDataFormatter.groupAxis.scalePadding,y=e.fullDataFormatter.groupAxis.scaleDomain[1]==="max"?x+e.fullDataFormatter.groupAxis.scalePadding:e.fullDataFormatter.groupAxis.scaleDomain[1]+e.fullDataFormatter.groupAxis.scalePadding;return[D,y]}),I(1)),c=S({fullDataFormatter:i,computedData:r}).pipe(A(async e=>e),h(e=>e.fullDataFormatter.seriesDirection==="row"?(e.computedData[0]??[]).map(x=>x.groupLabel):e.computedData.map(x=>x[0].groupLabel))),d=S({groupScaleDomain:a,groupLabels:c}).pipe(A(async e=>e),h(e=>e.groupLabels.filter((x,D)=>D>=e.groupScaleDomain[0]&&D<=e.groupScaleDomain[1]))),m=i.pipe(h(e=>e.valueAxis.position==="right"||e.valueAxis.position==="bottom")),u=S({reverse:m,gridAxesSize:o,scaleRangeGroupLabels:d,fullDataFormatter:i}).pipe(A(async e=>e),h(e=>H({axisLabels:e.scaleRangeGroupLabels,axisWidth:e.gridAxesSize.width,padding:e.fullDataFormatter.groupAxis.scalePadding,reverse:e.reverse}))),f=t.pipe(h(e=>e.reduce((D,y)=>y.columnIndex>D?y.columnIndex:D,0)+1),M()),p=t.pipe(h(e=>e.reduce((D,y)=>y.rowIndex>D?y.rowIndex:D,0)+1),M()),b=S({fullDataFormatter:i,fullChartParams:n,rootMousemove:s,columnAmount:f,rowAmount:p,layout:l}).pipe(A(async e=>e),h(e=>{const x={offsetX:e.rootMousemove.offsetX*e.columnAmount%e.layout.rootWidth,offsetY:e.rootMousemove.offsetY*e.rowAmount%e.layout.rootHeight};return e.fullDataFormatter.groupAxis.position==="bottom"||e.fullDataFormatter.groupAxis.position==="top"?x.offsetX-e.fullChartParams.padding.left:x.offsetY-e.fullChartParams.padding.top})),v=S({xIndexScale:u,axisValue:b,groupScaleDomain:a}).pipe(A(async e=>e),h(e=>{const x=e.xIndexScale(e.axisValue),D=Math.ceil(e.groupScaleDomain[0]);return x+D})),F=S({groupIndex:v,groupLabels:c}).pipe(A(async e=>e),h(e=>e.groupLabels[e.groupIndex]??""));return S({groupIndex:v,groupLabel:F}).pipe(A(async e=>e),h(e=>({groupIndex:e.groupIndex,groupLabel:e.groupLabel})))};export{pe as a,me as b,ue as c,ge as d,de as e,be as f,ce as g,xe as h,De as i,he as j,ve as k,Se as l,oe as m,ye as n,Fe as o,$e as p,fe as q,Ae as r};
