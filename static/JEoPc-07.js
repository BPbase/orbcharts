import{ar as h,as as H,at as $t,au as gt,av as ft,aw as bt,ax as Dt,ay as yt,az as d,aA as it,aB as st,aC as x,aD as j,aE as g,aF as At,aG as Tt,aH as ht,aI as xt,aJ as Ct,aK as Pt,aL as Gt,aM as Lt,aN as Bt,M as C,a as P,m as y,l as B,k as _,t as D,R as St,aO as Ft,aP as Rt,d as I,b as k,s as S,g as F,P as Mt,L as ot,V as Ot,Q as Et,r as _t,U as It,j as nt,i as kt}from"./Bh8imPUI.js";import{c as zt,g as Ut,a as Nt,b as Vt,d as wt,e as jt,f as Ht,h as vt,i as Wt,j as Xt,k as Yt,l as Jt,m as Kt,n as Qt}from"./CorttYm4.js";import{c as qt}from"./DUZwUmoI.js";import{c as Zt}from"./sQhI-oAP.js";import{c as te}from"./CsMsAnV-.js";import{c as ee}from"./BSwks4Jg.js";import{a as ae,c as re}from"./BJF8WTek.js";const ie=s=>{const i=h(s,{visibleFilter:{toBeTypes:["Function"]},gridList:{toBeTypes:["object[]"]},container:{toBeTypes:["object"]},separateGrid:{toBeTypes:["boolean"]}});if(s.gridList){const e=s.gridList.map((a,p)=>{const l=h(a,{seriesDirection:{toBe:'"row" | "column"',test:n=>n==="row"||n==="column"},rowLabels:{toBeTypes:["string[]"]},columnLabels:{toBeTypes:["string[]"]},valueAxis:{toBeTypes:["object"]},groupAxis:{toBeTypes:["object"]},separateSeries:{toBeTypes:["boolean"]}});if(l.status==="error")return l;if(a.valueAxis){const n=h(a.valueAxis,{position:{toBe:'"top" | "bottom" | "left" | "right"',test:t=>t==="top"||t==="bottom"||t==="left"||t==="right"},scaleDomain:{toBe:'[number | "min" | "auto", number | "max" | "auto"]',test:t=>Array.isArray(t)&&t.length===2&&(typeof t[0]=="number"||t[0]==="min"||t[0]==="auto")&&(typeof t[1]=="number"||t[1]==="max"||t[1]==="auto")},scaleRange:{toBe:"[number, number]",test:t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&typeof t[1]=="number"},label:{toBeTypes:["string"]}});if(n.status==="error")return n}else if(a.groupAxis){const n=h(a.groupAxis,{position:{toBe:'"top" | "bottom" | "left" | "right"',test:t=>t==="top"||t==="bottom"||t==="left"||t==="right"},scaleDomain:{toBe:'[number, number | "max"]',test:t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&(typeof t[1]=="number"||t[1]==="max")},scalePadding:{toBeTypes:["number"]},label:{toBeTypes:["string"]}});if(n.status==="error")return n}return{status:"success",columnName:"",expectToBe:""}}).find(a=>a.status==="error");if(e)return e}if(s.container){const r=h(s.container,{gap:{toBeTypes:["number"]},rowAmount:{toBeTypes:["number"]},columnAmount:{toBeTypes:["number"]}});if(r.status==="error")return r}return i},se=s=>{const{data:i=[],dataFormatter:r,chartParams:e}=s;if(!i.length)return[];let a=[];try{const p=r.gridList[0]||H,l=i.map((c,m)=>r.gridList[m]||p),n=i.map((c,m)=>zt(c,l[m])),t=r.separateGrid?n.map((c,m)=>$t({transposedDataGrid:c,dataFormatterGrid:l[m],chartType:"multiGrid"})):n.map((c,m)=>gt({transposedDataGrid:c,dataFormatterGrid:l[m],chartType:"multiGrid",gridIndex:m})),o=new Map;let u=0;t.flat().forEach((c,m)=>{if(!o.has(c)){const $=ft(u,e);o.set(c,$),u++}}),a=n.map((c,m)=>{const $=t[m],b=bt({transposedDataGrid:c,dataFormatterGrid:l[m],chartType:"multiGrid",gridIndex:m});let f=0;return c.map((M,G)=>M.map((A,T)=>{const O=Dt("multiGrid",m,G,T),U=b[T],E=$[G],L={id:A.id?A.id:O,index:f,label:A.label?A.label:O,description:A.description??"",data:A.data,value:A.value,gridIndex:m,seriesIndex:G,seriesLabel:E,groupIndex:T,groupLabel:U,color:o.get(E),visible:!0};return L.visible=r.visibleFilter(L,s),f++,L}))})}catch(p){throw Error(p)}return a},oe=s=>h({data:s},{data:{toBe:"DataGrid[]",test:r=>Array.isArray(r)}}),ne=({fullDataFormatter$:s,computedData$:i,layout$:r,fullChartParams$:e,event$:a,containerSize$:p})=>{const l=new yt,n=lt({computedData$:i,fullDataFormatter$:s,layout$:r}).pipe(d(1));return it({fullDataFormatter:s,computedData:i,multiGridContainer:n}).pipe(st(async t=>t),x(t=>{l.next(void 0);const o=t.fullDataFormatter.gridList[0]??H;return t.computedData.map((u,c)=>{const m=t.fullDataFormatter.gridList[c]??o,$={type:"grid",visibleFilter:t.fullDataFormatter.visibleFilter,...m,container:{...t.fullDataFormatter.container}},b=j($).pipe(g(l),d(1)),f=j(u).pipe(g(l),d(1)),z=b.pipe(x(w=>w.separateSeries),At(),d(1)),M=j(t.multiGridContainer[c]).pipe(g(l),d(1)),G=Ut({fullDataFormatter$:b,layout$:r}).pipe(g(l),d(1)),A=Nt({fullDataFormatter$:b,containerSize$:p}).pipe(d(1)),T=f.pipe(x(w=>w.flat())).pipe(g(l),d(1)),O=Vt({computedData$:f}).pipe(g(l),d(1)),U=Tt({datumList$:T}).pipe(g(l),d(1)),E=ht({datumList$:T}).pipe(g(l),d(1)),L=wt({computedData$:f}).pipe(g(l),d(1)),K=jt({computedData$:f,fullDataFormatter$:b,layout$:r}).pipe(g(l),d(1)),pt=Ht({computedAxesData$:K}).pipe(g(l),d(1)),ct=vt({computedData$:f,isSeriesSeprate$:z}).pipe(d(1)),N=Wt({computedData$:f,fullDataFormatter$:b}).pipe(g(l),d(1)),Q=Xt({computedData$:f,groupScaleDomainValue$:N}).pipe(g(l),d(1)),V=Yt({fullDataFormatter$:b,layout$:r}).pipe(g(l),d(1)),mt=Jt({gridAxesTransform$:V}).pipe(g(l),d(1)),q=Kt({computedData$:f,groupScaleDomainValue$:N,filteredMinMaxValue$:Q,fullDataFormatter$:b,layout$:r}).pipe(g(l),d(1)),dt=Qt({gridContainerPosition$:M,gridAxesTransform$:V,gridGraphicTransform$:q});return{isSeriesSeprate$:z,gridContainerPosition$:M,gridAxesSize$:G,gridAxesContainerSize$:A,seriesLabels$:O,SeriesDataMap$:U,GroupDataMap$:E,dataFormatter$:b,computedData$:f,computedAxesData$:K,visibleComputedData$:L,visibleComputedAxesData$:pt,computedStackedData$:ct,groupScaleDomainValue$:N,filteredMinMaxValue$:Q,gridAxesTransform$:V,gridAxesReverseTransform$:mt,gridGraphicTransform$:q,gridGraphicReverseScale$:dt}})}))},lt=({computedData$:s,fullDataFormatter$:i,layout$:r})=>it({computedData:s,fullDataFormatter:i,layout:r}).pipe(st(async e=>e),x(e=>{const a=e.fullDataFormatter.gridList[0]??H,p=e.computedData.reduce((o,u,c)=>{const $=(e.fullDataFormatter.gridList[c]??a).separateSeries?u.length:e.fullDataFormatter.separateGrid?1:0;return o+$},0)||1,l=xt(e.layout,e.fullDataFormatter.container,p);let n=0;return e.computedData.map((o,u)=>{const c=e.fullDataFormatter.gridList[u]??a,m=o.map(($,b)=>{const f=l[n];return c.separateSeries&&(n+=1),f});return!c.separateSeries&&e.fullDataFormatter.separateGrid&&(n+=1),m})})),le=({subject:s,observer:i})=>{const r=Ct(i.fullChartParams$).pipe(d(1)),e=lt({computedData$:i.computedData$,fullDataFormatter$:i.fullDataFormatter$,layout$:i.layout$}).pipe(d(1)),a=Pt({layout$:i.layout$,containerPosition$:e.pipe(x(n=>n.flat()))}).pipe(d(1)),p=Gt({datumList$:i.computedData$.pipe(x(n=>n.flat().flat()),d(1)),fullChartParams$:i.fullChartParams$,event$:s.event$}).pipe(d(1)),l=ne({fullDataFormatter$:i.fullDataFormatter$,computedData$:i.computedData$,layout$:i.layout$,fullChartParams$:i.fullChartParams$,event$:s.event$,containerSize$:a}).pipe(d(1));return{fullParams$:i.fullParams$,fullChartParams$:i.fullChartParams$,fullDataFormatter$:i.fullDataFormatter$,computedData$:i.computedData$,layout$:i.layout$,textSizePx$:r,containerSize$:a,multiGridHighlight$:p,multiGridContainerPosition$:e,multiGridEachDetail$:l}};class he extends Lt{constructor(i,r){super({defaultDataFormatter:Bt,dataFormatterValidator:ie,computedDataFn:se,dataValidator:oe,contextObserverCallback:le},i,r)}}const ut="MultiGridLegend",ue={name:ut,defaultParams:St,layerIndex:Ft,validator:(s,{validateColumns:i})=>{const r=i(s,{placement:{toBe:'"top" | "top-start" | "top-end" | "bottom" | "bottom-start" | "bottom-end" | "left" | "left-start" | "left-end" | "right" | "right-start" | "right-end"',test:e=>["top","top-start","top-end","bottom","bottom-start","bottom-end","left","left-start","left-end","right","right-start","right-end"].includes(e)},padding:{toBeTypes:["number"]},backgroundFill:{toBeOption:"ColorType"},backgroundStroke:{toBeOption:"ColorType"},gap:{toBeTypes:["number"]},listRectWidth:{toBeTypes:["number"]},listRectHeight:{toBeTypes:["number"]},listRectRadius:{toBeTypes:["number"]},gridList:{toBeTypes:["object[]"]},textColorType:{toBeOption:"ColorType"}});if(s.gridList){const a=s.gridList.map((p,l)=>i(p,{listRectWidth:{toBeTypes:["number"]},listRectHeight:{toBeTypes:["number"]},listRectRadius:{toBeTypes:["number"]}})).find(p=>p.status==="error");if(a)return a}return r}},xe=C(ue)(({selection:s,rootSelection:i,observer:r,subject:e})=>{const a=new P,p=r.multiGridEachDetail$.pipe(y(o=>o.map(u=>u.seriesLabels$)),B(o=>_(o).pipe(B(async u=>u))),y(o=>o.flat())),l=_({fullParams:r.fullParams$,computedData:r.computedData$}).pipe(D(a),B(async o=>o),y(o=>o.computedData.map((u,c)=>{const m=Rt(o.fullParams.gridList[c]??{},{listRectWidth:o.fullParams.listRectWidth,listRectHeight:o.fullParams.listRectHeight,listRectRadius:o.fullParams.listRectRadius});return u.map($=>m)}).flat())),n=_({fullParams:r.fullParams$,seriesList:l}).pipe(D(a),B(async o=>o),y(o=>({...o.fullParams,labelList:o.seriesList}))),t=qt(ut,{rootSelection:i,legendLabels$:p,fullParams$:n,layout$:r.layout$,fullChartParams$:r.fullChartParams$,textSizePx$:r.textSizePx$});return()=>{a.next(void 0),t()}}),R=s=>{const i=s.fullParams$.pipe(y(r=>r.gridIndexes),I(),k(1));return _({multiGridEachDetail:s.multiGridEachDetail$,gridIndexes:i}).pipe(B(async r=>r),y(r=>r.gridIndexes==="all"?r.multiGridEachDetail:r.gridIndexes.map(e=>r.multiGridEachDetail[e]??r.multiGridEachDetail[0])))},v="MultiBars",Z=F(v,"grid"),pe={name:v,defaultParams:Mt,layerIndex:ot,validator:(s,{validateColumns:i})=>i(s,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},barWidth:{toBeTypes:["number"]},barPadding:{toBeTypes:["number"]},barGroupPadding:{toBeTypes:["number"]},barRadius:{toBeTypes:["number","boolean"]}})},Ce=C(pe)(({selection:s,name:i,subject:r,observer:e})=>{const a=new P,p=[];return R(e).pipe(D(a)).subscribe(n=>{p.forEach(t=>t()),s.selectAll(`g.${Z}`).data(n).join("g").attr("class",Z).each((t,o,u)=>{const c=S(u[o]),m=t.dataFormatter$.pipe(D(a),y($=>$.separateSeries),I(),k(1));p[o]=Zt(v,{selection:c,computedData$:t.computedData$,visibleComputedData$:t.visibleComputedData$,computedAxesData$:t.computedAxesData$,visibleComputedAxesData$:t.visibleComputedAxesData$,seriesLabels$:t.seriesLabels$,SeriesDataMap$:t.SeriesDataMap$,GroupDataMap$:t.GroupDataMap$,fullParams$:e.fullParams$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridGraphicTransform$:t.gridGraphicTransform$,gridGraphicReverseScale$:t.gridGraphicReverseScale$,gridAxesSize$:t.gridAxesSize$,gridHighlight$:e.multiGridHighlight$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:m,event$:r.event$})})}),()=>{a.next(void 0),p.forEach(n=>n())}}),W="MultiLines",tt=F(W,"grid"),ce={name:W,defaultParams:Ot,layerIndex:ot,validator:(s,{validateColumns:i})=>i(s,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},lineCurve:{toBeTypes:["string"]},lineWidth:{toBeTypes:["number"]}})},Pe=C(ce)(({selection:s,rootSelection:i,name:r,subject:e,observer:a})=>{const p=new P,l=[],n=a.multiGridContainerPosition$.pipe(D(p),y(o=>o.flat()));return R(a).pipe(D(p)).subscribe(o=>{l.forEach(u=>u()),s.selectAll(`g.${tt}`).data(o).join("g").attr("class",tt).each((u,c,m)=>{const $=S(m[c]);l[c]=te(W,{selection:$,computedData$:u.computedData$,computedAxesData$:u.computedAxesData$,visibleComputedData$:u.visibleComputedData$,visibleComputedAxesData$:u.visibleComputedAxesData$,seriesLabels$:u.seriesLabels$,SeriesDataMap$:u.SeriesDataMap$,GroupDataMap$:u.GroupDataMap$,fullDataFormatter$:u.dataFormatter$,fullParams$:a.fullParams$,fullChartParams$:a.fullChartParams$,gridAxesTransform$:u.gridAxesTransform$,gridGraphicTransform$:u.gridGraphicTransform$,gridAxesSize$:u.gridAxesSize$,gridHighlight$:a.multiGridHighlight$,gridContainerPosition$:u.gridContainerPosition$,allContainerPosition$:n,layout$:a.layout$,event$:e.event$})})}),()=>{p.next(void 0),l.forEach(o=>o())}}),X="MultiDots",et=F(X,"grid"),me={name:X,defaultParams:Et,layerIndex:_t,validator:(s,{validateColumns:i})=>i(s,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},radius:{toBeTypes:["number"]},fillColorType:{toBeOption:"ColorType"},strokeColorType:{toBeOption:"ColorType"},strokeWidth:{toBeTypes:["number"]},onlyShowHighlighted:{toBeTypes:["boolean"]}})},Ge=C(me)(({selection:s,name:i,subject:r,observer:e})=>{const a=new P,p=[];return R(e).pipe(D(a)).subscribe(n=>{p.forEach(t=>t()),s.selectAll(`g.${et}`).data(n).join("g").attr("class",et).each((t,o,u)=>{const c=S(u[o]);p[o]=ee(X,{selection:c,computedData$:t.computedData$,visibleComputedData$:t.visibleComputedData$,computedAxesData$:t.computedAxesData$,visibleComputedAxesData$:t.visibleComputedAxesData$,seriesLabels$:t.seriesLabels$,SeriesDataMap$:t.SeriesDataMap$,GroupDataMap$:t.GroupDataMap$,fullParams$:e.fullParams$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridGraphicTransform$:t.gridGraphicTransform$,gridGraphicReverseScale$:t.gridGraphicReverseScale$,gridAxesSize$:t.gridAxesSize$,gridHighlight$:e.multiGridHighlight$,gridContainerPosition$:t.gridContainerPosition$,event$:r.event$})})}),()=>{a.next(void 0),p.forEach(n=>n())}}),Y="MultiGroupAxis",at=F(Y,"grid"),de={name:Y,defaultParams:It,layerIndex:nt,validator:(s,{validateColumns:i})=>i(s,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},labelOffset:{toBe:"[number, number]",test:e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="number"&&typeof e[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBe:'number | null | "all"',test:e=>e===null||e==="all"||typeof e=="number"},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}})},Le=C(de)(({selection:s,name:i,subject:r,observer:e})=>{const a=new P,p=[];return R(e).pipe(D(a)).subscribe(n=>{p.forEach(t=>t()),s.selectAll(`g.${at}`).data(n).join("g").attr("class",at).each((t,o,u)=>{const c=S(u[o]),m=t.dataFormatter$.pipe(D(a),y($=>$.separateSeries),I(),k(1));p[o]=ae(Y,{selection:c,computedData$:t.computedData$,fullParams$:e.fullParams$,fullDataFormatter$:t.dataFormatter$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridAxesReverseTransform$:t.gridAxesReverseTransform$,gridAxesSize$:t.gridAxesSize$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:m,textSizePx$:e.textSizePx$})})}),()=>{a.next(void 0),p.forEach(n=>n())}}),J="MultiValueAxis",rt=F(J,"grid"),$e={name:J,defaultParams:kt,layerIndex:nt,validator:(s,{validateColumns:i})=>i(s,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},labelOffset:{toBe:"[number, number]",test:e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="number"&&typeof e[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBeTypes:["number","null"]},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}})},Be=C($e)(({selection:s,name:i,subject:r,observer:e})=>{const a=new P,p=[];return R(e).pipe(D(a)).subscribe(n=>{p.forEach(t=>t()),s.selectAll(`g.${rt}`).data(n).join("g").attr("class",rt).each((t,o,u)=>{const c=S(u[o]),m=t.dataFormatter$.pipe(D(a),y($=>$.separateSeries),I(),k(1));p[o]=re(J,{selection:c,computedData$:t.computedData$,filteredMinMaxValue$:t.filteredMinMaxValue$,fullParams$:e.fullParams$,fullDataFormatter$:t.dataFormatter$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridAxesReverseTransform$:t.gridAxesReverseTransform$,gridAxesSize$:t.gridAxesSize$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:m})})}),()=>{a.next(void 0),p.forEach(n=>n())}});export{Ce as M,Ge as a,xe as b,Le as c,Pe as d,Be as e,he as f,R as m};
