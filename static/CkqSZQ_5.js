import{S as X,o as p,h as V,t as l,p as d,m as u,i as W,s as Y,ay as H,$ as G,aD as J}from"./DV8HSiku.js";import{h as C,n as K,i as I,g as M,o as Q,q as Z}from"./B_K1eqUP.js";const B=6;function _({selection:x,xAxisClassName:h,groupingLabelClassName:m,params:s,tickTextAlign:c,axisLabelAlign:k,gridAxesSize:b,fullDataFormatter:z,chartParams:n,groupScale:y,groupScaleDomain:R,groupLabels:o,textTransform:S}){const A=x.selectAll(`g.${h}`).data([s]).join("g").classed(h,!0);x.selectAll(`g.${m}`).data([s]).join("g").classed(m,!0).each((a,$,F)=>{Y(F[$]).selectAll("text").data([a]).join(g=>g.append("text").style("font-weight","bold"),g=>g,g=>g.remove()).attr("text-anchor",k.textAnchor).attr("dominant-baseline",k.dominantBaseline).attr("font-size",n.styles.textSize).style("fill",C(s.labelColorType,n)).text(g=>z.grid.groupAxis.label)}).attr("transform",a=>`translate(${b.width+a.tickPadding+s.labelOffset[0]}, ${-a.tickPadding-B-s.labelOffset[1]})`);const T=Math.floor(R[1])-Math.ceil(R[0])+1,L=K(y).scale(y).ticks(s.ticks==="all"||s.ticks>T?T:s.ticks).tickSize(s.tickFullLine==!0?-b.height:B).tickSizeOuter(0).tickFormat(a=>{const $=o[a]??"";return I($,s.tickFormat)}).tickPadding(s.tickPadding),v=A.transition().duration(100).call(L);return v.selectAll("line").style("fill","none").style("stroke",s.tickLineVisible==!0?C(s.tickColorType,n):"none").style("stroke-dasharray",s.tickFullLineDasharray).attr("pointer-events","none"),v.selectAll("path").style("fill","none").style("stroke",s.axisLineVisible==!0?C(s.axisLineColorType,n):"none").style("shape-rendering","crispEdges"),A.selectAll("text").attr("font-size",n.styles.textSize).style("color",C(s.tickTextColorType,n)).attr("text-anchor",c.textAnchor).attr("dominant-baseline",c.dominantBaseline).attr("transform-origin",`0 -${s.tickPadding+B}`).style("transform",S),A}const oe=(x,{selection:h,computedData$:m,fullParams$:s,fullDataFormatter$:c,fullChartParams$:k,gridAxesTransform$:b,gridAxesReverseTransform$:z,gridAxesSize$:n,gridContainerPosition$:y,isSeriesSeprate$:R})=>{const o=new X,S=M(x,"container"),A=M(x,"xAxisG"),T=M(x,"xAxis"),L=M(x,"groupingLabel"),v=p({computedData:m.pipe(V((e,i)=>e.length===i.length)),isSeriesSeprate:R}).pipe(l(o),d(async e=>e),u(e=>e.isSeriesSeprate?e.computedData:[e.computedData[0]]),u((e,i)=>h.selectAll(`g.${S}`).data(e,r=>r[0]?r[0].seriesIndex:i).join("g").classed(S,!0))),a=v.pipe(l(o),u((e,i)=>e.selectAll(`g.${A}`).data([A]).join("g").classed(A,!0)));p({containerSelection:v,gridContainerPosition:y}).pipe(l(o),d(async e=>e)).subscribe(e=>{e.containerSelection.attr("transform",(i,r)=>{const f=e.gridContainerPosition[r]??e.gridContainerPosition[0],D=f.translate,P=f.scale;return`translate(${D[0]}, ${D[1]}) scale(${P[0]}, ${P[1]})`})}),p({axisSelection:a,gridAxesTransform:b}).pipe(l(o),d(async e=>e)).subscribe(e=>{e.axisSelection.style("transform",e.gridAxesTransform.value)});const $=p({fullParams:s,fullDataFormatter:c,gridAxesReverseTransform:z,gridContainerPosition:y}).pipe(l(o),d(async e=>e),u(e=>{const i=`translate(${e.gridAxesReverseTransform.translate[0]}px, ${e.gridAxesReverseTransform.translate[1]}px)`,r=`rotate(${e.gridAxesReverseTransform.rotate}deg) rotateX(${e.gridAxesReverseTransform.rotateX}deg) rotateY(${e.gridAxesReverseTransform.rotateY}deg)`,f=`scale(${1/e.gridContainerPosition[0].scale[0]}, ${1/e.gridContainerPosition[0].scale[1]})`,P=`rotate(${e.fullDataFormatter.grid.groupAxis.position==="left"&&e.fullDataFormatter.grid.valueAxis.position==="top"||e.fullDataFormatter.grid.groupAxis.position==="right"&&e.fullDataFormatter.grid.valueAxis.position==="bottom"?e.fullParams.tickTextRotate+180:e.fullParams.tickTextRotate}deg)`;return`${i} ${r} ${f} ${P}`}),V()),F=p({fullDataFormatter:c,gridAxesSize:n,computedData:m}).pipe(l(o),d(async e=>e),u(e=>{const r=e.computedData[0]?e.computedData[0].length-1:0,f=e.fullDataFormatter.grid.groupAxis.scaleDomain[0]==="auto"?0-e.fullDataFormatter.grid.groupAxis.scalePadding:e.fullDataFormatter.grid.groupAxis.scaleDomain[0]-e.fullDataFormatter.grid.groupAxis.scalePadding,D=e.fullDataFormatter.grid.groupAxis.scaleDomain[1]==="auto"?r+e.fullDataFormatter.grid.groupAxis.scalePadding:e.fullDataFormatter.grid.groupAxis.scaleDomain[1]+e.fullDataFormatter.grid.groupAxis.scalePadding;return[f,D]}),W(1)),g=p({groupScaleDomain:F,gridAxesSize:n}).pipe(l(o),d(async e=>e),u(e=>H().domain(e.groupScaleDomain).range([0,e.gridAxesSize.width]))),j=m.pipe(u(e=>(e[0]??[]).map(i=>i.groupLabel))),w=p({fullDataFormatter:c,fullParams:s}).pipe(l(o),d(async e=>e),u(e=>{let i="middle",r="hanging";return e.fullDataFormatter.grid.groupAxis.position==="bottom"?(i=e.fullParams.tickTextRotate?"end":"middle",r="hanging"):e.fullDataFormatter.grid.groupAxis.position==="top"?(i=e.fullParams.tickTextRotate?"end":"middle",r="auto"):e.fullDataFormatter.grid.groupAxis.position==="left"?(i="end",r="middle"):e.fullDataFormatter.grid.groupAxis.position==="right"&&(i="start",r="middle"),{textAnchor:i,dominantBaseline:r}})),t=c.pipe(l(o),u(e=>{let i="start",r="hanging";return e.grid.groupAxis.position==="bottom"?r="hanging":e.grid.groupAxis.position==="top"?r="auto":e.grid.groupAxis.position==="left"?i="end":e.grid.groupAxis.position==="right"&&(i="start"),e.grid.valueAxis.position==="left"?i="start":e.grid.valueAxis.position==="right"?i="end":e.grid.valueAxis.position==="bottom"?r="auto":e.grid.valueAxis.position==="top"&&(r="hanging"),{textAnchor:i,dominantBaseline:r}}));return p({axisSelection:a,params:s,tickTextAlign:w,axisLabelAlign:t,gridAxesSize:n,fullDataFormatter:c,chartParams:k,groupScale:g,groupScaleDomain:F,groupLabels:j,textTransform:$}).pipe(l(o),d(async e=>e)).subscribe(e=>{_({selection:e.axisSelection,xAxisClassName:T,groupingLabelClassName:L,params:e.params,tickTextAlign:e.tickTextAlign,axisLabelAlign:e.axisLabelAlign,gridAxesSize:e.gridAxesSize,fullDataFormatter:e.fullDataFormatter,chartParams:e.chartParams,groupScale:e.groupScale,groupScaleDomain:e.groupScaleDomain,groupLabels:e.groupLabels,textTransform:e.textTransform})}),()=>{o.next(void 0)}},E=6;function N({selection:x,yAxisClassName:h,textClassName:m,fullParams:s,tickTextAlign:c,axisLabelAlign:k,gridAxesSize:b,fullDataFormatter:z,fullChartParams:n,valueScale:y,textTransform:R,minAndMax:o}){const S=x.selectAll(`g.${h}`).data([s]).join("g").classed(h,!0);x.selectAll(`g.${m}`).data([s]).join("g").classed(m,!0).each((a,$,F)=>{Y(F[$]).selectAll("text").data([a]).join(g=>g.append("text").style("font-weight","bold"),g=>g,g=>g.remove()).attr("text-anchor",k.textAnchor).attr("dominant-baseline",k.dominantBaseline).attr("font-size",n.styles.textSize).style("fill",C(s.labelColorType,n)).text(g=>z.grid.valueAxis.label)}).attr("transform",a=>`translate(${-a.tickPadding+s.labelOffset[0]}, ${b.height+a.tickPadding+s.labelOffset[1]})`);const A=o[1]-o[0],T=Q(y).scale(y).ticks(A>s.ticks?s.ticks:o[0]===0&&o[1]===0?1:Math.ceil(A)).tickFormat(a=>I(a,s.tickFormat)).tickSize(s.tickFullLine==!0?-b.width:E).tickPadding(s.tickPadding),L=S.transition().duration(100).call(T);return L.selectAll("line").style("fill","none").style("stroke",s.tickLineVisible==!0?C(s.tickColorType,n):"none").style("stroke-dasharray",s.tickFullLineDasharray).attr("pointer-events","none"),L.selectAll("path").style("fill","none").style("stroke",s.axisLineVisible==!0?C(s.axisLineColorType,n):"none").style("shape-rendering","crispEdges"),S.selectAll("text").attr("font-size",n.styles.textSize).style("color",C(s.tickTextColorType,n)).attr("text-anchor",c.textAnchor).attr("dominant-baseline",c.dominantBaseline).attr("transform-origin",`-${s.tickPadding+E} 0`).style("transform",R),S}const re=(x,{selection:h,computedData$:m,fullParams$:s,fullDataFormatter$:c,fullChartParams$:k,gridAxesTransform$:b,gridAxesReverseTransform$:z,gridAxesSize$:n,gridContainerPosition$:y,isSeriesSeprate$:R})=>{const o=new X,S=M(x,"container"),A=M(x,"yAxisG"),T=M(x,"yAxis"),L=M(x,"text"),v=p({computedData:m.pipe(V((t,e)=>t.length===e.length)),isSeriesSeprate:R}).pipe(l(o),d(async t=>t),u(t=>t.isSeriesSeprate?t.computedData:[t.computedData[0]]),u((t,e)=>h.selectAll(`g.${S}`).data(t,i=>i[0]?i[0].seriesIndex:e).join("g").classed(S,!0))),a=v.pipe(l(o),u((t,e)=>t.selectAll(`g.${A}`).data([A]).join("g").classed(A,!0)));p({containerSelection:v,gridContainerPosition:y}).pipe(l(o),d(async t=>t)).subscribe(t=>{t.containerSelection.attr("transform",(e,i)=>{const r=t.gridContainerPosition[i]??t.gridContainerPosition[0],f=r.translate,D=r.scale;return`translate(${f[0]}, ${f[1]}) scale(${D[0]}, ${D[1]})`})}),p({axisSelection:a,gridAxesTransform:b}).pipe(l(o),d(async t=>t)).subscribe(t=>{t.axisSelection.style("transform",t.gridAxesTransform.value)});const $=p({fullParams:s,fullDataFormatter:c,gridAxesReverseTransform:z,gridContainerPosition:y}).pipe(l(o),d(async t=>t),u(t=>{const e=`translate(${t.gridAxesReverseTransform.translate[0]}px, ${t.gridAxesReverseTransform.translate[1]}px)`,i=`rotate(${t.gridAxesReverseTransform.rotate}deg) rotateX(${t.gridAxesReverseTransform.rotateX}deg) rotateY(${t.gridAxesReverseTransform.rotateY}deg)`,r=`scale(${1/t.gridContainerPosition[0].scale[0]}, ${1/t.gridContainerPosition[0].scale[1]})`,D=`rotate(${t.fullDataFormatter.grid.groupAxis.position==="left"&&t.fullDataFormatter.grid.valueAxis.position==="top"||t.fullDataFormatter.grid.groupAxis.position==="right"&&t.fullDataFormatter.grid.valueAxis.position==="bottom"?t.fullParams.tickTextRotate+180:t.fullParams.tickTextRotate}deg)`;return`${e} ${i} ${r} ${D}`}),V()),F=new G(t=>{p({fullDataFormatter:c,gridAxesSize:n,computedData:m}).pipe(l(o),d(async e=>e)).subscribe(e=>{const r=e.computedData[0]?e.computedData[0].length-1:0,f=e.fullDataFormatter.grid.groupAxis.scaleDomain[0]==="auto"?0-e.fullDataFormatter.grid.groupAxis.scalePadding:e.fullDataFormatter.grid.groupAxis.scaleDomain[0]-e.fullDataFormatter.grid.groupAxis.scalePadding,D=e.fullDataFormatter.grid.groupAxis.scaleDomain[1]==="auto"?r+e.fullDataFormatter.grid.groupAxis.scalePadding:e.fullDataFormatter.grid.groupAxis.scaleDomain[1]+e.fullDataFormatter.grid.groupAxis.scalePadding,P=e.computedData.map((q,ee)=>q.filter((te,O)=>O>=f&&O<=D)),U=Z(P.flat());t.next(U)})}),g=new G(t=>{p({fullDataFormatter:c,gridAxesSize:n,minAndMax:F}).pipe(l(o),d(async e=>e)).subscribe(e=>{const i=J({maxValue:e.minAndMax[1],minValue:e.minAndMax[0],axisWidth:e.gridAxesSize.height,scaleDomain:e.fullDataFormatter.grid.valueAxis.scaleDomain,scaleRange:e.fullDataFormatter.grid.valueAxis.scaleRange});t.next(i)})}),j=c.pipe(l(o),u(t=>{let e="start",i="hanging";return t.grid.valueAxis.position==="left"?(e="end",i="middle"):t.grid.valueAxis.position==="right"?(e="start",i="middle"):t.grid.valueAxis.position==="bottom"?(e="middle",i="hanging"):t.grid.valueAxis.position==="top"&&(e="middle",i="auto"),{textAnchor:e,dominantBaseline:i}})),w=c.pipe(l(o),u(t=>{let e="start",i="hanging";return t.grid.groupAxis.position==="bottom"?i="auto":t.grid.groupAxis.position==="top"?i="hanging":t.grid.groupAxis.position==="left"?e="start":t.grid.groupAxis.position==="right"&&(e="end"),t.grid.valueAxis.position==="left"?e="end":t.grid.valueAxis.position==="right"?e="start":t.grid.valueAxis.position==="bottom"?i="hanging":t.grid.valueAxis.position==="top"&&(i="auto"),{textAnchor:e,dominantBaseline:i}}));return p({axisSelection:a,fullParams:s,tickTextAlign:j,axisLabelAlign:w,computedData:m,gridAxesSize:n,fullDataFormatter:c,fullChartParams:k,valueScale:g,textTransform:$,minAndMax:F}).pipe(l(o),d(async t=>t)).subscribe(t=>{N({selection:t.axisSelection,yAxisClassName:T,textClassName:L,fullParams:t.fullParams,tickTextAlign:t.tickTextAlign,axisLabelAlign:t.axisLabelAlign,gridAxesSize:t.gridAxesSize,fullDataFormatter:t.fullDataFormatter,fullChartParams:t.fullChartParams,valueScale:t.valueScale,textTransform:t.textTransform,minAndMax:t.minAndMax})}),()=>{o.next(void 0)}};export{oe as a,re as c};
