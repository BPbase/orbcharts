import{aD as h,bt as M,ar as T,as as P,ap as g,aw as E,aG as x,aq as u,ao as C,bu as L,aH as A,bY as B,bZ as D,S as N,t as F,m as I,a1 as S,aJ as _,a2 as k,am as w}from"./Dqvogce1.js";import{c as H}from"./C21pD4V8.js";import{c as v}from"./CWRBibWU.js";const U=s=>({status:"success",columnName:"",expectToBe:""}),z=s=>{const{data:t,dataFormatter:e,chartParams:a}=s,n=M();let c=[],d=[];try{let r=[],m=[];if(t.nodes)r=t.nodes,m=t.edges;else if(t[0])r=t[0],m=t[1];else return{nodes:[],edges:[]};const f=(()=>{const o=new Set(e.categoryLabels);for(let l of r){const i=l.categoryLabel??n;o.add(i)}for(let l of m){const i=l.categoryLabel??n;o.add(i)}return Array.from(o)})(),b=new Map(f.map((o,l)=>[o,l]));c=r.map((o,l)=>{const i=o.categoryLabel??n,y=b.get(i)??0,$={id:o.id,index:l,label:o.label??"",description:o.description??"",data:o.data??{},value:o.value??0,categoryIndex:y,categoryLabel:i,color:h(y,a),visible:!0};return $.visible=e.visibleFilter($,s),$});const p=new Map(c.map(o=>[o.id,o]));d=m.map((o,l)=>{const i=p.get(o.start),y=p.get(o.end);return{edge:o,startNode:i,endNode:y}}).filter(({edge:o})=>{const l=p.get(o.start),i=p.get(o.end);return l!=null&&i!=null}).map(({edge:o,startNode:l,endNode:i},y)=>{const $=o.categoryLabel??n;return{id:o.id,index:y,label:o.label??"",description:o.description??"",data:o.data??{},value:o.value??0,categoryIndex:b.get($),categoryLabel:$,color:h(y,a),startNode:l,endNode:i,visible:l.visible&&i.visible}})}catch(r){throw Error(r)}return{nodes:c,edges:d}},J=s=>({status:"success",columnName:"",expectToBe:""}),V=(s,t)=>T({CategoryNodeMap:s,CategoryEdgeMap:t}).pipe(P(async e=>e),g(e=>[...Array.from(e.CategoryNodeMap.keys()),...Array.from(e.CategoryEdgeMap.keys())]),E((e,a)=>JSON.stringify(e).length===JSON.stringify(a).length)),W=s=>s.pipe(g(t=>{const e=new Map;return t.nodes.forEach(a=>{e.set(a.id,a)}),e})),Y=s=>s.pipe(g(t=>{const e=new Map;return t.edges.forEach(a=>{e.set(a.id,a)}),e})),G=({computedData$:s,NodeMap$:t})=>T({computedData:s,NodeMap:t}).pipe(P(async e=>e),g(e=>({nodes:e.computedData.nodes.filter(a=>a.visible),edges:e.computedData.edges.filter(a=>a.visible).filter(a=>e.NodeMap.has(a.startNode.id)&&e.NodeMap.has(a.endNode.id))}))),X=({subject:s,observer:t})=>{const e=x(t.fullChartParams$).pipe(u(1)),a=C({datumList$:t.computedData$.pipe(g(p=>p.nodes)),fullChartParams$:t.fullChartParams$,event$:s.event$}).pipe(u(1)),n=C({datumList$:t.computedData$.pipe(g(p=>p.edges)),fullChartParams$:t.fullChartParams$,event$:s.event$}).pipe(u(1)),c=L({datumList$:t.computedData$.pipe(g(p=>p.nodes))}).pipe(u(1)),d=L({datumList$:t.computedData$.pipe(g(p=>p.edges))}).pipe(u(1)),r=W(t.computedData$).pipe(u(1)),m=Y(t.computedData$).pipe(u(1)),f=V(c,d).pipe(u(1)),b=G({computedData$:t.computedData$,NodeMap$:r}).pipe(u(1));return{fullParams$:t.fullParams$,fullChartParams$:t.fullChartParams$,fullDataFormatter$:t.fullDataFormatter$,computedData$:t.computedData$,layout$:t.layout$,textSizePx$:e,relationshipHighlightNodes$:a,relationshipHighlightEdges$:n,categoryLabels$:f,CategoryNodeMap$:c,CategoryEdgeMap$:d,NodeMap$:r,EdgeMap$:m,visibleComputedData$:b}};class et extends A{constructor(t,e){super({defaultDataFormatter:B,dataFormatterValidator:U,computedDataFn:z,dataValidator:J,contextObserverCallback:X},t,e)}}const O="RelationshipLegend",j={name:O,defaultParams:S,layerIndex:_,validator:(s,{validateColumns:t})=>t(s,{placement:{toBe:'"top" | "top-start" | "top-end" | "bottom" | "bottom-start" | "bottom-end" | "left" | "left-start" | "left-end" | "right" | "right-start" | "right-end"',test:a=>["top","top-start","top-end","bottom","bottom-start","bottom-end","left","left-start","left-end","right","right-start","right-end"].includes(a)},padding:{toBeTypes:["number"]},backgroundFill:{toBeOption:"ColorType"},backgroundStroke:{toBeOption:"ColorType"},gap:{toBeTypes:["number"]},listRectWidth:{toBeTypes:["number"]},listRectHeight:{toBeTypes:["number"]},listRectRadius:{toBeTypes:["number"]},textColorType:{toBeOption:"ColorType"}})},at=D(j)(({selection:s,rootSelection:t,observer:e,subject:a})=>{const n=new N,c=e.fullParams$.pipe(F(n),I(r=>{const m=[{listRectWidth:r.listRectWidth,listRectHeight:r.listRectHeight,listRectRadius:r.listRectRadius}];return{...r,labelList:m}})),d=H(O,{rootSelection:t,legendLabels$:e.categoryLabels$,fullParams$:c,layout$:e.layout$,fullChartParams$:e.fullChartParams$,textSizePx$:e.textSizePx$});return()=>{n.next(void 0),d()}}),R="RelationshipTooltip",q={name:R,defaultParams:k,layerIndex:w,validator:(s,{validateColumns:t})=>t(s,{backgroundColorType:{toBeOption:"ColorType"},backgroundOpacity:{toBeTypes:["number"]},strokeColorType:{toBeOption:"ColorType"},offset:{toBe:"[number, number]",test:a=>Array.isArray(a)&&a.length===2&&typeof a[0]=="number"&&typeof a[1]=="number"},padding:{toBeTypes:["number"]},textColorType:{toBeOption:"ColorType"},renderFn:{toBeTypes:["Function"]}})},ot=D(q)(({selection:s,rootSelection:t,name:e,subject:a,observer:n})=>{const c=new N,d=v(R,{rootSelection:t,fullParams$:n.fullParams$,fullChartParams$:n.fullChartParams$,layout$:n.layout$,event$:a.event$});return()=>{c.next(void 0),d()}});export{at as R,ot as a,et as b};
