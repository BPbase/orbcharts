import{K as Y,L as ue,M as pe,E as ge,N as de,B as $e,P as me,Q as se,R as oe,T as H,U as K,V as Z,G as L,W as Q,F as he,H as fe,X as De,I as xe,Y as Se,S as F,e as C,t as A,s as b,m as T,d as V,c as M,v as E,Z as be}from"./DNpuBO6_.js";import{c as Le,b as Ae,d as ye,i as Te,e as Ge,f as Pe,h as Ce,j as Me,k as Fe,l as Re,m as Ie,n as ve,a as ke}from"./CdoJceY_.js";import{c as _e}from"./gIJZDqXc.js";import{c as Ee}from"./Cz28BQT8.js";import{e as Oe,b as q,g as v,s as z}from"./D8yrUiOY.js";import{c as Ue}from"./Cq6aZMnD.js";import{a as we,c as ze}from"./g4BM-lXL.js";import{o as He}from"./1_JtqLfi.js";function Ve({context:a,gridIndex:l,transposedDataGrid:r,gridSeriesLabels:u,SeriesLabelColorMap:g}){const{data:t=[],dataFormatter:f,chartParams:o,layout:e}=a;if(!t.length)return[];const i=Ae(r,f,e),p=de({transposedDataGrid:r,dataFormatter:f,chartType:"multiGrid",gridIndex:l}),d=ye(r,f,e),x=r.map((S,$)=>d[$](0));let s=0;return r.map((S,$)=>S.map((D,G)=>{const P=$e("multiGrid",l,$,G),R=p[G],n=u[$],k=d[$],_=k(D.value??0),O=x[$],U={id:D.id?D.id:P,index:s,label:D.label?D.label:P,description:D.description??"",data:D.data,value:D.value,gridIndex:l,seriesIndex:$,seriesLabel:n,groupIndex:G,groupLabel:R,color:g.get(n),axisX:i(G),axisY:_,axisYFromZero:_-O,visible:D._visible};return s++,U}))}const je=({data:a=[],dataFormatter:l,chartParams:r,layout:u})=>{if(!a.length)return[];let g=[];try{const t=l.gridList[0]||Y,f=a.map((s,h)=>({type:"grid",grid:{...l.gridList[h]||t},container:{...l.container}})),o=a.map((s,h)=>({data:s,dataFormatter:f[h],chartParams:r,layout:u})),e=a.map((s,h)=>Le(o[h])),i=new Set(f.map(S=>S.grid.slotIndex)).size!==f.length?ue:pe,p=e.map((s,h)=>i({transposedDataGrid:s,dataFormatter:f[h],chartType:"multiGrid",gridIndex:h})),d=new Map;let x=0;p.flat().forEach((s,h)=>{if(!d.has(s)){const S=ge(x,r);d.set(s,S),x++}}),g=a.map((s,h)=>Ve({context:o[h],gridIndex:h,transposedDataGrid:e[h],gridSeriesLabels:p[h],SeriesLabelColorMap:d}))}catch(t){throw Error(t)}return g},Ne=({fullDataFormatter$:a,computedData$:l,layout$:r,fullChartParams$:u,event$:g})=>{function t({gridDataFormatter$:o,gridComputedData$:e,layout$:i,fullChartParams$:p,event$:d}){const x=Te({computedData$:e,fullDataFormatter$:o}).pipe(L(1)),s=Ge({computedData$:e,fullDataFormatter$:o,fullChartParams$:p,layout$:i}).pipe(L(1)),h=Pe({fullDataFormatter$:o,layout$:i}).pipe(L(1)),S=Ce({gridAxesTransform$:h}).pipe(L(1)),$=Me({computedData$:e,fullDataFormatter$:o,layout$:i}).pipe(L(1)),D=Fe({gridContainer$:s,gridAxesTransform$:h,gridGraphicTransform$:$}),G=Re({fullDataFormatter$:o,layout$:i}).pipe(L(1)),P=e.pipe(H(U=>U.flat())).pipe(L(1)),R=he({datumList$:P,fullChartParams$:p,event$:d}).pipe(L(1)),n=Ie({computedData$:e}),k=fe({datumList$:P}).pipe(L(1)),_=De({datumList$:P}).pipe(L(1)),O=ve({computedData$:e}).pipe(L(1));return{isSeriesPositionSeprate$:x,gridContainer$:s,gridAxesTransform$:h,gridAxesReverseTransform$:S,gridGraphicTransform$:$,gridGraphicReverseScale$:D,gridAxesSize$:G,gridHighlight$:R,existSeriesLabels$:n,SeriesDataMap$:k,GroupDataMap$:_,visibleComputedData$:O}}const f=new me;return se({fullDataFormatter:a,computedData:l}).pipe(oe(async o=>o),H(o=>{f.next(void 0);const e=o.fullDataFormatter.gridList[0]??Y;return o.computedData.map((i,p)=>{const x={type:"grid",grid:{...o.fullDataFormatter.gridList[p]??e},container:{...o.fullDataFormatter.container}},s=K(x).pipe(Z(f),L(1)),h=K(i).pipe(Z(f),L(1));return t({gridDataFormatter$:s,gridComputedData$:h,layout$:r,fullChartParams$:u,event$:g})})}))},Be=({computedData$:a,fullDataFormatter$:l,fullChartParams$:r,layout$:u})=>se({computedData:a,fullDataFormatter:l,fullChartParams:r,layout:u}).pipe(oe(async t=>t),H(t=>{const f=t.fullDataFormatter.gridList[0]??Y;return t.computedData.map((e,i)=>{const p=t.fullDataFormatter.gridList[i]??f;if(!!(p.seriesSlotIndexes&&p.seriesSlotIndexes.length===e.length))return e.map((x,s)=>{const h=p.seriesSlotIndexes[s]%t.fullDataFormatter.container.columnAmount,S=Math.floor(p.seriesSlotIndexes[s]/t.fullDataFormatter.container.columnAmount),{translate:$,scale:D}=Q(t.layout,t.fullDataFormatter.container,S,h);return{slotIndex:p.seriesSlotIndexes[s],rowIndex:S,columnIndex:h,translate:$,scale:D}});{const x=p.slotIndex%t.fullDataFormatter.container.columnAmount,s=Math.floor(p.slotIndex/t.fullDataFormatter.container.columnAmount);return e.map((h,S)=>{const{translate:$,scale:D}=Q(t.layout,t.fullDataFormatter.container,s,x);return{slotIndex:p.slotIndex,rowIndex:s,columnIndex:x,translate:$,scale:D}})}})})),We=({subject:a,observer:l})=>{const r=Ne({fullDataFormatter$:l.fullDataFormatter$,computedData$:l.computedData$,layout$:l.layout$,fullChartParams$:l.fullChartParams$,event$:a.event$}).pipe(L(1)),u=Be({computedData$:l.computedData$,fullDataFormatter$:l.fullDataFormatter$,fullChartParams$:l.fullChartParams$,layout$:l.layout$});return{fullParams$:l.fullParams$,fullChartParams$:l.fullChartParams$,fullDataFormatter$:l.fullDataFormatter$,computedData$:l.computedData$,layout$:l.layout$,multiGridEachDetail$:r,multiGridContainer$:u}};class pt extends xe{constructor(l,r){super({defaultDataFormatter:Se,computedDataFn:je,contextObserverFn:We},l,r)}}function Xe({graphicGSelection:a,circleGClassName:l,circleClassName:r,data:u,fullParams:g,fullChartParams:t,graphicReverseScale:f}){const o=p=>{const d=p.size();return t.transitionDuration/d};let e=0;return a.each((p,d,x)=>{M(x[d]).selectAll("g").data(u[d],s=>s.id).join(s=>(e=o(s),s.append("g").classed(l,!0)),s=>s,s=>s.remove()).attr("transform",s=>`translate(${s.axisX}, ${s.axisY})`).each((s,h,S)=>{M(S[h]).selectAll("circle").data([s]).join($=>$.append("circle").style("cursor","pointer").style("vector-effect","non-scaling-stroke").classed(r,!0).attr("opacity",0).transition().delay((D,G)=>h*e).attr("opacity",1),$=>$.transition().duration(50).attr("opacity",1),$=>$.remove()).attr("r",g.radius).attr("fill",($,D)=>q({datum:$,colorType:g.fillColorType,fullChartParams:t})).attr("stroke",($,D)=>q({datum:$,colorType:g.strokeColorType,fullChartParams:t})).attr("stroke-width",g.strokeWidth).attr("transform",`scale(${f[d][0]??1}, ${f[d][1]??1})`)})}),a.selectAll(`circle.${r}`)}function Ye({selection:a,ids:l,onlyShowHighlighted:r,fullChartParams:u}){if(a.interrupt("highlight"),!l.length){a.transition("highlight").duration(200).style("opacity",r===!0?0:1);return}a.each((g,t,f)=>{l.includes(g.id)?M(f[t]).style("opacity",1).transition("highlight").duration(200):M(f[t]).style("opacity",r===!0?0:u.styles.unhighlightedOpacity).transition("highlight").duration(200)})}function Ke({defsSelection:a,clipPathData:l}){a.selectAll("clipPath").data(l).join(r=>r.append("clipPath"),r=>r,r=>r.remove()).attr("id",r=>r.id).each((r,u,g)=>{M(g[u]).selectAll("rect").data([r]).join("rect").attr("x",0).attr("y",0).attr("width",t=>t.width).attr("height",t=>t.height)})}const Ze=(a,{selection:l,computedData$:r,visibleComputedData$:u,existSeriesLabels$:g,SeriesDataMap$:t,GroupDataMap$:f,fullParams$:o,fullChartParams$:e,gridAxesTransform$:i,gridGraphicTransform$:p,gridGraphicReverseScale$:d,gridAxesSize$:x,gridHighlight$:s,gridContainer$:h,event$:S})=>{const $=new F,D=Oe(a,"clipPath-box"),G=v(a,"circleG"),P=v(a,"circle"),R=new F,{seriesSelection$:n,axesSelection$:k,defsSelection$:_,graphicGSelection$:O}=ke({selection:l,pluginName:a,clipPathID:D,existSeriesLabels$:g,gridContainer$:h,gridAxesTransform$:i,gridGraphicTransform$:p}),U=C({computedData:r,gridGraphicReverseScale:d}).pipe(A($),b(async c=>c),T(c=>c.computedData.map((I,y)=>c.gridGraphicReverseScale[y])));C({defsSelection:_,gridAxesSize:x}).pipe(A($),b(async c=>c)).subscribe(c=>{const I=[{id:D,width:c.gridAxesSize.width,height:c.gridAxesSize.height}];Ke({defsSelection:c.defsSelection,clipPathData:I})});const le=e.pipe(A($),T(c=>c.highlightTarget),V());C({graphicGSelection:O,computedData:r,visibleComputedData:u,SeriesDataMap:t,GroupDataMap:f,graphicReverseScale:U,fullChartParams:e,fullParams:o,highlightTarget:le}).pipe(A($),b(async c=>c)).subscribe(c=>{const I=Xe({graphicGSelection:c.graphicGSelection,circleGClassName:G,circleClassName:P,data:c.visibleComputedData,fullParams:c.fullParams,fullChartParams:c.fullChartParams,graphicReverseScale:c.graphicReverseScale});I.on("mouseover",(y,m)=>{y.stopPropagation(),S.next({type:"grid",eventName:"mouseover",pluginName:a,highlightTarget:c.highlightTarget,datum:m,gridIndex:m.gridIndex,series:c.SeriesDataMap.get(m.seriesLabel),seriesIndex:m.seriesIndex,seriesLabel:m.seriesLabel,groups:c.GroupDataMap.get(m.groupLabel),groupIndex:m.groupIndex,groupLabel:m.groupLabel,event:y,data:c.computedData})}).on("mousemove",(y,m)=>{y.stopPropagation(),S.next({type:"grid",eventName:"mousemove",pluginName:a,highlightTarget:c.highlightTarget,data:c.computedData,datum:m,gridIndex:m.gridIndex,series:c.SeriesDataMap.get(m.seriesLabel),seriesIndex:m.seriesIndex,seriesLabel:m.seriesLabel,groups:c.GroupDataMap.get(m.groupLabel),groupIndex:m.groupIndex,groupLabel:m.groupLabel,event:y})}).on("mouseout",(y,m)=>{y.stopPropagation(),S.next({type:"grid",eventName:"mouseout",pluginName:a,highlightTarget:c.highlightTarget,datum:m,gridIndex:m.gridIndex,series:c.SeriesDataMap.get(m.seriesLabel),seriesIndex:m.seriesIndex,seriesLabel:m.seriesLabel,groups:c.GroupDataMap.get(m.groupLabel),groupIndex:m.groupIndex,groupLabel:m.groupLabel,event:y,data:c.computedData})}).on("click",(y,m)=>{y.stopPropagation(),S.next({type:"grid",eventName:"click",pluginName:a,highlightTarget:c.highlightTarget,datum:m,gridIndex:m.gridIndex,series:c.SeriesDataMap.get(m.seriesLabel),seriesIndex:m.seriesIndex,seriesLabel:m.seriesLabel,groups:c.GroupDataMap.get(m.groupLabel),groupIndex:m.groupIndex,groupLabel:m.groupLabel,event:y,data:c.computedData})}),R.next(I)});const ne=s.subscribe(),ce=o.pipe(A($),T(c=>c.onlyShowHighlighted),V());return e.pipe(A($),b(c=>C({graphicSelection:R,highlight:s,onlyShowHighlighted:ce,fullChartParams:e}).pipe(A($),b(async I=>I)))).subscribe(c=>{Ye({selection:c.graphicSelection,ids:c.highlight,onlyShowHighlighted:c.onlyShowHighlighted,fullChartParams:c.fullChartParams})}),()=>{$.next(void 0),ne.unsubscribe()}},Qe={position:"right",justify:"end",padding:28,backgroundFill:"none",backgroundStroke:"none",gap:10,listRectWidth:14,listRectHeight:14,listRectRadius:0,gridList:[{listRectWidth:14,listRectHeight:14,listRectRadius:0}],textColorType:"primary"},qe={labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!0,axisLineColorType:"primary",tickFormat:a=>a,tickLineVisible:!0,tickPadding:20,tickFullLine:!1,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary",gridIndexes:[0]},Je={labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!1,axisLineColorType:"primary",ticks:4,tickFormat:",.0f",tickLineVisible:!0,tickPadding:20,tickFullLine:!0,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary",gridIndexes:[0]},et={barWidth:0,barPadding:1,barGroupPadding:40,barRadius:!1,gridIndexes:[0]},gt={barWidth:0,barGroupPadding:10,barRadius:!1,gridIndexes:[0]},dt={barWidth:0,barPadding:1,barGroupPadding:20,linearGradientOpacity:[1,0],gridIndexes:[0]},tt={lineCurve:"curveLinear",lineWidth:2,gridIndexes:[1]},rt={radius:4,fillColorType:"white",strokeColorType:"series",strokeWidth:2,onlyShowHighlighted:!1,gridIndexes:[1]},$t={firstAxis:{labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!1,axisLineColorType:"primary",ticks:4,tickFormat:",.0f",tickLineVisible:!0,tickPadding:20,tickFullLine:!0,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary"},secondAxis:{labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!1,axisLineColorType:"primary",ticks:4,tickFormat:",.0f",tickLineVisible:!0,tickPadding:20,tickFullLine:!0,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary"},gridIndexes:[0,1]},J="MultiGridLegend",mt=E(J,Qe)(({selection:a,rootSelection:l,observer:r,subject:u})=>{const g=new F,t=r.multiGridEachDetail$.pipe(A(g),T(i=>i.map((d,x)=>d.SeriesDataMap$.pipe(T(s=>Array.from(s.keys()))))),b(i=>C(i)),T(i=>i.flat())),f=C({fullParams:r.fullParams$,multiGrid:r.multiGridEachDetail$,computedData:r.computedData$}).pipe(A(g),b(async i=>i),T(i=>i.computedData.map((p,d)=>{const x=be(i.fullParams.gridList[d]??{},{listRectWidth:i.fullParams.listRectWidth,listRectHeight:i.fullParams.listRectHeight,listRectRadius:i.fullParams.listRectRadius});return p.map(s=>x)}).flat())),o=C({fullParams:r.fullParams$,seriesList:f}).pipe(A(g),b(async i=>i),T(i=>({...i.fullParams,seriesList:i.seriesList}))),e=_e(J,{rootSelection:l,seriesLabels$:t,fullParams$:o,layout$:r.layout$,fullChartParams$:r.fullChartParams$});return()=>{g.next(void 0),e()}}),w=a=>{const l=a.fullParams$.pipe(T(u=>u.gridIndexes),V(),z(1)),r=new F;return l.pipe(T(u=>u.map(g=>{r.next(void 0);const t=He(g).pipe(A(r),z(1)),f=C({computedData:a.computedData$,gridIndex:t}).pipe(A(r),T(n=>n.computedData[n.gridIndex]??n.computedData[0])),o=C({fullDataFormatter:a.fullDataFormatter$,gridIndex:t}).pipe(A(r),T(n=>{const k=n.fullDataFormatter.gridList[0];return{type:"grid",grid:{...n.fullDataFormatter.gridList[n.gridIndex]??k},container:{...n.fullDataFormatter.container}}})),e=C({multiGridEachDetail:a.multiGridEachDetail$,gridIndex:t}).pipe(A(r),b(async n=>n),T(n=>n.multiGridEachDetail[n.gridIndex]??n.multiGridEachDetail[0]),z(1)),i=e.pipe(b(n=>n.isSeriesPositionSeprate$)),p=e.pipe(b(n=>n.gridContainer$)),d=e.pipe(b(n=>n.gridAxesTransform$)),x=e.pipe(b(n=>n.gridAxesReverseTransform$)),s=e.pipe(b(n=>n.gridAxesSize$)),h=e.pipe(b(n=>n.gridGraphicTransform$)),S=e.pipe(b(n=>n.gridGraphicReverseScale$)),$=e.pipe(b(n=>n.gridHighlight$)),D=e.pipe(b(n=>n.existSeriesLabels$)),G=e.pipe(b(n=>n.SeriesDataMap$)),P=e.pipe(b(n=>n.GroupDataMap$)),R=e.pipe(b(n=>n.visibleComputedData$));return{gridComputedData$:f,gridDataFormatter$:o,gridAxesTransform$:d,gridGraphicTransform$:h,gridGraphicReverseScale$:S,gridAxesReverseTransform$:x,gridAxesSize$:s,gridHighlight$:$,existSeriesLabels$:D,SeriesDataMap$:G,GroupDataMap$:P,visibleComputedData$:R,isSeriesPositionSeprate$:i,gridContainer$:p}})))},j="MultiBars",ee=v(j,"grid"),ht=E(j,et)(({selection:a,name:l,subject:r,observer:u})=>{const g=new F,t=[];return w(u).subscribe(o=>{t.forEach(e=>e()),a.selectAll(`g.${ee}`).data(o).join("g").attr("class",ee).each((e,i,p)=>{const d=M(p[i]);t[i]=Ee(j,{selection:d,computedData$:e.gridComputedData$,visibleComputedData$:e.visibleComputedData$,existSeriesLabels$:e.existSeriesLabels$,SeriesDataMap$:e.SeriesDataMap$,GroupDataMap$:e.GroupDataMap$,fullParams$:u.fullParams$,fullChartParams$:u.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridGraphicTransform$:e.gridGraphicTransform$,gridGraphicReverseScale$:e.gridGraphicReverseScale$,gridAxesSize$:e.gridAxesSize$,gridHighlight$:e.gridHighlight$,gridContainer$:e.gridContainer$,isSeriesPositionSeprate$:e.isSeriesPositionSeprate$,event$:r.event$})})}),()=>{g.next(void 0),t.forEach(o=>o())}}),N="MultiLines",te=v(N,"grid"),ft=E(N,tt)(({selection:a,name:l,subject:r,observer:u})=>{const g=new F,t=[];return w(u).subscribe(o=>{t.forEach(e=>e()),a.selectAll(`g.${te}`).data(o).join("g").attr("class",te).each((e,i,p)=>{const d=M(p[i]);t[i]=Ue(N,{selection:d,computedData$:e.gridComputedData$,existSeriesLabels$:e.existSeriesLabels$,SeriesDataMap$:e.SeriesDataMap$,GroupDataMap$:e.GroupDataMap$,fullDataFormatter$:e.gridDataFormatter$,fullParams$:u.fullParams$,fullChartParams$:u.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridGraphicTransform$:e.gridGraphicTransform$,gridAxesSize$:e.gridAxesSize$,gridHighlight$:e.gridHighlight$,gridContainer$:e.gridContainer$,event$:r.event$})})}),()=>{g.next(void 0),t.forEach(o=>o())}}),B="MultiDots",re=v(B,"grid"),Dt=E(B,rt)(({selection:a,name:l,subject:r,observer:u})=>{const g=new F,t=[];return w(u).subscribe(o=>{t.forEach(e=>e()),a.selectAll(`g.${re}`).data(o).join("g").attr("class",re).each((e,i,p)=>{const d=M(p[i]);t[i]=Ze(B,{selection:d,computedData$:e.gridComputedData$,visibleComputedData$:e.visibleComputedData$,existSeriesLabels$:e.existSeriesLabels$,SeriesDataMap$:e.SeriesDataMap$,GroupDataMap$:e.GroupDataMap$,fullParams$:u.fullParams$,fullChartParams$:u.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridGraphicTransform$:e.gridGraphicTransform$,gridGraphicReverseScale$:e.gridGraphicReverseScale$,gridAxesSize$:e.gridAxesSize$,gridHighlight$:e.gridHighlight$,gridContainer$:e.gridContainer$,event$:r.event$})})}),()=>{g.next(void 0),t.forEach(o=>o())}}),W="MultiGroupAxis",ie=v(W,"grid"),xt=E(W,qe)(({selection:a,name:l,subject:r,observer:u})=>{const g=new F,t=[];return w(u).subscribe(o=>{t.forEach(e=>e()),a.selectAll(`g.${ie}`).data(o).join("g").attr("class",ie).each((e,i,p)=>{const d=M(p[i]);t[i]=we(W,{selection:d,computedData$:e.gridComputedData$,fullParams$:u.fullParams$,fullDataFormatter$:e.gridDataFormatter$,fullChartParams$:u.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridAxesReverseTransform$:e.gridAxesReverseTransform$,gridAxesSize$:e.gridAxesSize$,gridContainer$:e.gridContainer$,isSeriesPositionSeprate$:e.isSeriesPositionSeprate$})})}),()=>{g.next(void 0),t.forEach(o=>o())}}),X="MultiValueAxis",ae=v(X,"grid"),St=E(X,Je)(({selection:a,name:l,subject:r,observer:u})=>{const g=new F,t=[];return w(u).subscribe(o=>{t.forEach(e=>e()),a.selectAll(`g.${ae}`).data(o).join("g").attr("class",ae).each((e,i,p)=>{const d=M(p[i]);t[i]=ze(X,{selection:d,computedData$:e.gridComputedData$,fullParams$:u.fullParams$,fullDataFormatter$:e.gridDataFormatter$,fullChartParams$:u.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridAxesReverseTransform$:e.gridAxesReverseTransform$,gridAxesSize$:e.gridAxesSize$,gridContainer$:e.gridContainer$,isSeriesPositionSeprate$:e.isSeriesPositionSeprate$})})}),()=>{g.next(void 0),t.forEach(o=>o())}}),bt=[[[1205,850,930,1111,1500],[735,900,880,1035,1120]],[[55,60,50,70,75],[35,40,45,65,80]]];export{gt as D,pt as M,dt as a,xt as b,Ze as c,St as d,ht as e,mt as f,bt as g,ft as h,Dt as i,$t as j,w as m};
