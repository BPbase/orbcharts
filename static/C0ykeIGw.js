import{ai as i,an as T,a8 as s,a7 as c,ae as B,a6 as C,af as O,ag as S,A as F,aQ as R}from"./D7osWch-.js";import{q as P,g as G,a as L,b as j,d as M,e as V,f as k,i as w,h as z,j as _,k as E,r as U}from"./CtfRwFoZ.js";const q=e=>{const t=i(e,{visibleFilter:{toBeTypes:["Function"]},grid:{toBeTypes:["object"]},container:{toBeTypes:["object"]}});if(e.grid){const r=i(e.grid,{seriesDirection:{toBe:'"row" | "column"',test:o=>o==="row"||o==="column"},rowLabels:{toBeTypes:["string[]"]},columnLabels:{toBeTypes:["string[]"]},valueAxis:{toBeTypes:["object"]},groupAxis:{toBeTypes:["object"]},separateSeries:{toBeTypes:["boolean"]}});if(r.status==="error")return r;if(e.grid.valueAxis){const o=i(e.grid.valueAxis,{position:{toBe:'"left" | "right"',test:a=>a==="left"||a==="right"},scaleDomain:{toBe:'[number | "min" | "auto", number | "max" | "auto"]',test:a=>Array.isArray(a)&&a.length===2&&(typeof a[0]=="number"||a[0]==="min"||a[0]==="auto")&&(typeof a[1]=="number"||a[1]==="max"||a[1]==="auto")},scaleRange:{toBe:"[number, number]",test:a=>Array.isArray(a)&&a.length===2&&typeof a[0]=="number"&&typeof a[1]=="number"},label:{toBeTypes:["string"]}});if(o.status==="error")return o}if(e.grid.groupAxis){const o=i(e.grid.groupAxis,{position:{toBe:'"top" | "bottom"',test:a=>a==="top"||a==="bottom"},scaleDomain:{toBe:'[number, number | "max"]',test:a=>Array.isArray(a)&&a.length===2&&typeof a[0]=="number"&&(typeof a[1]=="number"||a[1]==="max")},scalePadding:{toBeTypes:["number"]},label:{toBeTypes:["string"]}});if(o.status==="error")return o}}if(e.container){const r=i(e.container,{gap:{toBeTypes:["number"]},rowAmount:{toBeTypes:["number"]},columnAmount:{toBeTypes:["number"]}});if(r.status==="error")return r}return t},H=e=>i({data:e},{data:{toBe:"(DataGridDatum | DataGridValue)[][]",test:r=>Array.isArray(r)}}),I=({subject:e,observer:t})=>{const r=T(t.fullChartParams$).pipe(s(1)),o=t.fullDataFormatter$.pipe(c(u=>u.grid.separateSeries),B(),s(1)),a=P({computedData$:t.computedData$,fullDataFormatter$:t.fullDataFormatter$,layout$:t.layout$}),l=G({fullDataFormatter$:t.fullDataFormatter$,layout$:t.layout$}).pipe(s(1)),$=L({gridAxesTransform$:l}).pipe(s(1)),p=j({computedData$:t.computedData$,fullDataFormatter$:t.fullDataFormatter$,layout$:t.layout$}).pipe(s(1)),d=M({gridContainerPosition$:a,gridAxesTransform$:l,gridGraphicTransform$:p}),D=V({fullDataFormatter$:t.fullDataFormatter$,layout$:t.layout$}).pipe(s(1)),n=t.computedData$.pipe(c(u=>u.flat())).pipe(s(1)),g=C({datumList$:n,fullChartParams$:t.fullChartParams$,event$:e.event$}).pipe(s(1)),f=k({computedData$:t.computedData$}),b=O({datumList$:n}).pipe(s(1)),y=S({datumList$:n}).pipe(s(1)),m=w({computedData$:t.computedData$,fullDataFormatter$:t.fullDataFormatter$,layout$:t.layout$}).pipe(s(1)),A=z({computedData$:t.computedData$}).pipe(s(1)),x=_({computedLayoutData$:m}).pipe(s(1)),h=E({computedData$:t.computedData$,isSeriesSeprate$:o}).pipe(s(1));return{fullParams$:t.fullParams$,fullChartParams$:t.fullChartParams$,fullDataFormatter$:t.fullDataFormatter$,computedData$:t.computedData$,layout$:t.layout$,textSizePx$:r,isSeriesSeprate$:o,gridContainerPosition$:a,gridAxesTransform$:l,gridAxesReverseTransform$:$,gridGraphicTransform$:p,gridGraphicReverseScale$:d,gridAxesSize$:D,gridHighlight$:g,seriesLabels$:f,SeriesDataMap$:b,GroupDataMap$:y,computedLayoutData$:m,visibleComputedData$:A,visibleComputedLayoutData$:x,computedStackedData$:h}};class K extends F{constructor(t,r){super({defaultDataFormatter:R,dataFormatterValidator:q,computedDataFn:U,dataValidator:H,contextObserverCallback:I},t,r)}}export{K as G};
