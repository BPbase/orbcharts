import{S as G,O as S,c as D,t as g,s as x,m,p as C,a as b}from"./B0ZHf31c.js";import{j as v,m as L}from"./DK-HOdcA.js";import{c as O}from"./BWQ4_dzs.js";import{g as T}from"./DTR3OuCX.js";import{o as F}from"./Scc6E3Yy.js";function h(u,d,p,a){const{gap:o,rowAmount:e,columnAmount:i}=d,c=(u.width-o*(i-1))/i,l=(u.height-o*(e-1))/e,n=a*c+a*o,r=p*l+p*o,t=[n,r],s=[c/u.width,l/u.height];return{translate:t,scale:s}}const w=({fullDataFormatter$:u,layout$:d})=>{const p=new G;function a({xAxis:o,yAxis:e,width:i,height:c}){if(!o||!e)return{translate:[0,0],scale:[1,1],rotate:0,rotateX:0,rotateY:0,value:""};let l=0,n=0,r=0,t=0,s=0;return o.position==="bottom"?e.position==="left"?(t=180,n=c):e.position==="right"?(t=180,s=180,l=i,n=c):(t=180,n=c):o.position==="top"?e.position==="left"||(e.position==="right"?(s=180,l=i):(t=180,n=c)):o.position==="left"?e.position==="bottom"?(r=-90,n=c):e.position==="top"?(r=-90,s=180):(t=180,n=c):o.position==="right"&&(e.position==="bottom"?(r=-90,t=180,n=c,l=i):e.position==="top"?(r=-90,t=180,s=180,l=i):(t=180,n=c)),{translate:[l,n],scale:[1,1],rotate:r,rotateX:t,rotateY:s,value:`translate(${l}px, ${n}px) rotate(${r}deg) rotateX(${t}deg) rotateY(${s}deg)`}}return new S(o=>(D({fullDataFormatter:u,layout:d}).pipe(g(p),x(async e=>e)).subscribe(e=>{const i=a({xAxis:e.fullDataFormatter.grid.groupAxis,yAxis:e.fullDataFormatter.grid.valueAxis,width:e.layout.width,height:e.layout.height});o.next(i)}),function(){p.next(void 0)}))},X=({gridAxesTransform$:u})=>u.pipe(m(d=>{const p=[0,0],a=[1/d.scale[0],1/d.scale[1]],o=d.rotate*-1,e=d.rotateX*-1,i=d.rotateY*-1;return{translate:p,scale:a,rotate:o,rotateX:e,rotateY:i,value:`translate(${p[0]}px, ${p[1]}px) rotate(${o}deg) rotateX(${e}deg) rotateY(${i}deg)`}})),Y=({computedData$:u,fullDataFormatter$:d,fullChartParams$:p,layout$:a})=>D({computedData:u,fullDataFormatter:d,fullChartParams:p,layout:a}).pipe(x(async e=>e),m(e=>{const i=e.fullDataFormatter.grid;if(!!(i.seriesSlotIndexes&&i.seriesSlotIndexes.length===e.computedData.length))return e.computedData.map((l,n)=>{const r=i.seriesSlotIndexes[n]%e.fullDataFormatter.container.columnAmount,t=Math.floor(i.seriesSlotIndexes[n]/e.fullDataFormatter.container.columnAmount),{translate:s,scale:f}=h(e.layout,e.fullDataFormatter.container,t,r);return{slotIndex:i.seriesSlotIndexes[n],rowIndex:t,columnIndex:r,translate:s,scale:f}});{const l=i.slotIndex%e.fullDataFormatter.container.columnAmount,n=Math.floor(i.slotIndex/e.fullDataFormatter.container.columnAmount);return e.computedData.map((r,t)=>{const{translate:s,scale:f}=h(e.layout,e.fullDataFormatter.container,n,l);return{slotIndex:i.slotIndex,rowIndex:n,columnIndex:l,translate:s,scale:f}})}})),A="OverlappingValueAxes",P=T(A,"grid"),M=C(A,v)(({selection:u,name:d,subject:p,observer:a})=>{const o=new G,e=[],i=a.fullParams$.pipe(g(o),m(r=>r.gridIndexes[0])),c=a.fullParams$.pipe(g(o),m(r=>r.gridIndexes[1])),l=D({firstGridIndex:i,secondGridIndex:c}).pipe(g(o),x(r=>a.fullDataFormatter$.pipe(g(o),m(t=>{t.gridList[r.secondGridIndex]||(t.gridList[r.secondGridIndex]=Object.assign({},t.gridList[r.firstGridIndex]));let s="";return t.gridList[r.firstGridIndex].valueAxis.position==="left"?s="right":t.gridList[r.firstGridIndex].valueAxis.position==="bottom"?s="top":t.gridList[r.firstGridIndex].valueAxis.position==="top"?s="bottom":t.gridList[r.firstGridIndex].valueAxis.position==="right"&&(s="left"),console.log("reversePosition",s),{type:"grid",grid:{...t.gridList[r.secondGridIndex],valueAxis:{...t.gridList[r.secondGridIndex].valueAxis,position:s}},container:{...t.container}}}))));return F(a).pipe(g(o),m(r=>({...r,fullParams$:r.fullParams$.pipe(m(t=>(t.gridIndexes.length>2&&(t.gridIndexes.length=2),t)))})),x(r=>L(r)),m(r=>r.map((t,s)=>{if(s===0)return t;const f=w({fullDataFormatter$:l,layout$:a.layout$}),I=X({gridAxesTransform$:f}),$=Y({computedData$:t.gridComputedData$,fullDataFormatter$:l,fullChartParams$:a.fullChartParams$,layout$:a.layout$});return{...t,gridAxesTransform$:f,gridAxesReverseTransform$:I,gridContainer$:$}}))).subscribe(r=>{e.forEach(t=>t()),u.selectAll(`g.${P}`).data(r).join("g").attr("class",P).each((t,s,f)=>{if(s>1)return;const I=b(f[s]);e[s]=O(A,{selection:I,computedData$:t.gridComputedData$,fullParams$:a.fullParams$.pipe(m($=>s===0?$.firstAxis:$.secondAxis)),fullDataFormatter$:t.gridDataFormatter$,fullChartParams$:a.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridAxesReverseTransform$:t.gridAxesReverseTransform$,gridAxesSize$:t.gridAxesSize$,gridContainer$:t.gridContainer$,isSeriesPositionSeprate$:t.isSeriesPositionSeprate$})})}),()=>{o.next(void 0),e.forEach(r=>r())}});export{M as O};
