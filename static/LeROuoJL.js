import{a0 as W,a1 as na,a2 as ua,a3 as ca,a4 as ma,c as $a,a5 as pa,a6 as da,a7 as x,a8 as $,a9 as aa,aa as ta,ab as N,ac as g,ad as ga,ae as Da,af as fa,ag as ha,ah as Ga,A as Aa,ai as ba,e as P,I as La,S,t as f,m as h,p as j,o as E,aj as Pa,h as _,i as O,G as Sa,s as M,K as Ca,H as Fa,J as xa,l as Ma}from"./CzjhHakb.js";import{a as Ta,g as ya,b as va,d as Ra,e as Ea,f as _a,s as Oa,h as Ua,i as Ia,j as za,k as Na}from"./sU_-MLKA.js";import{c as ja}from"./zpKl2suD.js";import{c as wa}from"./Cq4NHVJa.js";import{g as T}from"./u-UBqIpB.js";import{c as Ba}from"./C_u8zaRd.js";import{c as Ha}from"./CFEEDzG_.js";import{a as ka,c as Va}from"./DkqUpMvk.js";const Wa=m=>{const{data:n=[],dataFormatter:r,chartParams:i}=m;if(!n.length)return[];let s=[];try{const e=r.gridList[0]||W,d=n.map((o,u)=>r.gridList[u]||e),c=n.map((o,u)=>Ta(o,d[u])),a=r.separateGrid?c.map((o,u)=>na({transposedDataGrid:o,dataFormatterGrid:d[u],chartType:"multiGrid"})):c.map((o,u)=>ua({transposedDataGrid:o,dataFormatterGrid:d[u],chartType:"multiGrid",gridIndex:u})),t=new Map;let l=0;a.flat().forEach((o,u)=>{if(!t.has(o)){const p=ca(l,i);t.set(o,p),l++}}),s=c.map((o,u)=>{const p=a[u],G=ma({transposedDataGrid:o,dataFormatterGrid:d[u],chartType:"multiGrid",gridIndex:u});let D=0;return o.map((v,b)=>v.map((A,L)=>{const R=$a("multiGrid",u,b,L),I=G[L],C=p[b],F={id:A.id?A.id:R,index:D,label:A.label?A.label:R,description:A.description??"",data:A.data,value:A.value,gridIndex:u,seriesIndex:b,seriesLabel:C,groupIndex:L,groupLabel:I,color:t.get(C),visible:!0};return F.visible=r.visibleFilter(F,m),D++,F}))})}catch(e){throw Error(e)}return s},Xa=({fullDataFormatter$:m,computedData$:n,layout$:r,fullChartParams$:i,event$:s})=>{const e=new pa,d=da({datumList$:n.pipe(x(a=>a.flat().flat()),$(1)),fullChartParams$:i,event$:s}).pipe($(1)),c=ea({computedData$:n,fullDataFormatter$:m,layout$:r}).pipe($(1));return aa({fullDataFormatter:m,computedData:n,multiGridContainer:c}).pipe(ta(async a=>a),x(a=>{e.next(void 0);const t=a.fullDataFormatter.gridList[0]??W;return a.computedData.map((l,o)=>{const u=a.fullDataFormatter.gridList[o]??t,p={type:"grid",visibleFilter:a.fullDataFormatter.visibleFilter,grid:{...u},container:{...a.fullDataFormatter.container}},G=N(p).pipe(g(e),$(1)),D=N(l).pipe(g(e),$(1)),U=G.pipe(x(z=>z.grid.separateSeries),ga(),$(1)),v=N(a.multiGridContainer[o]).pipe(g(e),$(1)),b=ya({fullDataFormatter$:G,layout$:r}).pipe(g(e),$(1)),A=va({gridAxesTransform$:b}).pipe(g(e),$(1)),L=Ra({computedData$:D,fullDataFormatter$:G,layout$:r}).pipe(g(e),$(1)),R=Ea({gridContainerPosition$:v,gridAxesTransform$:b,gridGraphicTransform$:L}),I=_a({fullDataFormatter$:G,layout$:r}).pipe(g(e),$(1)),C=D.pipe(x(z=>z.flat())).pipe(g(e),$(1)),F=Oa({computedData$:D}).pipe(g(e),$(1)),ra=Da({datumList$:C}).pipe(g(e),$(1)),ia=fa({datumList$:C}).pipe(g(e),$(1)),sa=Ua({computedData$:D}).pipe(g(e),$(1)),X=Ia({computedData$:D,fullDataFormatter$:G,layout$:r}).pipe(g(e),$(1)),la=za({computedLayoutData$:X}).pipe(g(e),$(1)),oa=Na({computedData$:D,isSeriesSeprate$:U}).pipe($(1));return{isSeriesSeprate$:U,gridContainerPosition$:v,gridAxesTransform$:b,gridAxesReverseTransform$:A,gridGraphicTransform$:L,gridGraphicReverseScale$:R,gridAxesSize$:I,gridHighlight$:d,seriesLabels$:F,SeriesDataMap$:ra,GroupDataMap$:ia,dataFormatter$:G,computedData$:D,computedLayoutData$:X,visibleComputedData$:sa,visibleComputedLayoutData$:la,computedStackedData$:oa}})}))},ea=({computedData$:m,fullDataFormatter$:n,layout$:r})=>aa({computedData:m,fullDataFormatter:n,layout:r}).pipe(ta(async i=>i),x(i=>{const s=i.fullDataFormatter.gridList[0]??W,e=i.computedData.reduce((t,l,o)=>{const p=(i.fullDataFormatter.gridList[o]??s).separateSeries?l.length:i.fullDataFormatter.separateGrid?1:0;return t+p},0)||1,d=ha(i.layout,i.fullDataFormatter.container,e);let c=0;return i.computedData.map((t,l)=>{const o=i.fullDataFormatter.gridList[l]??s,u=t.map((p,G)=>{const D=d[c];return o.separateSeries&&(c+=1),D});return!o.separateSeries&&i.fullDataFormatter.separateGrid&&(c+=1),u})})),Ja=({subject:m,observer:n})=>{const r=Ga(n.fullChartParams$).pipe($(1)),i=Xa({fullDataFormatter$:n.fullDataFormatter$,computedData$:n.computedData$,layout$:n.layout$,fullChartParams$:n.fullChartParams$,event$:m.event$}).pipe($(1)),s=ea({computedData$:n.computedData$,fullDataFormatter$:n.fullDataFormatter$,layout$:n.layout$});return{fullParams$:n.fullParams$,fullChartParams$:n.fullChartParams$,fullDataFormatter$:n.fullDataFormatter$,computedData$:n.computedData$,layout$:n.layout$,textSizePx$:r,multiGridContainerPosition$:s,multiGridEachDetail$:i}};class rt extends Aa{constructor(n,r){super({defaultDataFormatter:ba,computedDataFn:Wa,contextObserverFn:Ja},n,r)}}const J="MultiGridLegend",it=P(J,La)(({selection:m,rootSelection:n,observer:r,subject:i})=>{const s=new S,e=r.multiGridEachDetail$.pipe(f(s),h(t=>t.map((o,u)=>o.SeriesDataMap$.pipe(h(p=>Array.from(p.keys()))))),j(t=>E(t)),h(t=>t.flat())),d=E({fullParams:r.fullParams$,computedData:r.computedData$}).pipe(f(s),j(async t=>t),h(t=>t.computedData.map((l,o)=>{const u=Pa(t.fullParams.gridList[o]??{},{listRectWidth:t.fullParams.listRectWidth,listRectHeight:t.fullParams.listRectHeight,listRectRadius:t.fullParams.listRectRadius});return l.map(p=>u)}).flat())),c=E({fullParams:r.fullParams$,seriesList:d}).pipe(f(s),j(async t=>t),h(t=>({...t.fullParams,seriesList:t.seriesList}))),a=ja(J,{rootSelection:n,seriesLabels$:e,fullParams$:c,layout$:r.layout$,fullChartParams$:r.fullChartParams$,textSizePx$:r.textSizePx$});return()=>{s.next(void 0),a()}}),y=m=>{const n=m.fullParams$.pipe(h(r=>r.gridIndexes),_(),O(1));return E({multiGridEachDetail:m.multiGridEachDetail$,gridIndexes:n}).pipe(h(r=>r.gridIndexes==="all"?r.multiGridEachDetail:r.gridIndexes.map(i=>r.multiGridEachDetail[i]??r.multiGridEachDetail[0])))},w="MultiBars",K=T(w,"grid"),st=P(w,Sa)(({selection:m,name:n,subject:r,observer:i})=>{const s=new S,e=[];return y(i).pipe(f(s)).subscribe(c=>{e.forEach(a=>a()),m.selectAll(`g.${K}`).data(c).join("g").attr("class",K).each((a,t,l)=>{const o=M(l[t]),u=a.dataFormatter$.pipe(f(s),h(p=>p.grid.separateSeries),_(),O(1));e[t]=wa(w,{selection:o,computedData$:a.computedData$,visibleComputedData$:a.visibleComputedData$,computedLayoutData$:a.computedLayoutData$,visibleComputedLayoutData$:a.visibleComputedLayoutData$,seriesLabels$:a.seriesLabels$,SeriesDataMap$:a.SeriesDataMap$,GroupDataMap$:a.GroupDataMap$,fullParams$:i.fullParams$,fullChartParams$:i.fullChartParams$,gridAxesTransform$:a.gridAxesTransform$,gridGraphicTransform$:a.gridGraphicTransform$,gridGraphicReverseScale$:a.gridGraphicReverseScale$,gridAxesSize$:a.gridAxesSize$,gridHighlight$:a.gridHighlight$,gridContainerPosition$:a.gridContainerPosition$,isSeriesSeprate$:u,event$:r.event$})})}),()=>{s.next(void 0),e.forEach(c=>c())}}),B="MultiLines",q=T(B,"grid"),lt=P(B,Ca)(({selection:m,rootSelection:n,name:r,subject:i,observer:s})=>{const e=new S,d=[],c=s.multiGridContainerPosition$.pipe(f(e),h(t=>t.flat()));return y(s).pipe(f(e)).subscribe(t=>{d.forEach(l=>l()),m.selectAll(`g.${q}`).data(t).join("g").attr("class",q).each((l,o,u)=>{const p=M(u[o]);d[o]=Ba(B,{selection:p,computedData$:l.computedData$,computedLayoutData$:l.computedLayoutData$,visibleComputedData$:l.visibleComputedData$,visibleComputedLayoutData$:l.visibleComputedLayoutData$,seriesLabels$:l.seriesLabels$,SeriesDataMap$:l.SeriesDataMap$,GroupDataMap$:l.GroupDataMap$,fullDataFormatter$:l.dataFormatter$,fullParams$:s.fullParams$,fullChartParams$:s.fullChartParams$,gridAxesTransform$:l.gridAxesTransform$,gridGraphicTransform$:l.gridGraphicTransform$,gridAxesSize$:l.gridAxesSize$,gridHighlight$:l.gridHighlight$,gridContainerPosition$:l.gridContainerPosition$,allContainerPosition$:c,layout$:s.layout$,event$:i.event$})})}),()=>{e.next(void 0),d.forEach(t=>t())}}),H="MultiDots",Q=T(H,"grid"),ot=P(H,Fa)(({selection:m,name:n,subject:r,observer:i})=>{const s=new S,e=[];return y(i).pipe(f(s)).subscribe(c=>{e.forEach(a=>a()),m.selectAll(`g.${Q}`).data(c).join("g").attr("class",Q).each((a,t,l)=>{const o=M(l[t]);e[t]=Ha(H,{selection:o,computedData$:a.computedData$,visibleComputedData$:a.visibleComputedData$,computedLayoutData$:a.computedLayoutData$,visibleComputedLayoutData$:a.visibleComputedLayoutData$,seriesLabels$:a.seriesLabels$,SeriesDataMap$:a.SeriesDataMap$,GroupDataMap$:a.GroupDataMap$,fullParams$:i.fullParams$,fullChartParams$:i.fullChartParams$,gridAxesTransform$:a.gridAxesTransform$,gridGraphicTransform$:a.gridGraphicTransform$,gridGraphicReverseScale$:a.gridGraphicReverseScale$,gridAxesSize$:a.gridAxesSize$,gridHighlight$:a.gridHighlight$,gridContainerPosition$:a.gridContainerPosition$,event$:r.event$})})}),()=>{s.next(void 0),e.forEach(c=>c())}}),k="MultiGroupAxis",Y=T(k,"grid"),nt=P(k,xa)(({selection:m,name:n,subject:r,observer:i})=>{const s=new S,e=[];return y(i).pipe(f(s)).subscribe(c=>{e.forEach(a=>a()),m.selectAll(`g.${Y}`).data(c).join("g").attr("class",Y).each((a,t,l)=>{const o=M(l[t]),u=a.dataFormatter$.pipe(f(s),h(p=>p.grid.separateSeries),_(),O(1));e[t]=ka(k,{selection:o,computedData$:a.computedData$,fullParams$:i.fullParams$,fullDataFormatter$:a.dataFormatter$,fullChartParams$:i.fullChartParams$,gridAxesTransform$:a.gridAxesTransform$,gridAxesReverseTransform$:a.gridAxesReverseTransform$,gridAxesSize$:a.gridAxesSize$,gridContainerPosition$:a.gridContainerPosition$,isSeriesSeprate$:u})})}),()=>{s.next(void 0),e.forEach(c=>c())}}),V="MultiValueAxis",Z=T(V,"grid"),ut=P(V,Ma)(({selection:m,name:n,subject:r,observer:i})=>{const s=new S,e=[];return y(i).pipe(f(s)).subscribe(c=>{e.forEach(a=>a()),m.selectAll(`g.${Z}`).data(c).join("g").attr("class",Z).each((a,t,l)=>{const o=M(l[t]),u=a.dataFormatter$.pipe(f(s),h(p=>p.grid.separateSeries),_(),O(1));e[t]=Va(V,{selection:o,computedData$:a.computedData$,fullParams$:i.fullParams$,fullDataFormatter$:a.dataFormatter$,fullChartParams$:i.fullChartParams$,gridAxesTransform$:a.gridAxesTransform$,gridAxesReverseTransform$:a.gridAxesReverseTransform$,gridAxesSize$:a.gridAxesSize$,gridContainerPosition$:a.gridContainerPosition$,isSeriesSeprate$:u})})}),()=>{s.next(void 0),e.forEach(c=>c())}});export{st as M,ot as a,it as b,nt as c,lt as d,ut as e,rt as f,y as m};
