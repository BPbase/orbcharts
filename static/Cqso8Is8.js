import{at as x,au as H,av as $t,aw as gt,ax as ft,ay as bt,az as Dt,aA as yt,aB as d,aC as it,aD as st,aE as T,aF as j,aG as g,aH as At,aI as Tt,aJ as ht,aK as xt,aL as Ct,aM as Pt,aN as Gt,aO as Lt,aP as Bt,a as C,S as P,m as y,l as B,k as _,t as D,P as St,aQ as Ft,aR as Rt,d as I,b as k,s as S,g as F,M as Mt,L as ot,T as Ot,N as Et,q as _t,R as It,j as nt,i as kt}from"./ZOIXw5Nq.js";import{c as zt,g as Nt,a as Ut,b as Vt,d as wt,e as jt,f as Ht,h as vt,i as Wt,j as Xt,k as Yt,l as qt,m as Jt,n as Kt}from"./wO7_YHzT.js";import{c as Qt}from"./nbwQzsGv.js";import{c as Zt}from"./DB2ujUM5.js";import{c as te}from"./DjoSwNnf.js";import{c as ee}from"./BxnsOsQw.js";import{a as ae,c as re}from"./BhhwBwE2.js";const ie=s=>{const i=x(s,{visibleFilter:{toBeTypes:["Function"]},gridList:{toBeTypes:["object[]"]},container:{toBeTypes:["object"]},separateGrid:{toBeTypes:["boolean"]}});if(s.gridList){const e=s.gridList.map((a,p)=>{const l=x(a,{seriesDirection:{toBe:'"row" | "column"',test:n=>n==="row"||n==="column"},rowLabels:{toBeTypes:["string[]"]},columnLabels:{toBeTypes:["string[]"]},valueAxis:{toBeTypes:["object"]},groupAxis:{toBeTypes:["object"]},separateSeries:{toBeTypes:["boolean"]}});if(l.status==="error")return l;if(a.valueAxis){const n=x(a.valueAxis,{position:{toBe:'"top" | "bottom" | "left" | "right"',test:t=>t==="top"||t==="bottom"||t==="left"||t==="right"},scaleDomain:{toBe:'[number | "min" | "auto", number | "max" | "auto"]',test:t=>Array.isArray(t)&&t.length===2&&(typeof t[0]=="number"||t[0]==="min"||t[0]==="auto")&&(typeof t[1]=="number"||t[1]==="max"||t[1]==="auto")},scaleRange:{toBe:"[number, number]",test:t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&typeof t[1]=="number"},label:{toBeTypes:["string"]}});if(n.status==="error")return n}else if(a.groupAxis){const n=x(a.groupAxis,{position:{toBe:'"top" | "bottom" | "left" | "right"',test:t=>t==="top"||t==="bottom"||t==="left"||t==="right"},scaleDomain:{toBe:'[number, number | "max"]',test:t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&(typeof t[1]=="number"||t[1]==="max")},scalePadding:{toBeTypes:["number"]},label:{toBeTypes:["string"]}});if(n.status==="error")return n}return{status:"success",columnName:"",expectToBe:""}}).find(a=>a.status==="error");if(e)return e}if(s.container){const r=x(s.container,{columnAmount:{toBeTypes:["number"]},rowAmount:{toBeTypes:["number"]},columnGap:{toBe:'"auto" | number',test:e=>e==="auto"||typeof e=="number"},rowGap:{toBe:'"auto" | number',test:e=>e==="auto"||typeof e=="number"}});if(r.status==="error")return r}return i},se=s=>{const{data:i=[],dataFormatter:r,chartParams:e}=s;if(!i.length)return[];let a=[];try{const p=r.gridList[0]||H,l=i.map((c,m)=>r.gridList[m]||p),n=i.map((c,m)=>zt(c,l[m])),t=r.separateGrid?n.map((c,m)=>$t({transposedDataGrid:c,dataFormatterGrid:l[m],chartType:"multiGrid"})):n.map((c,m)=>gt({transposedDataGrid:c,dataFormatterGrid:l[m],chartType:"multiGrid",gridIndex:m})),o=new Map;let u=0;t.flat().forEach((c,m)=>{if(!o.has(c)){const $=ft(u,e);o.set(c,$),u++}}),a=n.map((c,m)=>{const $=t[m],b=bt({transposedDataGrid:c,dataFormatterGrid:l[m],chartType:"multiGrid",gridIndex:m});let f=0;return c.map((M,G)=>M.map((A,h)=>{const O=Dt("multiGrid",m,G,h),N=b[h],E=$[G],L={id:A.id?A.id:O,index:f,label:A.label?A.label:O,description:A.description??"",data:A.data,value:A.value,gridIndex:m,seriesIndex:G,seriesLabel:E,groupIndex:h,groupLabel:N,color:o.get(E),visible:!0};return L.visible=r.visibleFilter(L,s),f++,L}))})}catch(p){throw Error(p)}return a},oe=s=>x({data:s},{data:{toBe:"DataGrid[]",test:r=>Array.isArray(r)}}),ne=({fullDataFormatter$:s,computedData$:i,layout$:r,fullChartParams$:e,event$:a,containerSize$:p})=>{const l=new yt,n=lt({computedData$:i,fullDataFormatter$:s,layout$:r}).pipe(d(1));return it({fullDataFormatter:s,computedData:i,multiGridContainer:n}).pipe(st(async t=>t),T(t=>{l.next(void 0);const o=t.fullDataFormatter.gridList[0]??H;return t.computedData.map((u,c)=>{const m=t.fullDataFormatter.gridList[c]??o,$={type:"grid",visibleFilter:t.fullDataFormatter.visibleFilter,...m,container:{...t.fullDataFormatter.container}},b=j($).pipe(g(l),d(1)),f=j(u).pipe(g(l),d(1)),z=b.pipe(T(w=>w.separateSeries),At(),d(1)),M=j(t.multiGridContainer[c]).pipe(g(l),d(1)),G=Nt({fullDataFormatter$:b,layout$:r}).pipe(g(l),d(1)),A=Ut({fullDataFormatter$:b,containerSize$:p}).pipe(d(1)),h=f.pipe(T(w=>w.flat())).pipe(g(l),d(1)),O=Vt({computedData$:f}).pipe(g(l),d(1)),N=Tt({datumList$:h}).pipe(g(l),d(1)),E=ht({datumList$:h}).pipe(g(l),d(1)),L=wt({computedData$:f}).pipe(g(l),d(1)),J=jt({computedData$:f,fullDataFormatter$:b,layout$:r}).pipe(g(l),d(1)),pt=Ht({computedAxesData$:J}).pipe(g(l),d(1)),ct=vt({computedData$:f,isSeriesSeprate$:z}).pipe(d(1)),U=Wt({computedData$:f,fullDataFormatter$:b}).pipe(g(l),d(1)),K=Xt({computedData$:f,groupScaleDomainValue$:U}).pipe(g(l),d(1)),V=Yt({fullDataFormatter$:b,layout$:r}).pipe(g(l),d(1)),mt=qt({gridAxesTransform$:V}).pipe(g(l),d(1)),Q=Jt({computedData$:f,groupScaleDomainValue$:U,filteredMinMaxValue$:K,fullDataFormatter$:b,layout$:r}).pipe(g(l),d(1)),dt=Kt({gridContainerPosition$:M,gridAxesTransform$:V,gridGraphicTransform$:Q});return{isSeriesSeprate$:z,gridContainerPosition$:M,gridAxesSize$:G,gridAxesContainerSize$:A,seriesLabels$:O,SeriesDataMap$:N,GroupDataMap$:E,dataFormatter$:b,computedData$:f,computedAxesData$:J,visibleComputedData$:L,visibleComputedAxesData$:pt,computedStackedData$:ct,groupScaleDomainValue$:U,filteredMinMaxValue$:K,gridAxesTransform$:V,gridAxesReverseTransform$:mt,gridGraphicTransform$:Q,gridGraphicReverseScale$:dt}})}))},lt=({computedData$:s,fullDataFormatter$:i,layout$:r})=>it({computedData:s,fullDataFormatter:i,layout:r}).pipe(st(async e=>e),T(e=>{const a=e.fullDataFormatter.gridList[0]??H,p=e.computedData.reduce((o,u,c)=>{const $=(e.fullDataFormatter.gridList[c]??a).separateSeries?u.length:e.fullDataFormatter.separateGrid?1:0;return o+$},0)||1,l=xt(e.layout,e.fullDataFormatter.container,p);let n=0;return e.computedData.map((o,u)=>{const c=e.fullDataFormatter.gridList[u]??a,m=o.map(($,b)=>{const f=l[n];return c.separateSeries&&(n+=1),f});return!c.separateSeries&&e.fullDataFormatter.separateGrid&&(n+=1),m})})),le=({subject:s,observer:i})=>{const r=Ct(i.fullChartParams$).pipe(d(1)),e=lt({computedData$:i.computedData$,fullDataFormatter$:i.fullDataFormatter$,layout$:i.layout$}).pipe(d(1)),a=Pt({layout$:i.layout$,containerPosition$:e.pipe(T(n=>n.flat())),container$:i.fullDataFormatter$.pipe(T(n=>n.container))}).pipe(d(1)),p=Gt({datumList$:i.computedData$.pipe(T(n=>n.flat().flat()),d(1)),fullChartParams$:i.fullChartParams$,event$:s.event$}).pipe(d(1)),l=ne({fullDataFormatter$:i.fullDataFormatter$,computedData$:i.computedData$,layout$:i.layout$,fullChartParams$:i.fullChartParams$,event$:s.event$,containerSize$:a}).pipe(d(1));return{fullParams$:i.fullParams$,fullChartParams$:i.fullChartParams$,fullDataFormatter$:i.fullDataFormatter$,computedData$:i.computedData$,layout$:i.layout$,textSizePx$:r,containerSize$:a,multiGridHighlight$:p,multiGridContainerPosition$:e,multiGridEachDetail$:l}};class he extends Lt{constructor(i,r){super({defaultDataFormatter:Bt,dataFormatterValidator:ie,computedDataFn:se,dataValidator:oe,contextObserverCallback:le},i,r)}}const ut="MultiGridLegend",ue={name:ut,defaultParams:St,layerIndex:Ft,validator:(s,{validateColumns:i})=>{const r=i(s,{placement:{toBe:'"top" | "top-start" | "top-end" | "bottom" | "bottom-start" | "bottom-end" | "left" | "left-start" | "left-end" | "right" | "right-start" | "right-end"',test:e=>["top","top-start","top-end","bottom","bottom-start","bottom-end","left","left-start","left-end","right","right-start","right-end"].includes(e)},padding:{toBeTypes:["number"]},backgroundFill:{toBeOption:"ColorType"},backgroundStroke:{toBeOption:"ColorType"},gap:{toBeTypes:["number"]},listRectWidth:{toBeTypes:["number"]},listRectHeight:{toBeTypes:["number"]},listRectRadius:{toBeTypes:["number"]},gridList:{toBeTypes:["object[]"]},textColorType:{toBeOption:"ColorType"}});if(s.gridList){const a=s.gridList.map((p,l)=>i(p,{listRectWidth:{toBeTypes:["number"]},listRectHeight:{toBeTypes:["number"]},listRectRadius:{toBeTypes:["number"]}})).find(p=>p.status==="error");if(a)return a}return r}},xe=C(ue)(({selection:s,rootSelection:i,observer:r,subject:e})=>{const a=new P,p=r.multiGridEachDetail$.pipe(y(o=>o.map(u=>u.seriesLabels$)),B(o=>_(o).pipe(B(async u=>u))),y(o=>o.flat())),l=_({fullParams:r.fullParams$,computedData:r.computedData$}).pipe(D(a),B(async o=>o),y(o=>o.computedData.map((u,c)=>{const m=Rt(o.fullParams.gridList[c]??{},{listRectWidth:o.fullParams.listRectWidth,listRectHeight:o.fullParams.listRectHeight,listRectRadius:o.fullParams.listRectRadius});return u.map($=>m)}).flat())),n=_({fullParams:r.fullParams$,seriesList:l}).pipe(D(a),B(async o=>o),y(o=>({...o.fullParams,labelList:o.seriesList}))),t=Qt(ut,{rootSelection:i,legendLabels$:p,fullParams$:n,layout$:r.layout$,fullChartParams$:r.fullChartParams$,textSizePx$:r.textSizePx$});return()=>{a.next(void 0),t()}}),R=s=>{const i=s.fullParams$.pipe(y(r=>r.gridIndexes),I(),k(1));return _({multiGridEachDetail:s.multiGridEachDetail$,gridIndexes:i}).pipe(B(async r=>r),y(r=>r.gridIndexes==="all"?r.multiGridEachDetail:r.gridIndexes.map(e=>r.multiGridEachDetail[e]??r.multiGridEachDetail[0])))},v="MultiBars",Z=F(v,"grid"),pe={name:v,defaultParams:Mt,layerIndex:ot,validator:(s,{validateColumns:i})=>i(s,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},barWidth:{toBeTypes:["number"]},barPadding:{toBeTypes:["number"]},barGroupPadding:{toBeTypes:["number"]},barRadius:{toBeTypes:["number","boolean"]}})},Ce=C(pe)(({selection:s,name:i,subject:r,observer:e})=>{const a=new P,p=[];return R(e).pipe(D(a)).subscribe(n=>{p.forEach(t=>t()),s.selectAll(`g.${Z}`).data(n).join("g").attr("class",Z).each((t,o,u)=>{const c=S(u[o]),m=t.dataFormatter$.pipe(D(a),y($=>$.separateSeries),I(),k(1));p[o]=Zt(v,{selection:c,computedData$:t.computedData$,visibleComputedData$:t.visibleComputedData$,computedAxesData$:t.computedAxesData$,visibleComputedAxesData$:t.visibleComputedAxesData$,seriesLabels$:t.seriesLabels$,SeriesDataMap$:t.SeriesDataMap$,GroupDataMap$:t.GroupDataMap$,fullParams$:e.fullParams$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridGraphicTransform$:t.gridGraphicTransform$,gridGraphicReverseScale$:t.gridGraphicReverseScale$,gridAxesSize$:t.gridAxesSize$,gridHighlight$:e.multiGridHighlight$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:m,event$:r.event$})})}),()=>{a.next(void 0),p.forEach(n=>n())}}),W="MultiLines",tt=F(W,"grid"),ce={name:W,defaultParams:Ot,layerIndex:ot,validator:(s,{validateColumns:i})=>i(s,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},lineCurve:{toBeTypes:["string"]},lineWidth:{toBeTypes:["number"]}})},Pe=C(ce)(({selection:s,rootSelection:i,name:r,subject:e,observer:a})=>{const p=new P,l=[],n=a.multiGridContainerPosition$.pipe(D(p),y(o=>o.flat()));return R(a).pipe(D(p)).subscribe(o=>{l.forEach(u=>u()),s.selectAll(`g.${tt}`).data(o).join("g").attr("class",tt).each((u,c,m)=>{const $=S(m[c]);l[c]=te(W,{selection:$,computedData$:u.computedData$,computedAxesData$:u.computedAxesData$,visibleComputedData$:u.visibleComputedData$,visibleComputedAxesData$:u.visibleComputedAxesData$,seriesLabels$:u.seriesLabels$,SeriesDataMap$:u.SeriesDataMap$,GroupDataMap$:u.GroupDataMap$,fullDataFormatter$:u.dataFormatter$,fullParams$:a.fullParams$,fullChartParams$:a.fullChartParams$,gridAxesTransform$:u.gridAxesTransform$,gridGraphicTransform$:u.gridGraphicTransform$,gridAxesSize$:u.gridAxesSize$,gridHighlight$:a.multiGridHighlight$,gridContainerPosition$:u.gridContainerPosition$,allContainerPosition$:n,layout$:a.layout$,event$:e.event$})})}),()=>{p.next(void 0),l.forEach(o=>o())}}),X="MultiDots",et=F(X,"grid"),me={name:X,defaultParams:Et,layerIndex:_t,validator:(s,{validateColumns:i})=>i(s,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},radius:{toBeTypes:["number"]},fillColorType:{toBeOption:"ColorType"},strokeColorType:{toBeOption:"ColorType"},strokeWidth:{toBeTypes:["number"]},onlyShowHighlighted:{toBeTypes:["boolean"]}})},Ge=C(me)(({selection:s,name:i,subject:r,observer:e})=>{const a=new P,p=[];return R(e).pipe(D(a)).subscribe(n=>{p.forEach(t=>t()),s.selectAll(`g.${et}`).data(n).join("g").attr("class",et).each((t,o,u)=>{const c=S(u[o]);p[o]=ee(X,{selection:c,computedData$:t.computedData$,visibleComputedData$:t.visibleComputedData$,computedAxesData$:t.computedAxesData$,visibleComputedAxesData$:t.visibleComputedAxesData$,seriesLabels$:t.seriesLabels$,SeriesDataMap$:t.SeriesDataMap$,GroupDataMap$:t.GroupDataMap$,fullParams$:e.fullParams$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridGraphicTransform$:t.gridGraphicTransform$,gridGraphicReverseScale$:t.gridGraphicReverseScale$,gridAxesSize$:t.gridAxesSize$,gridHighlight$:e.multiGridHighlight$,gridContainerPosition$:t.gridContainerPosition$,event$:r.event$})})}),()=>{a.next(void 0),p.forEach(n=>n())}}),Y="MultiGroupAxis",at=F(Y,"grid"),de={name:Y,defaultParams:It,layerIndex:nt,validator:(s,{validateColumns:i})=>i(s,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},labelOffset:{toBe:"[number, number]",test:e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="number"&&typeof e[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBe:'number | null | "all"',test:e=>e===null||e==="all"||typeof e=="number"},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}})},Le=C(de)(({selection:s,name:i,subject:r,observer:e})=>{const a=new P,p=[];return R(e).pipe(D(a)).subscribe(n=>{p.forEach(t=>t()),s.selectAll(`g.${at}`).data(n).join("g").attr("class",at).each((t,o,u)=>{const c=S(u[o]),m=t.dataFormatter$.pipe(D(a),y($=>$.separateSeries),I(),k(1));p[o]=ae(Y,{selection:c,computedData$:t.computedData$,fullParams$:e.fullParams$,fullDataFormatter$:t.dataFormatter$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridAxesReverseTransform$:t.gridAxesReverseTransform$,gridAxesSize$:t.gridAxesSize$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:m,textSizePx$:e.textSizePx$})})}),()=>{a.next(void 0),p.forEach(n=>n())}}),q="MultiValueAxis",rt=F(q,"grid"),$e={name:q,defaultParams:kt,layerIndex:nt,validator:(s,{validateColumns:i})=>i(s,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},labelOffset:{toBe:"[number, number]",test:e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="number"&&typeof e[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBeTypes:["number","null"]},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}})},Be=C($e)(({selection:s,name:i,subject:r,observer:e})=>{const a=new P,p=[];return R(e).pipe(D(a)).subscribe(n=>{p.forEach(t=>t()),s.selectAll(`g.${rt}`).data(n).join("g").attr("class",rt).each((t,o,u)=>{const c=S(u[o]),m=t.dataFormatter$.pipe(D(a),y($=>$.separateSeries),I(),k(1));p[o]=re(q,{selection:c,computedData$:t.computedData$,filteredMinMaxValue$:t.filteredMinMaxValue$,fullParams$:e.fullParams$,fullDataFormatter$:t.dataFormatter$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridAxesReverseTransform$:t.gridAxesReverseTransform$,gridAxesSize$:t.gridAxesSize$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:m})})}),()=>{a.next(void 0),p.forEach(n=>n())}});export{Ce as M,Ge as a,xe as b,Le as c,Pe as d,Be as e,he as f,R as m};
