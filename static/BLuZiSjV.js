import{b as A,S as b,t as a,m as n,k as B,l as g,s as F,g as D,Y as C,j as L,n as k,$ as I,o as P}from"./Dqvogce1.js";import{c as O}from"./CMAIQOh1.js";import{m as h}from"./DN0wsy5H.js";import{o as G}from"./BHIvdwFR.js";const d="OverlappingValueAxes",x=D(d,"grid"),S={name:d,defaultParams:C,layerIndex:L,validator:(s,{validateColumns:l})=>{const y=l(s,{firstAxis:{toBeTypes:["object"]},secondAxis:{toBeTypes:["object"]},gridIndexes:{toBe:"[number, number]",test:i=>Array.isArray(i)&&i.length===2}});if(s.firstAxis){const i=l(s.firstAxis,{labelOffset:{toBe:"[number, number]",test:r=>Array.isArray(r)&&r.length===2&&typeof r[0]=="number"&&typeof r[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBeTypes:["number"]},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}});if(i.status==="error")return i}if(s.secondAxis){const i=l(s.secondAxis,{labelOffset:{toBe:"[number, number]",test:r=>Array.isArray(r)&&r.length===2&&typeof r[0]=="number"&&typeof r[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBeTypes:["number"]},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}});if(i.status==="error")return i}return y}},M=A(S)(({selection:s,name:l,subject:y,observer:i})=>{const r=new b,c=[],$=i.fullParams$.pipe(a(r),n(e=>e.gridIndexes[0])),T=i.fullParams$.pipe(a(r),n(e=>e.gridIndexes[1])),f=B({firstGridIndex:$,secondGridIndex:T,fullDataFormatter:i.fullDataFormatter$}).pipe(a(r),g(async e=>e),n(e=>{e.fullDataFormatter.gridList[e.secondGridIndex]||(e.fullDataFormatter.gridList[e.secondGridIndex]=Object.assign({},e.fullDataFormatter.gridList[e.firstGridIndex]));const t=e.fullDataFormatter.gridList[e.firstGridIndex].valueAxis.position;let o=t;return t==="left"?o="right":t==="bottom"?o="top":t==="top"?o="bottom":t==="right"&&(o="left"),{type:"grid",visibleFilter:e.fullDataFormatter.visibleFilter,...e.fullDataFormatter.gridList[e.secondGridIndex],valueAxis:{...e.fullDataFormatter.gridList[e.secondGridIndex].valueAxis,position:o},container:{...e.fullDataFormatter.container}}}));return G(i).pipe(a(r),n(e=>({...e,fullParams$:e.fullParams$.pipe(n(t=>(t.gridIndexes.length>2&&(t.gridIndexes.length=2),t)))})),g(e=>h(e)),n(e=>e.map((t,o)=>{if(o===0)return t;const p=k({fullDataFormatter$:f,layout$:i.layout$}),m=I({gridAxesTransform$:p}),u=P({computedData$:t.computedData$,fullDataFormatter$:f,layout$:i.layout$});return{...t,dataFormatter$:f,gridAxesTransform$:p,gridAxesReverseTransform$:m,gridContainerPosition$:u}}))).pipe(a(r)).subscribe(e=>{c.forEach(t=>t()),s.selectAll(`g.${x}`).data(e).join("g").attr("class",x).each((t,o,p)=>{if(o>1)return;const m=F(p[o]);c[o]=O(d,{selection:m,computedData$:t.computedData$,filteredMinMaxValue$:t.filteredMinMaxValue$,fullParams$:i.fullParams$.pipe(n(u=>o===0?u.firstAxis:u.secondAxis)),fullDataFormatter$:t.dataFormatter$,fullChartParams$:i.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridAxesReverseTransform$:t.gridAxesReverseTransform$,gridAxesSize$:t.gridAxesSize$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:t.isSeriesSeprate$})})}),()=>{r.next(void 0),c.forEach(e=>e())}});export{M as O};
