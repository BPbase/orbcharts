import{L as Y,M as ce,N as pe,E as ue,P as ge,B as de,Q as $e,R as se,T as le,U as H,V as Z,W as J,G as A,X as K,H as me,I as he,Y as fe,F as De,J as xe,Z as Se,S as R,e as P,t as T,s as b,m as y,d as V,c as M,x as E,$ as be}from"./Bt7wG3zu.js";import{c as Le,b as Ae,d as ye,i as Te,e as Ge,f as Pe,h as Ce,j as Me,k as Fe,l as Re,m as Ie,n as ve,a as ke}from"./8OeFB8vA.js";import{c as _e}from"./rbJIPsOw.js";import{c as Ee}from"./sLbfBDBv.js";import{e as Oe,b as Q,g as v,s as z}from"./vANVmeqg.js";import{c as Ue}from"./CVR2pviJ.js";import{a as we,c as ze}from"./CD7KWqPx.js";import{o as He}from"./uoaLhK_V.js";function Ve({context:a,gridIndex:s,transposedDataGrid:i,gridSeriesLabels:u,SeriesLabelColorMap:c}){const{data:r=[],dataFormatter:h,chartParams:l,layout:e}=a;if(!r.length)return[];const t=Ae(i,h,e),g=ge({transposedDataGrid:i,dataFormatter:h,chartType:"multiGrid",gridIndex:s}),d=ye(i,h,e),x=i.map((S,$)=>d[$](0));let o=0;return i.map((S,$)=>S.map((D,G)=>{const C=de("multiGrid",s,$,G),I=g[G],p=u[$],k=d[$],_=k(D.value??0),O=x[$],U={id:D.id?D.id:C,index:o,label:D.label?D.label:C,description:D.description??"",data:D.data,value:D.value,gridIndex:s,seriesIndex:$,seriesLabel:p,groupIndex:G,groupLabel:I,color:c.get(p),axisX:t(G),axisY:_,axisYFromZero:_-O,visible:D._visible};return o++,U}))}const je=({data:a=[],dataFormatter:s,chartParams:i,layout:u})=>{if(!a.length)return[];let c=[];try{const r=s.gridList[0]||Y,h=a.map((o,f)=>({type:"grid",grid:{...s.gridList[f]||r},container:{...s.container}})),l=a.map((o,f)=>({data:o,dataFormatter:h[f],chartParams:i,layout:u})),e=a.map((o,f)=>Le(l[f])),t=new Set(h.map(S=>S.grid.slotIndex)).size!==h.length?ce:pe,g=e.map((o,f)=>t({transposedDataGrid:o,dataFormatter:h[f],chartType:"multiGrid",gridIndex:f})),d=new Map;let x=0;g.flat().forEach((o,f)=>{if(!d.has(o)){const S=ue(x,i);d.set(o,S),x++}}),c=a.map((o,f)=>Ve({context:l[f],gridIndex:f,transposedDataGrid:e[f],gridSeriesLabels:g[f],SeriesLabelColorMap:d}))}catch(r){throw Error(r)}return c},Ne=({fullDataFormatter$:a,computedData$:s,layout$:i,fullChartParams$:u,event$:c})=>{function r({gridDataFormatter$:l,gridComputedData$:e,layout$:t,fullChartParams$:g,event$:d}){const x=Te({computedData$:e,fullDataFormatter$:l}).pipe(A(1)),o=Ge({computedData$:e,fullDataFormatter$:l,fullChartParams$:g,layout$:t}).pipe(A(1)),f=Pe({fullDataFormatter$:l,layout$:t}).pipe(A(1)),S=Ce({gridAxesTransform$:f}).pipe(A(1)),$=Me({computedData$:e,fullDataFormatter$:l,layout$:t}).pipe(A(1)),D=Fe({gridContainer$:o,gridAxesTransform$:f,gridGraphicTransform$:$}),G=Re({fullDataFormatter$:l,layout$:t}).pipe(A(1)),C=e.pipe(H(U=>U.flat())).pipe(A(1)),I=me({datumList$:C,fullChartParams$:g,event$:d}).pipe(A(1)),p=Ie({computedData$:e}),k=he({datumList$:C}).pipe(A(1)),_=fe({datumList$:C}).pipe(A(1)),O=ve({computedData$:e}).pipe(A(1));return{isSeriesPositionSeprate$:x,gridContainer$:o,gridAxesTransform$:f,gridAxesReverseTransform$:S,gridGraphicTransform$:$,gridGraphicReverseScale$:D,gridAxesSize$:G,gridHighlight$:I,existSeriesLabels$:p,SeriesDataMap$:k,GroupDataMap$:_,visibleComputedData$:O}}const h=new $e;return se({fullDataFormatter:a,computedData:s}).pipe(le(async l=>l),H(l=>{h.next(void 0);const e=l.fullDataFormatter.gridList[0]??Y;return l.computedData.map((t,g)=>{const x={type:"grid",grid:{...l.fullDataFormatter.gridList[g]??e},container:{...l.fullDataFormatter.container}},o=Z(x).pipe(J(h),A(1)),f=Z(t).pipe(J(h),A(1));return r({gridDataFormatter$:o,gridComputedData$:f,layout$:i,fullChartParams$:u,event$:c})})}))},Be=({computedData$:a,fullDataFormatter$:s,fullChartParams$:i,layout$:u})=>se({computedData:a,fullDataFormatter:s,fullChartParams:i,layout:u}).pipe(le(async r=>r),H(r=>{const h=r.fullDataFormatter.gridList[0]??Y;return r.computedData.map((e,t)=>{const g=r.fullDataFormatter.gridList[t]??h;if(!!(g.seriesSlotIndexes&&g.seriesSlotIndexes.length===e.length))return e.map((x,o)=>{const f=g.seriesSlotIndexes[o]%r.fullDataFormatter.container.columnAmount,S=Math.floor(g.seriesSlotIndexes[o]/r.fullDataFormatter.container.columnAmount),{translate:$,scale:D}=K(r.layout,r.fullDataFormatter.container,S,f);return{slotIndex:g.seriesSlotIndexes[o],rowIndex:S,columnIndex:f,translate:$,scale:D}});{const x=g.slotIndex%r.fullDataFormatter.container.columnAmount,o=Math.floor(g.slotIndex/r.fullDataFormatter.container.columnAmount);return e.map((f,S)=>{const{translate:$,scale:D}=K(r.layout,r.fullDataFormatter.container,o,x);return{slotIndex:g.slotIndex,rowIndex:o,columnIndex:x,translate:$,scale:D}})}})})),We=({subject:a,observer:s})=>{const i=De(s.fullChartParams$).pipe(A(1)),u=Ne({fullDataFormatter$:s.fullDataFormatter$,computedData$:s.computedData$,layout$:s.layout$,fullChartParams$:s.fullChartParams$,event$:a.event$}).pipe(A(1)),c=Be({computedData$:s.computedData$,fullDataFormatter$:s.fullDataFormatter$,fullChartParams$:s.fullChartParams$,layout$:s.layout$});return{fullParams$:s.fullParams$,fullChartParams$:s.fullChartParams$,fullDataFormatter$:s.fullDataFormatter$,computedData$:s.computedData$,layout$:s.layout$,textSizePx$:i,multiGridEachDetail$:u,multiGridContainer$:c}};class ut extends xe{constructor(s,i){super({defaultDataFormatter:Se,computedDataFn:je,contextObserverFn:We},s,i)}}function Xe({graphicGSelection:a,circleGClassName:s,circleClassName:i,data:u,fullParams:c,fullChartParams:r,graphicReverseScale:h}){const l=g=>{const d=g.size();return r.transitionDuration/d};let e=0;return a.each((g,d,x)=>{M(x[d]).selectAll("g").data(u[d],o=>o.id).join(o=>(e=l(o),o.append("g").classed(s,!0)),o=>o,o=>o.remove()).attr("transform",o=>`translate(${o.axisX}, ${o.axisY})`).each((o,f,S)=>{M(S[f]).selectAll("circle").data([o]).join($=>$.append("circle").style("cursor","pointer").style("vector-effect","non-scaling-stroke").classed(i,!0).attr("opacity",0).transition().delay((D,G)=>f*e).attr("opacity",1),$=>$.transition().duration(50).attr("opacity",1),$=>$.remove()).attr("r",c.radius).attr("fill",($,D)=>Q({datum:$,colorType:c.fillColorType,fullChartParams:r})).attr("stroke",($,D)=>Q({datum:$,colorType:c.strokeColorType,fullChartParams:r})).attr("stroke-width",c.strokeWidth).attr("transform",`scale(${h[d][0]??1}, ${h[d][1]??1})`)})}),a.selectAll(`circle.${i}`)}function Ye({selection:a,ids:s,onlyShowHighlighted:i,fullChartParams:u}){if(a.interrupt("highlight"),!s.length){a.transition("highlight").duration(200).style("opacity",i===!0?0:1);return}a.each((c,r,h)=>{s.includes(c.id)?M(h[r]).style("opacity",1).transition("highlight").duration(200):M(h[r]).style("opacity",i===!0?0:u.styles.unhighlightedOpacity).transition("highlight").duration(200)})}function Ze({defsSelection:a,clipPathData:s}){a.selectAll("clipPath").data(s).join(i=>i.append("clipPath"),i=>i,i=>i.remove()).attr("id",i=>i.id).each((i,u,c)=>{M(c[u]).selectAll("rect").data([i]).join("rect").attr("x",0).attr("y",0).attr("width",r=>r.width).attr("height",r=>r.height)})}const Je=(a,{selection:s,computedData$:i,visibleComputedData$:u,existSeriesLabels$:c,SeriesDataMap$:r,GroupDataMap$:h,fullParams$:l,fullChartParams$:e,gridAxesTransform$:t,gridGraphicTransform$:g,gridGraphicReverseScale$:d,gridAxesSize$:x,gridHighlight$:o,gridContainer$:f,event$:S})=>{const $=new R,D=Oe(a,"clipPath-box"),G=v(a,"circleG"),C=v(a,"circle"),I=new R,{seriesSelection$:p,axesSelection$:k,defsSelection$:_,graphicGSelection$:O}=ke({selection:s,pluginName:a,clipPathID:D,existSeriesLabels$:c,gridContainer$:f,gridAxesTransform$:t,gridGraphicTransform$:g}),U=P({computedData:i,gridGraphicReverseScale:d}).pipe(T($),b(async n=>n),y(n=>n.computedData.map((F,L)=>n.gridGraphicReverseScale[L])));P({defsSelection:_,gridAxesSize:x}).pipe(T($),b(async n=>n)).subscribe(n=>{const F=[{id:D,width:n.gridAxesSize.width,height:n.gridAxesSize.height}];Ze({defsSelection:n.defsSelection,clipPathData:F})});const oe=e.pipe(T($),y(n=>n.highlightTarget),V());P({graphicGSelection:O,computedData:i,visibleComputedData:u,SeriesDataMap:r,GroupDataMap:h,graphicReverseScale:U,fullChartParams:e,fullParams:l,highlightTarget:oe}).pipe(T($),b(async n=>n)).subscribe(n=>{const F=Xe({graphicGSelection:n.graphicGSelection,circleGClassName:G,circleClassName:C,data:n.visibleComputedData,fullParams:n.fullParams,fullChartParams:n.fullChartParams,graphicReverseScale:n.graphicReverseScale});F.on("mouseover",(L,m)=>{L.stopPropagation(),S.next({type:"grid",eventName:"mouseover",pluginName:a,highlightTarget:n.highlightTarget,datum:m,gridIndex:m.gridIndex,series:n.SeriesDataMap.get(m.seriesLabel),seriesIndex:m.seriesIndex,seriesLabel:m.seriesLabel,groups:n.GroupDataMap.get(m.groupLabel),groupIndex:m.groupIndex,groupLabel:m.groupLabel,event:L,data:n.computedData})}).on("mousemove",(L,m)=>{L.stopPropagation(),S.next({type:"grid",eventName:"mousemove",pluginName:a,highlightTarget:n.highlightTarget,data:n.computedData,datum:m,gridIndex:m.gridIndex,series:n.SeriesDataMap.get(m.seriesLabel),seriesIndex:m.seriesIndex,seriesLabel:m.seriesLabel,groups:n.GroupDataMap.get(m.groupLabel),groupIndex:m.groupIndex,groupLabel:m.groupLabel,event:L})}).on("mouseout",(L,m)=>{L.stopPropagation(),S.next({type:"grid",eventName:"mouseout",pluginName:a,highlightTarget:n.highlightTarget,datum:m,gridIndex:m.gridIndex,series:n.SeriesDataMap.get(m.seriesLabel),seriesIndex:m.seriesIndex,seriesLabel:m.seriesLabel,groups:n.GroupDataMap.get(m.groupLabel),groupIndex:m.groupIndex,groupLabel:m.groupLabel,event:L,data:n.computedData})}).on("click",(L,m)=>{L.stopPropagation(),S.next({type:"grid",eventName:"click",pluginName:a,highlightTarget:n.highlightTarget,datum:m,gridIndex:m.gridIndex,series:n.SeriesDataMap.get(m.seriesLabel),seriesIndex:m.seriesIndex,seriesLabel:m.seriesLabel,groups:n.GroupDataMap.get(m.groupLabel),groupIndex:m.groupIndex,groupLabel:m.groupLabel,event:L,data:n.computedData})}),I.next(F)});const ne=l.pipe(T($),y(n=>n.onlyShowHighlighted),V());return e.pipe(T($),b(n=>P({graphicSelection:I,highlight:o.pipe(y(F=>F.map(L=>L.id))),onlyShowHighlighted:ne,fullChartParams:e}).pipe(T($),b(async F=>F)))).subscribe(n=>{Ye({selection:n.graphicSelection,ids:n.highlight,onlyShowHighlighted:n.onlyShowHighlighted,fullChartParams:n.fullChartParams})}),()=>{$.next(void 0)}},Ke={position:"right",justify:"end",padding:28,backgroundFill:"none",backgroundStroke:"none",gap:10,listRectWidth:14,listRectHeight:14,listRectRadius:0,gridList:[{listRectWidth:14,listRectHeight:14,listRectRadius:0}],textColorType:"primary"},Qe={labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!0,axisLineColorType:"primary",tickFormat:a=>a,tickLineVisible:!0,tickPadding:20,tickFullLine:!1,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary",gridIndexes:[0]},qe={labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!1,axisLineColorType:"primary",ticks:4,tickFormat:",.0f",tickLineVisible:!0,tickPadding:20,tickFullLine:!0,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary",gridIndexes:[0]},et={barWidth:0,barPadding:1,barGroupPadding:40,barRadius:!1,gridIndexes:[0]},gt={barWidth:0,barGroupPadding:10,barRadius:!1,gridIndexes:[0]},dt={barWidth:0,barPadding:1,barGroupPadding:20,linearGradientOpacity:[1,0],gridIndexes:[0]},tt={lineCurve:"curveLinear",lineWidth:2,gridIndexes:[1]},$t={lineCurve:"curveLinear",linearGradientOpacity:[1,0],gridIndexes:[1]},rt={radius:4,fillColorType:"white",strokeColorType:"series",strokeWidth:2,onlyShowHighlighted:!1,gridIndexes:[1]},mt={firstAxis:{labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!1,axisLineColorType:"primary",ticks:4,tickFormat:",.0f",tickLineVisible:!0,tickPadding:20,tickFullLine:!0,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary"},secondAxis:{labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!1,axisLineColorType:"primary",ticks:4,tickFormat:",.0f",tickLineVisible:!0,tickPadding:20,tickFullLine:!0,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary"},gridIndexes:[0,1]},q="MultiGridLegend",ht=E(q,Ke)(({selection:a,rootSelection:s,observer:i,subject:u})=>{const c=new R,r=i.multiGridEachDetail$.pipe(T(c),y(t=>t.map((d,x)=>d.SeriesDataMap$.pipe(y(o=>Array.from(o.keys()))))),b(t=>P(t)),y(t=>t.flat())),h=P({fullParams:i.fullParams$,multiGrid:i.multiGridEachDetail$,computedData:i.computedData$}).pipe(T(c),b(async t=>t),y(t=>t.computedData.map((g,d)=>{const x=be(t.fullParams.gridList[d]??{},{listRectWidth:t.fullParams.listRectWidth,listRectHeight:t.fullParams.listRectHeight,listRectRadius:t.fullParams.listRectRadius});return g.map(o=>x)}).flat())),l=P({fullParams:i.fullParams$,seriesList:h}).pipe(T(c),b(async t=>t),y(t=>({...t.fullParams,seriesList:t.seriesList}))),e=_e(q,{rootSelection:s,seriesLabels$:r,fullParams$:l,layout$:i.layout$,fullChartParams$:i.fullChartParams$,textSizePx$:i.textSizePx$});return()=>{c.next(void 0),e()}}),w=a=>{const s=a.fullParams$.pipe(y(c=>c.gridIndexes),V(),z(1)),i=new R,u=a.multiGridEachDetail$.pipe(b(c=>P(c.map(r=>r.gridHighlight$))),y(c=>c.flat()),z(1));return s.pipe(y(c=>c.map(r=>{i.next(void 0);const h=He(r).pipe(T(i),z(1)),l=P({computedData:a.computedData$,gridIndex:h}).pipe(T(i),y(p=>p.computedData[p.gridIndex]??p.computedData[0])),e=P({fullDataFormatter:a.fullDataFormatter$,gridIndex:h}).pipe(T(i),y(p=>{const k=p.fullDataFormatter.gridList[0];return{type:"grid",grid:{...p.fullDataFormatter.gridList[p.gridIndex]??k},container:{...p.fullDataFormatter.container}}})),t=P({multiGridEachDetail:a.multiGridEachDetail$,gridIndex:h}).pipe(T(i),b(async p=>p),y(p=>p.multiGridEachDetail[p.gridIndex]??p.multiGridEachDetail[0]),z(1)),g=t.pipe(b(p=>p.isSeriesPositionSeprate$)),d=t.pipe(b(p=>p.gridContainer$)),x=t.pipe(b(p=>p.gridAxesTransform$)),o=t.pipe(b(p=>p.gridAxesReverseTransform$)),f=t.pipe(b(p=>p.gridAxesSize$)),S=t.pipe(b(p=>p.gridGraphicTransform$)),$=t.pipe(b(p=>p.gridGraphicReverseScale$)),D=t.pipe(b(p=>p.existSeriesLabels$)),G=t.pipe(b(p=>p.SeriesDataMap$)),C=t.pipe(b(p=>p.GroupDataMap$)),I=t.pipe(b(p=>p.visibleComputedData$));return{gridComputedData$:l,gridDataFormatter$:e,gridAxesTransform$:x,gridGraphicTransform$:S,gridGraphicReverseScale$:$,gridAxesReverseTransform$:o,gridAxesSize$:f,gridHighlight$:u,existSeriesLabels$:D,SeriesDataMap$:G,GroupDataMap$:C,visibleComputedData$:I,isSeriesPositionSeprate$:g,gridContainer$:d}})))},j="MultiBars",ee=v(j,"grid"),ft=E(j,et)(({selection:a,name:s,subject:i,observer:u})=>{const c=new R,r=[];return w(u).subscribe(l=>{r.forEach(e=>e()),a.selectAll(`g.${ee}`).data(l).join("g").attr("class",ee).each((e,t,g)=>{const d=M(g[t]);r[t]=Ee(j,{selection:d,computedData$:e.gridComputedData$,visibleComputedData$:e.visibleComputedData$,existSeriesLabels$:e.existSeriesLabels$,SeriesDataMap$:e.SeriesDataMap$,GroupDataMap$:e.GroupDataMap$,fullParams$:u.fullParams$,fullChartParams$:u.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridGraphicTransform$:e.gridGraphicTransform$,gridGraphicReverseScale$:e.gridGraphicReverseScale$,gridAxesSize$:e.gridAxesSize$,gridHighlight$:e.gridHighlight$,gridContainer$:e.gridContainer$,isSeriesPositionSeprate$:e.isSeriesPositionSeprate$,event$:i.event$})})}),()=>{c.next(void 0),r.forEach(l=>l())}}),N="MultiLines",te=v(N,"grid"),Dt=E(N,tt)(({selection:a,name:s,subject:i,observer:u})=>{const c=new R,r=[];return w(u).subscribe(l=>{r.forEach(e=>e()),a.selectAll(`g.${te}`).data(l).join("g").attr("class",te).each((e,t,g)=>{const d=M(g[t]);r[t]=Ue(N,{selection:d,computedData$:e.gridComputedData$,existSeriesLabels$:e.existSeriesLabels$,SeriesDataMap$:e.SeriesDataMap$,GroupDataMap$:e.GroupDataMap$,fullDataFormatter$:e.gridDataFormatter$,fullParams$:u.fullParams$,fullChartParams$:u.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridGraphicTransform$:e.gridGraphicTransform$,gridAxesSize$:e.gridAxesSize$,gridHighlight$:e.gridHighlight$,gridContainer$:e.gridContainer$,event$:i.event$})})}),()=>{c.next(void 0),r.forEach(l=>l())}}),B="MultiDots",re=v(B,"grid"),xt=E(B,rt)(({selection:a,name:s,subject:i,observer:u})=>{const c=new R,r=[];return w(u).subscribe(l=>{r.forEach(e=>e()),a.selectAll(`g.${re}`).data(l).join("g").attr("class",re).each((e,t,g)=>{const d=M(g[t]);r[t]=Je(B,{selection:d,computedData$:e.gridComputedData$,visibleComputedData$:e.visibleComputedData$,existSeriesLabels$:e.existSeriesLabels$,SeriesDataMap$:e.SeriesDataMap$,GroupDataMap$:e.GroupDataMap$,fullParams$:u.fullParams$,fullChartParams$:u.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridGraphicTransform$:e.gridGraphicTransform$,gridGraphicReverseScale$:e.gridGraphicReverseScale$,gridAxesSize$:e.gridAxesSize$,gridHighlight$:e.gridHighlight$,gridContainer$:e.gridContainer$,event$:i.event$})})}),()=>{c.next(void 0),r.forEach(l=>l())}}),W="MultiGroupAxis",ie=v(W,"grid"),St=E(W,Qe)(({selection:a,name:s,subject:i,observer:u})=>{const c=new R,r=[];return w(u).subscribe(l=>{r.forEach(e=>e()),a.selectAll(`g.${ie}`).data(l).join("g").attr("class",ie).each((e,t,g)=>{const d=M(g[t]);r[t]=we(W,{selection:d,computedData$:e.gridComputedData$,fullParams$:u.fullParams$,fullDataFormatter$:e.gridDataFormatter$,fullChartParams$:u.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridAxesReverseTransform$:e.gridAxesReverseTransform$,gridAxesSize$:e.gridAxesSize$,gridContainer$:e.gridContainer$,isSeriesPositionSeprate$:e.isSeriesPositionSeprate$})})}),()=>{c.next(void 0),r.forEach(l=>l())}}),X="MultiValueAxis",ae=v(X,"grid"),bt=E(X,qe)(({selection:a,name:s,subject:i,observer:u})=>{const c=new R,r=[];return w(u).subscribe(l=>{r.forEach(e=>e()),a.selectAll(`g.${ae}`).data(l).join("g").attr("class",ae).each((e,t,g)=>{const d=M(g[t]);r[t]=ze(X,{selection:d,computedData$:e.gridComputedData$,fullParams$:u.fullParams$,fullDataFormatter$:e.gridDataFormatter$,fullChartParams$:u.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridAxesReverseTransform$:e.gridAxesReverseTransform$,gridAxesSize$:e.gridAxesSize$,gridContainer$:e.gridContainer$,isSeriesPositionSeprate$:e.isSeriesPositionSeprate$})})}),()=>{c.next(void 0),r.forEach(l=>l())}}),Lt=[[[1205,850,930,1111,1500],[735,900,880,1035,1120]],[[55,60,50,70,75],[35,40,45,65,80]]];export{gt as D,ut as M,dt as a,$t as b,Je as c,St as d,bt as e,ft as f,ht as g,Lt as h,Dt as i,xt as j,mt as k,w as m};
