import{t as A,S as b,d as a,m as n,o as B,p as g,s as F,R as D,n as C,q as L,r as k,u as I}from"./BmSCDJil.js";import{c as P}from"./DAHtLQSG.js";import{m as O}from"./C0wMTR4G.js";import{g as h}from"./DQaJP6Gt.js";import{o as G}from"./9NWDRSWC.js";const d="OverlappingValueAxes",x=h(d,"grid"),S={name:d,defaultParams:D,layerIndex:C,validator:(s,{validateColumns:l})=>{const y=l(s,{firstAxis:{toBeTypes:["object"]},secondAxis:{toBeTypes:["object"]},gridIndexes:{toBe:"[number, number]",test:r=>Array.isArray(r)&&r.length===2}});if(s.firstAxis){const r=l(s.firstAxis,{labelOffset:{toBe:"[number, number]",test:i=>Array.isArray(i)&&i.length===2&&typeof i[0]=="number"&&typeof i[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBeTypes:["number"]},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}});if(r.status==="error")return r}if(s.secondAxis){const r=l(s.secondAxis,{labelOffset:{toBe:"[number, number]",test:i=>Array.isArray(i)&&i.length===2&&typeof i[0]=="number"&&typeof i[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBeTypes:["number"]},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}});if(r.status==="error")return r}return y}},U=A(S)(({selection:s,name:l,subject:y,observer:r})=>{const i=new b,c=[],T=r.fullParams$.pipe(a(i),n(e=>e.gridIndexes[0])),$=r.fullParams$.pipe(a(i),n(e=>e.gridIndexes[1])),m=B({firstGridIndex:T,secondGridIndex:$,fullDataFormatter:r.fullDataFormatter$}).pipe(a(i),g(async e=>e),n(e=>{e.fullDataFormatter.gridList[e.secondGridIndex]||(e.fullDataFormatter.gridList[e.secondGridIndex]=Object.assign({},e.fullDataFormatter.gridList[e.firstGridIndex]));const t=e.fullDataFormatter.gridList[e.firstGridIndex].valueAxis.position;let o=t;return t==="left"?o="right":t==="bottom"?o="top":t==="top"?o="bottom":t==="right"&&(o="left"),{type:"grid",visibleFilter:e.fullDataFormatter.visibleFilter,grid:{...e.fullDataFormatter.gridList[e.secondGridIndex],valueAxis:{...e.fullDataFormatter.gridList[e.secondGridIndex].valueAxis,position:o}},container:{...e.fullDataFormatter.container}}}));return G(r).pipe(a(i),n(e=>({...e,fullParams$:e.fullParams$.pipe(n(t=>(t.gridIndexes.length>2&&(t.gridIndexes.length=2),t)))})),g(e=>O(e)),n(e=>e.map((t,o)=>{if(o===0)return t;const p=L({fullDataFormatter$:m,layout$:r.layout$}),f=k({gridAxesTransform$:p}),u=I({computedData$:t.computedData$,fullDataFormatter$:m,layout$:r.layout$});return{...t,dataFormatter$:m,gridAxesTransform$:p,gridAxesReverseTransform$:f,gridContainerPosition$:u}}))).pipe(a(i)).subscribe(e=>{c.forEach(t=>t()),s.selectAll(`g.${x}`).data(e).join("g").attr("class",x).each((t,o,p)=>{if(o>1)return;const f=F(p[o]);c[o]=P(d,{selection:f,computedData$:t.computedData$,fullParams$:r.fullParams$.pipe(n(u=>o===0?u.firstAxis:u.secondAxis)),fullDataFormatter$:t.dataFormatter$,fullChartParams$:r.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridAxesReverseTransform$:t.gridAxesReverseTransform$,gridAxesSize$:t.gridAxesSize$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:t.isSeriesSeprate$})})}),()=>{i.next(void 0),c.forEach(e=>e())}});export{U as O};
