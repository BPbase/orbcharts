import{ag as dt,ah as $t,ai as G,aj as m,ak as rt,al as it,am as w,an as j,ao as g,ap as gt,aq as ft,ar as bt,as as yt,at as h,au as Dt,av as Tt,aw as At,ax as ht,ay as Lt,az as Ct,A as xt,aA as Pt,d as L,S as C,t as b,m as y,l as v,k as _,P as Gt,aB as Bt,aC as St,b as E,c as I,s as B,N as Ft,L as st,T as Rt,O as Mt,v as Ot,R as _t,j as ot,i as Et}from"./Dh2HIxf9.js";import{g as It,a as kt,b as Ut,c as Nt,d as zt,e as Vt,f as jt,h as vt,i as wt,j as Ht,k as Wt,l as Xt,m as Yt}from"./BqHtTwBw.js";import{c as qt}from"./E19rGNXz.js";import{c as Jt}from"./B2qvV4JZ.js";import{g as S}from"./2zdWaanV.js";import{c as Kt}from"./8z5i525a.js";import{c as Qt}from"./CYPt39Eq.js";import{a as Zt,c as te}from"./vPaWCS1v.js";const ee=({fullDataFormatter$:o,computedData$:i,layout$:r,fullChartParams$:e,event$:a})=>{const s=new dt,d=$t({datumList$:i.pipe(G(t=>t.flat().flat()),m(1)),fullChartParams$:e,event$:a}).pipe(m(1)),l=nt({computedData$:i,fullDataFormatter$:o,layout$:r}).pipe(m(1));return rt({fullDataFormatter:o,computedData:i,multiGridContainer:l}).pipe(it(async t=>t),G(t=>{s.next(void 0);const n=t.fullDataFormatter.gridList[0]??w;return t.computedData.map((u,p)=>{const c=t.fullDataFormatter.gridList[p]??n,$={type:"grid",visibleFilter:t.fullDataFormatter.visibleFilter,grid:{...c},container:{...t.fullDataFormatter.container}},D=j($).pipe(g(s),m(1)),f=j(u).pipe(g(s),m(1)),k=D.pipe(G(V=>V.grid.separateSeries),gt(),m(1)),R=j(t.multiGridContainer[p]).pipe(g(s),m(1)),x=It({fullDataFormatter$:D,layout$:r}).pipe(g(s),m(1)),T=f.pipe(G(V=>V.flat())).pipe(g(s),m(1)),P=kt({computedData$:f}).pipe(g(s),m(1)),M=ft({datumList$:T}).pipe(g(s),m(1)),U=bt({datumList$:T}).pipe(g(s),m(1)),O=Ut({computedData$:f}).pipe(g(s),m(1)),A=Nt({computedData$:f,fullDataFormatter$:D,layout$:r}).pipe(g(s),m(1)),ut=zt({computedLayoutData$:A}).pipe(g(s),m(1)),pt=Vt({computedData$:f,isSeriesSeprate$:k}).pipe(m(1)),N=jt({computedData$:f,fullDataFormatter$:D}).pipe(g(s),m(1)),J=vt({computedData$:f,groupScaleDomainValue$:N}).pipe(g(s),m(1)),z=wt({fullDataFormatter$:D,layout$:r}).pipe(g(s),m(1)),ct=Ht({gridAxesTransform$:z}).pipe(g(s),m(1)),K=Wt({computedData$:f,groupScaleDomainValue$:N,filteredMinMaxValue$:J,fullDataFormatter$:D,layout$:r}).pipe(g(s),m(1)),mt=Xt({gridContainerPosition$:R,gridAxesTransform$:z,gridGraphicTransform$:K});return{isSeriesSeprate$:k,gridContainerPosition$:R,gridAxesSize$:x,gridHighlight$:d,seriesLabels$:P,SeriesDataMap$:M,GroupDataMap$:U,dataFormatter$:D,computedData$:f,computedLayoutData$:A,visibleComputedData$:O,visibleComputedLayoutData$:ut,computedStackedData$:pt,groupScaleDomainValue$:N,filteredMinMaxValue$:J,gridAxesTransform$:z,gridAxesReverseTransform$:ct,gridGraphicTransform$:K,gridGraphicReverseScale$:mt}})}))},nt=({computedData$:o,fullDataFormatter$:i,layout$:r})=>rt({computedData:o,fullDataFormatter:i,layout:r}).pipe(it(async e=>e),G(e=>{const a=e.fullDataFormatter.gridList[0]??w,s=e.computedData.reduce((n,u,p)=>{const $=(e.fullDataFormatter.gridList[p]??a).separateSeries?u.length:e.fullDataFormatter.separateGrid?1:0;return n+$},0)||1,d=yt(e.layout,e.fullDataFormatter.container,s);let l=0;return e.computedData.map((n,u)=>{const p=e.fullDataFormatter.gridList[u]??a,c=n.map(($,D)=>{const f=d[l];return p.separateSeries&&(l+=1),f});return!p.separateSeries&&e.fullDataFormatter.separateGrid&&(l+=1),c})})),ae=o=>{const i=h(o,{visibleFilter:{toBeTypes:["Function"]},gridList:{toBeTypes:["object[]"]},container:{toBeTypes:["object"]},separateGrid:{toBeTypes:["boolean"]}});if(o.gridList){const e=o.gridList.map((a,s)=>{const d=h(a,{seriesDirection:{toBe:'"row" | "column"',test:l=>l==="row"||l==="column"},rowLabels:{toBeTypes:["string[]"]},columnLabels:{toBeTypes:["string[]"]},valueAxis:{toBeTypes:["object"]},groupAxis:{toBeTypes:["object"]},separateSeries:{toBeTypes:["boolean"]}});if(d.status==="error")return d;if(a.valueAxis){const l=h(a.valueAxis,{position:{toBe:'"top" | "bottom" | "left" | "right"',test:t=>t==="top"||t==="bottom"||t==="left"||t==="right"},scaleDomain:{toBe:'[number | "min" | "auto", number | "max" | "auto"]',test:t=>Array.isArray(t)&&t.length===2&&(typeof t[0]=="number"||t[0]==="min"||t[0]==="auto")&&(typeof t[1]=="number"||t[1]==="max"||t[1]==="auto")},scaleRange:{toBe:"[number, number]",test:t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&typeof t[1]=="number"},label:{toBeTypes:["string"]}});if(l.status==="error")return l}else if(a.groupAxis){const l=h(a.groupAxis,{position:{toBe:'"top" | "bottom" | "left" | "right"',test:t=>t==="top"||t==="bottom"||t==="left"||t==="right"},scaleDomain:{toBe:'[number, number | "max"]',test:t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&(typeof t[1]=="number"||t[1]==="max")},scalePadding:{toBeTypes:["number"]},label:{toBeTypes:["string"]}});if(l.status==="error")return l}return{status:"success",columnName:"",expectToBe:""}}).find(a=>a.status==="error");if(e)return e}if(o.container){const r=h(o.container,{gap:{toBeTypes:["number"]},rowAmount:{toBeTypes:["number"]},columnAmount:{toBeTypes:["number"]}});if(r.status==="error")return r}return i},re=o=>{const{data:i=[],dataFormatter:r,chartParams:e}=o;if(!i.length)return[];let a=[];try{const s=r.gridList[0]||w,d=i.map((p,c)=>r.gridList[c]||s),l=i.map((p,c)=>Yt(p,d[c])),t=r.separateGrid?l.map((p,c)=>Dt({transposedDataGrid:p,dataFormatterGrid:d[c],chartType:"multiGrid"})):l.map((p,c)=>Tt({transposedDataGrid:p,dataFormatterGrid:d[c],chartType:"multiGrid",gridIndex:c})),n=new Map;let u=0;t.flat().forEach((p,c)=>{if(!n.has(p)){const $=At(u,e);n.set(p,$),u++}}),a=l.map((p,c)=>{const $=t[c],D=ht({transposedDataGrid:p,dataFormatterGrid:d[c],chartType:"multiGrid",gridIndex:c});let f=0;return p.map((R,x)=>R.map((T,P)=>{const M=Lt("multiGrid",c,x,P),U=D[P],O=$[x],A={id:T.id?T.id:M,index:f,label:T.label?T.label:M,description:T.description??"",data:T.data,value:T.value,gridIndex:c,seriesIndex:x,seriesLabel:O,groupIndex:P,groupLabel:U,color:n.get(O),visible:!0};return A.visible=r.visibleFilter(A,o),f++,A}))})}catch(s){throw Error(s)}return a},ie=o=>h({data:o},{data:{toBe:"DataGrid[]",test:r=>Array.isArray(r)}}),se=({subject:o,observer:i})=>{const r=Ct(i.fullChartParams$).pipe(m(1)),e=ee({fullDataFormatter$:i.fullDataFormatter$,computedData$:i.computedData$,layout$:i.layout$,fullChartParams$:i.fullChartParams$,event$:o.event$}).pipe(m(1)),a=nt({computedData$:i.computedData$,fullDataFormatter$:i.fullDataFormatter$,layout$:i.layout$});return{fullParams$:i.fullParams$,fullChartParams$:i.fullChartParams$,fullDataFormatter$:i.fullDataFormatter$,computedData$:i.computedData$,layout$:i.layout$,textSizePx$:r,multiGridContainerPosition$:a,multiGridEachDetail$:e}};class Te extends xt{constructor(i,r){super({defaultDataFormatter:Pt,dataFormatterValidator:ae,computedDataFn:re,dataValidator:ie,contextObserverCallback:se},i,r)}}const lt="MultiGridLegend",oe={name:lt,defaultParams:Gt,layerIndex:Bt,validator:(o,{validateColumns:i})=>{const r=i(o,{placement:{toBe:'"top" | "top-start" | "top-end" | "bottom" | "bottom-start" | "bottom-end" | "left" | "left-start" | "left-end" | "right" | "right-start" | "right-end"',test:e=>["top","top-start","top-end","bottom","bottom-start","bottom-end","left","left-start","left-end","right","right-start","right-end"].includes(e)},padding:{toBeTypes:["number"]},backgroundFill:{toBeOption:"ColorType"},backgroundStroke:{toBeOption:"ColorType"},gap:{toBeTypes:["number"]},listRectWidth:{toBeTypes:["number"]},listRectHeight:{toBeTypes:["number"]},listRectRadius:{toBeTypes:["number"]},gridList:{toBeTypes:["object[]"]},textColorType:{toBeOption:"ColorType"}});if(o.gridList){const a=o.gridList.map((s,d)=>i(s,{listRectWidth:{toBeTypes:["number"]},listRectHeight:{toBeTypes:["number"]},listRectRadius:{toBeTypes:["number"]}})).find(s=>s.status==="error");if(a)return a}return r}},Ae=L(oe)(({selection:o,rootSelection:i,observer:r,subject:e})=>{const a=new C,s=r.multiGridEachDetail$.pipe(b(a),y(n=>n.map((p,c)=>p.SeriesDataMap$.pipe(y($=>Array.from($.keys()))))),v(n=>_(n)),y(n=>n.flat())),d=_({fullParams:r.fullParams$,computedData:r.computedData$}).pipe(b(a),v(async n=>n),y(n=>n.computedData.map((u,p)=>{const c=St(n.fullParams.gridList[p]??{},{listRectWidth:n.fullParams.listRectWidth,listRectHeight:n.fullParams.listRectHeight,listRectRadius:n.fullParams.listRectRadius});return u.map($=>c)}).flat())),l=_({fullParams:r.fullParams$,seriesList:d}).pipe(b(a),v(async n=>n),y(n=>({...n.fullParams,labelList:n.seriesList}))),t=qt(lt,{rootSelection:i,legendLabels$:s,fullParams$:l,layout$:r.layout$,fullChartParams$:r.fullChartParams$,textSizePx$:r.textSizePx$});return()=>{a.next(void 0),t()}}),F=o=>{const i=o.fullParams$.pipe(y(r=>r.gridIndexes),E(),I(1));return _({multiGridEachDetail:o.multiGridEachDetail$,gridIndexes:i}).pipe(y(r=>r.gridIndexes==="all"?r.multiGridEachDetail:r.gridIndexes.map(e=>r.multiGridEachDetail[e]??r.multiGridEachDetail[0])))},H="MultiBars",Q=S(H,"grid"),ne={name:H,defaultParams:Ft,layerIndex:st,validator:(o,{validateColumns:i})=>i(o,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},barWidth:{toBeTypes:["number"]},barPadding:{toBeTypes:["number"]},barGroupPadding:{toBeTypes:["number"]},barRadius:{toBeTypes:["number","boolean"]}})},he=L(ne)(({selection:o,name:i,subject:r,observer:e})=>{const a=new C,s=[];return F(e).pipe(b(a)).subscribe(l=>{s.forEach(t=>t()),o.selectAll(`g.${Q}`).data(l).join("g").attr("class",Q).each((t,n,u)=>{const p=B(u[n]),c=t.dataFormatter$.pipe(b(a),y($=>$.grid.separateSeries),E(),I(1));s[n]=Jt(H,{selection:p,computedData$:t.computedData$,visibleComputedData$:t.visibleComputedData$,computedLayoutData$:t.computedLayoutData$,visibleComputedLayoutData$:t.visibleComputedLayoutData$,seriesLabels$:t.seriesLabels$,SeriesDataMap$:t.SeriesDataMap$,GroupDataMap$:t.GroupDataMap$,fullParams$:e.fullParams$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridGraphicTransform$:t.gridGraphicTransform$,gridGraphicReverseScale$:t.gridGraphicReverseScale$,gridAxesSize$:t.gridAxesSize$,gridHighlight$:t.gridHighlight$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:c,event$:r.event$})})}),()=>{a.next(void 0),s.forEach(l=>l())}}),W="MultiLines",Z=S(W,"grid"),le={name:W,defaultParams:Rt,layerIndex:st,validator:(o,{validateColumns:i})=>i(o,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},lineCurve:{toBeTypes:["string"]},lineWidth:{toBeTypes:["number"]}})},Le=L(le)(({selection:o,rootSelection:i,name:r,subject:e,observer:a})=>{const s=new C,d=[],l=a.multiGridContainerPosition$.pipe(b(s),y(n=>n.flat()));return F(a).pipe(b(s)).subscribe(n=>{d.forEach(u=>u()),o.selectAll(`g.${Z}`).data(n).join("g").attr("class",Z).each((u,p,c)=>{const $=B(c[p]);d[p]=Kt(W,{selection:$,computedData$:u.computedData$,computedLayoutData$:u.computedLayoutData$,visibleComputedData$:u.visibleComputedData$,visibleComputedLayoutData$:u.visibleComputedLayoutData$,seriesLabels$:u.seriesLabels$,SeriesDataMap$:u.SeriesDataMap$,GroupDataMap$:u.GroupDataMap$,fullDataFormatter$:u.dataFormatter$,fullParams$:a.fullParams$,fullChartParams$:a.fullChartParams$,gridAxesTransform$:u.gridAxesTransform$,gridGraphicTransform$:u.gridGraphicTransform$,gridAxesSize$:u.gridAxesSize$,gridHighlight$:u.gridHighlight$,gridContainerPosition$:u.gridContainerPosition$,allContainerPosition$:l,layout$:a.layout$,event$:e.event$})})}),()=>{s.next(void 0),d.forEach(n=>n())}}),X="MultiDots",tt=S(X,"grid"),ue={name:X,defaultParams:Mt,layerIndex:Ot,validator:(o,{validateColumns:i})=>i(o,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},radius:{toBeTypes:["number"]},fillColorType:{toBeOption:"ColorType"},strokeColorType:{toBeOption:"ColorType"},strokeWidth:{toBeTypes:["number"]},onlyShowHighlighted:{toBeTypes:["boolean"]}})},Ce=L(ue)(({selection:o,name:i,subject:r,observer:e})=>{const a=new C,s=[];return F(e).pipe(b(a)).subscribe(l=>{s.forEach(t=>t()),o.selectAll(`g.${tt}`).data(l).join("g").attr("class",tt).each((t,n,u)=>{const p=B(u[n]);s[n]=Qt(X,{selection:p,computedData$:t.computedData$,visibleComputedData$:t.visibleComputedData$,computedLayoutData$:t.computedLayoutData$,visibleComputedLayoutData$:t.visibleComputedLayoutData$,seriesLabels$:t.seriesLabels$,SeriesDataMap$:t.SeriesDataMap$,GroupDataMap$:t.GroupDataMap$,fullParams$:e.fullParams$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridGraphicTransform$:t.gridGraphicTransform$,gridGraphicReverseScale$:t.gridGraphicReverseScale$,gridAxesSize$:t.gridAxesSize$,gridHighlight$:t.gridHighlight$,gridContainerPosition$:t.gridContainerPosition$,event$:r.event$})})}),()=>{a.next(void 0),s.forEach(l=>l())}}),Y="MultiGroupAxis",et=S(Y,"grid"),pe={name:Y,defaultParams:_t,layerIndex:ot,validator:(o,{validateColumns:i})=>i(o,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},labelOffset:{toBe:"[number, number]",test:e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="number"&&typeof e[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBe:'number | null | "all"',test:e=>e===null||e==="all"||typeof e=="number"},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}})},xe=L(pe)(({selection:o,name:i,subject:r,observer:e})=>{const a=new C,s=[];return F(e).pipe(b(a)).subscribe(l=>{s.forEach(t=>t()),o.selectAll(`g.${et}`).data(l).join("g").attr("class",et).each((t,n,u)=>{const p=B(u[n]),c=t.dataFormatter$.pipe(b(a),y($=>$.grid.separateSeries),E(),I(1));s[n]=Zt(Y,{selection:p,computedData$:t.computedData$,fullParams$:e.fullParams$,fullDataFormatter$:t.dataFormatter$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridAxesReverseTransform$:t.gridAxesReverseTransform$,gridAxesSize$:t.gridAxesSize$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:c,textSizePx$:e.textSizePx$})})}),()=>{a.next(void 0),s.forEach(l=>l())}}),q="MultiValueAxis",at=S(q,"grid"),ce={name:q,defaultParams:Et,layerIndex:ot,validator:(o,{validateColumns:i})=>i(o,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},labelOffset:{toBe:"[number, number]",test:e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="number"&&typeof e[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBeTypes:["number","null"]},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}})},Pe=L(ce)(({selection:o,name:i,subject:r,observer:e})=>{const a=new C,s=[];return F(e).pipe(b(a)).subscribe(l=>{s.forEach(t=>t()),o.selectAll(`g.${at}`).data(l).join("g").attr("class",at).each((t,n,u)=>{const p=B(u[n]),c=t.dataFormatter$.pipe(b(a),y($=>$.grid.separateSeries),E(),I(1));s[n]=te(q,{selection:p,computedData$:t.computedData$,filteredMinMaxValue$:t.filteredMinMaxValue$,fullParams$:e.fullParams$,fullDataFormatter$:t.dataFormatter$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridAxesReverseTransform$:t.gridAxesReverseTransform$,gridAxesSize$:t.gridAxesSize$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:c})})}),()=>{a.next(void 0),s.forEach(l=>l())}});export{he as M,Ce as a,Ae as b,xe as c,Le as d,Pe as e,Te as f,F as m};
