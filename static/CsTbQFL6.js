import{ar as f,ax as F,b5 as P,av as g,aC as p,aF as C,aA as b,aB as d,b6 as S,aJ as v,az as l,aL as L,aG as O,aM as T,b7 as A}from"./Cc0KHcL0.js";const B=s=>{const e=f(s,{visibleFilter:{toBeTypes:["Function"]},sort:{toBeTypes:["Function","null"]},seriesLabels:{toBeTypes:["string[]"]},container:{toBeTypes:["object"]},separateSeries:{toBeTypes:["boolean"]},sumSeries:{toBeTypes:["boolean"]}});if(s.container){const a=f(s.container,{gap:{toBeTypes:["number"]},rowAmount:{toBeTypes:["number"]},columnAmount:{toBeTypes:["number"]}});if(a.status==="error")return a}return e},M=s=>{const{data:e=[],dataFormatter:a,chartParams:o}=s;if(!e.length)return[];let r=[];try{const n=(t,i,m,u)=>{const c=F(a.type,i,m),$=a.seriesLabels[i]||P("series",i),D=g(i,o);return typeof t=="number"?{id:c,index:u,seq:0,label:c,description:"",data:{},value:t,seriesIndex:i,seriesLabel:$,color:D,visible:!0}:{id:t.id?t.id:c,index:u,seq:0,label:t.label?t.label:c,description:t.description,data:t.data??{},value:t.value,seriesIndex:i,seriesLabel:$,color:D,visible:!0}};r=e.map((t,i)=>Array.isArray(t)?t.map((m,u)=>n(m,i,u,r.length+u)):n(t,i,0,r.length)).flat().sort(a.sort??void 0).map((t,i)=>(t.seq=i,t)).map(t=>(t.visible=a.visibleFilter(t,s),t)).sort((t,i)=>t.index-i.index).reduce((t,i)=>(t[i.seriesIndex]||(t[i.seriesIndex]=[]),t[i.seriesIndex].push(i),t),[])}catch(n){throw Error(n)}return r},q=s=>f({data:s},{data:{toBe:"(DataSeriesDatum | DataSeriesValue)[][] | (DataSeriesDatum | DataSeriesValue)[]",test:a=>Array.isArray(a)}}),x=({fullDataFormatter$:s})=>s.pipe(p(e=>e.separateSeries),C()),w=({computedData$:s})=>s.pipe(p(e=>e.filter(a=>a.length).map(a=>a[0].seriesLabel)),C((e,a)=>JSON.stringify(e).length===JSON.stringify(a).length)),y=({computedData$:s})=>s.pipe(p(e=>e.map(a=>a.filter(o=>o.visible!=!1)))),E=({computedData$:s,fullDataFormatter$:e})=>b({computedData:s,fullDataFormatter:e}).pipe(d(async a=>a),p(a=>{const o=a.fullDataFormatter.sumSeries==!0?a.computedData.map(r=>[r.reduce((n,t)=>n==null?t:(n.value=n.value+t.value,n),null)]):a.computedData;return a.fullDataFormatter.separateSeries==!0?o.map(r=>r.sort((n,t)=>n.seq-t.seq)):[o.flat().sort((r,n)=>r.seq-n.seq)]})),R=({computedData$:s,fullDataFormatter$:e,layout$:a})=>b({computedData:s,fullDataFormatter:e,layout:a}).pipe(d(async r=>r),p(r=>r.fullDataFormatter.separateSeries?S(r.layout,r.fullDataFormatter.container,r.computedData.length):S(r.layout,r.fullDataFormatter.container,1))),V=({seriesContainerPosition$:s,seriesLabels$:e,separateSeries$:a})=>b({seriesContainerPosition:s,seriesLabels:e,separateSeries:a}).pipe(d(async o=>o),p(o=>o.separateSeries?new Map(o.seriesLabels.map((r,n)=>[r,o.seriesContainerPosition[n]??o.seriesContainerPosition[0]])):new Map(o.seriesLabels.map((r,n)=>[r,o.seriesContainerPosition[0]])))),z=({subject:s,observer:e})=>{const a=v(e.fullChartParams$).pipe(l(1)),o=x({fullDataFormatter$:e.fullDataFormatter$}).pipe(l(1)),r=y({computedData$:e.computedData$}).pipe(l(1)),n=E({computedData$:e.computedData$,fullDataFormatter$:e.fullDataFormatter$}).pipe(l(1)),t=y({computedData$:n}).pipe(l(1)),i=e.computedData$.pipe(p(h=>h.flat())).pipe(l(1)),m=L({datumList$:i,fullChartParams$:e.fullChartParams$,event$:s.event$}).pipe(l(1)),u=w({computedData$:e.computedData$}).pipe(l(1)),c=O({datumList$:i}).pipe(l(1)),$=R({computedData$:e.computedData$,fullDataFormatter$:e.fullDataFormatter$,layout$:e.layout$}).pipe(l(1)),D=V({seriesContainerPosition$:$,seriesLabels$:u,separateSeries$:o}).pipe(l(1));return{fullParams$:e.fullParams$,fullChartParams$:e.fullChartParams$,fullDataFormatter$:e.fullDataFormatter$,computedData$:e.computedData$,layout$:e.layout$,textSizePx$:a,visibleComputedData$:r,visibleComputedSortedData$:t,separateSeries$:o,computedSortedData$:n,seriesHighlight$:m,seriesLabels$:u,SeriesDataMap$:c,seriesContainerPosition$:$,SeriesContainerPositionMap$:D}};class _ extends T{constructor(e,a){super({defaultDataFormatter:A,dataFormatterValidator:B,computedDataFn:M,dataValidator:q,contextObserverCallback:z},e,a)}}export{_ as S};
