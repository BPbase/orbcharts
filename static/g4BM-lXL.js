import{S as W,e as x,d as B,t as a,s as u,m as y,c as _,O as Y,l as H,a1 as J}from"./DNpuBO6_.js";import{c as L,k as K,p as q,g as M,n as Q,o as Z}from"./D8yrUiOY.js";const X=6;function N({selection:g,xAxisClassName:b,groupingLabelClassName:d,params:s,tickTextAlign:c,axisLabelAlign:k,gridAxesSize:T,fullDataFormatter:z,chartParams:o,groupScale:D,textTransform:v}){const r=g.selectAll(`g.${b}`).data([s]).join("g").classed(b,!0);g.selectAll(`g.${d}`).data([s]).join("g").classed(d,!0).each((A,F,R)=>{_(R[F]).selectAll("text").data([A]).join(l=>l.append("text").style("font-weight","bold"),l=>l,l=>l.remove()).attr("text-anchor",k.textAnchor).attr("dominant-baseline",k.dominantBaseline).style("font-size",`${o.styles.textSize}px`).style("fill",L(s.labelColorType,o)).style("transform",v).text(l=>z.grid.groupAxis.label)}).attr("transform",A=>`translate(${T.width+A.tickPadding+s.labelOffset[0]}, ${-A.tickPadding-X-s.labelOffset[1]})`);const h=K(D).scale(D).tickSize(s.tickFullLine==!0?-T.height:X).tickSizeOuter(0).tickFormat(A=>q(A,s.tickFormat)).tickPadding(s.tickPadding),p=r.transition().duration(100).call(h);return p.selectAll("line").style("fill","none").style("stroke",s.tickLineVisible==!0?L(s.tickColorType,o):"none").style("stroke-dasharray",s.tickFullLineDasharray).attr("pointer-events","none"),p.selectAll("path").style("fill","none").style("stroke",s.axisLineVisible==!0?L(s.axisLineColorType,o):"none").style("shape-rendering","crispEdges"),r.selectAll("text").style("font-family","sans-serif").style("font-size",`${o.styles.textSize}px`).style("color",L(s.tickTextColorType,o)).attr("text-anchor",c.textAnchor).attr("dominant-baseline",c.dominantBaseline).attr("transform-origin",`0 -${s.tickPadding+X}`).style("transform",v),r}const se=(g,{selection:b,computedData$:d,fullParams$:s,fullDataFormatter$:c,fullChartParams$:k,gridAxesTransform$:T,gridAxesReverseTransform$:z,gridAxesSize$:o,gridContainer$:D,isSeriesPositionSeprate$:v})=>{const r=new W,h=M(g,"container"),p=M(g,"xAxisG"),A=M(g,"xAxis"),F=M(g,"groupingLabel"),R=x({computedData:d.pipe(B((t,e)=>t.length===e.length)),isSeriesPositionSeprate:v}).pipe(a(r),u(async t=>t),y(t=>t.isSeriesPositionSeprate?t.computedData:[t.computedData[0]]),y((t,e)=>b.selectAll(`g.${h}`).data(t,i=>i[0]?i[0].seriesIndex:e).join("g").classed(h,!0))),l=R.pipe(a(r),y((t,e)=>t.selectAll(`g.${p}`).data([p]).join("g").classed(p,!0)));x({containerSelection:R,gridContainer:D}).pipe(a(r),u(async t=>t)).subscribe(t=>{t.containerSelection.attr("transform",(e,i)=>{const n=t.gridContainer[i]??t.gridContainer[0],f=n.translate,m=n.scale;return`translate(${f[0]}, ${f[1]}) scale(${m[0]}, ${m[1]})`})}),x({axisSelection:l,gridAxesTransform:T}).pipe(a(r),u(async t=>t)).subscribe(t=>{t.axisSelection.style("transform",t.gridAxesTransform.value)});const P=x({fullParams:s,fullDataFormatter:c,gridAxesReverseTransform:z,gridContainer:D}).pipe(a(r),u(async t=>t),y(t=>{const e=`translate(${t.gridAxesReverseTransform.translate[0]}px, ${t.gridAxesReverseTransform.translate[1]}px)`,i=`rotate(${t.gridAxesReverseTransform.rotate}deg) rotateX(${t.gridAxesReverseTransform.rotateX}deg) rotateY(${t.gridAxesReverseTransform.rotateY}deg)`,n=`scale(${1/t.gridContainer[0].scale[0]}, ${1/t.gridContainer[0].scale[1]})`,m=`rotate(${t.fullDataFormatter.grid.groupAxis.position==="left"&&t.fullDataFormatter.grid.valueAxis.position==="top"||t.fullDataFormatter.grid.groupAxis.position==="right"&&t.fullDataFormatter.grid.valueAxis.position==="bottom"?t.fullParams.tickTextRotate+180:t.fullParams.tickTextRotate}deg)`;return`${e} ${i} ${n} ${m}`}),B()),V=new Y(t=>{x({fullDataFormatter:c,gridAxesSize:o,computedData:d}).pipe(a(r),u(async e=>e)).subscribe(e=>{const n=e.computedData[0]?e.computedData[0].length-1:0,f=e.fullDataFormatter.grid.groupAxis.scaleDomain[0]==="auto"?0-e.fullDataFormatter.grid.groupAxis.scalePadding:e.fullDataFormatter.grid.groupAxis.scaleDomain[0]-e.fullDataFormatter.grid.groupAxis.scalePadding,m=e.fullDataFormatter.grid.groupAxis.scaleDomain[1]==="auto"?n+e.fullDataFormatter.grid.groupAxis.scalePadding:e.fullDataFormatter.grid.groupAxis.scaleDomain[1]+e.fullDataFormatter.grid.groupAxis.scalePadding,C=e.computedData[0]?e.computedData[0].length:0;let w=(e.computedData[0]??[]).map(j=>j.groupLabel);const G=new Array(C).fill(0).map((j,$)=>w[$]!=null?w[$]:String($)).filter((j,$)=>$>=f&&$<=m),E=e.fullDataFormatter.grid.groupAxis.scalePadding,I=H({axisLabels:G,axisWidth:e.gridAxesSize.width,padding:E});t.next(I)})}),S=x({fullDataFormatter:c,fullParams:s}).pipe(a(r),u(async t=>t),y(t=>{let e="middle",i="hanging";return t.fullDataFormatter.grid.groupAxis.position==="bottom"?(e=t.fullParams.tickTextRotate?"end":"middle",i="hanging"):t.fullDataFormatter.grid.groupAxis.position==="top"?(e=t.fullParams.tickTextRotate?"end":"middle",i="auto"):t.fullDataFormatter.grid.groupAxis.position==="left"?(e="end",i="middle"):t.fullDataFormatter.grid.groupAxis.position==="right"&&(e="start",i="middle"),{textAnchor:e,dominantBaseline:i}})),O=c.pipe(a(r),y(t=>{let e="start",i="hanging";return t.grid.groupAxis.position==="bottom"?i="hanging":t.grid.groupAxis.position==="top"?i="auto":t.grid.groupAxis.position==="left"?e="end":t.grid.groupAxis.position==="right"&&(e="start"),t.grid.valueAxis.position==="left"?e="start":t.grid.valueAxis.position==="right"?e="end":t.grid.valueAxis.position==="bottom"?i="auto":t.grid.valueAxis.position==="top"&&(i="hanging"),{textAnchor:e,dominantBaseline:i}}));return x({axisSelection:l,params:s,tickTextAlign:S,axisLabelAlign:O,gridAxesSize:o,fullDataFormatter:c,chartParams:k,groupScale:V,textTransform:P}).pipe(a(r),u(async t=>t)).subscribe(t=>{N({selection:t.axisSelection,xAxisClassName:A,groupingLabelClassName:F,params:t.params,tickTextAlign:t.tickTextAlign,axisLabelAlign:t.axisLabelAlign,gridAxesSize:t.gridAxesSize,fullDataFormatter:t.fullDataFormatter,chartParams:t.chartParams,groupScale:t.groupScale,textTransform:t.textTransform})}),()=>{r.next(void 0)}},U=6;function ee({selection:g,yAxisClassName:b,textClassName:d,fullParams:s,tickTextAlign:c,axisLabelAlign:k,gridAxesSize:T,fullDataFormatter:z,fullChartParams:o,valueScale:D,textTransform:v,minAndMax:r}){const h=g.selectAll(`g.${b}`).data([s]).join("g").classed(b,!0);g.selectAll(`g.${d}`).data([s]).join("g").classed(d,!0).each((l,P,V)=>{_(V[P]).selectAll("text").data([l]).join(S=>S.append("text").style("font-weight","bold"),S=>S,S=>S.remove()).attr("text-anchor",k.textAnchor).attr("dominant-baseline",k.dominantBaseline).style("font-size",`${o.styles.textSize}px`).style("fill",L(s.labelColorType,o)).style("transform",v).text(S=>z.grid.valueAxis.label)}).attr("transform",l=>`translate(${-l.tickPadding+s.labelOffset[0]}, ${T.height+l.tickPadding+s.labelOffset[1]})`);const p=r[1]-r[0],A=Q(D).scale(D).ticks(p>s.ticks?s.ticks:r[0]===0&&r[1]===0?1:Math.ceil(p)).tickFormat(l=>q(l,s.tickFormat)).tickSize(s.tickFullLine==!0?-T.width:U).tickPadding(s.tickPadding),F=h.transition().duration(100).call(A);return F.selectAll("line").style("fill","none").style("stroke",s.tickLineVisible==!0?L(s.tickColorType,o):"none").style("stroke-dasharray",s.tickFullLineDasharray).attr("pointer-events","none"),F.selectAll("path").style("fill","none").style("stroke",s.axisLineVisible==!0?L(s.axisLineColorType,o):"none").style("shape-rendering","crispEdges"),h.selectAll("text").style("font-family","sans-serif").style("font-size",`${o.styles.textSize}px`).style("color",L(s.tickTextColorType,o)).attr("text-anchor",c.textAnchor).attr("dominant-baseline",c.dominantBaseline).attr("transform-origin",`-${s.tickPadding+U} 0`).style("transform",v),h}const re=(g,{selection:b,computedData$:d,fullParams$:s,fullDataFormatter$:c,fullChartParams$:k,gridAxesTransform$:T,gridAxesReverseTransform$:z,gridAxesSize$:o,gridContainer$:D,isSeriesPositionSeprate$:v})=>{const r=new W,h=M(g,"container"),p=M(g,"yAxisG"),A=M(g,"yAxis"),F=M(g,"text"),R=x({computedData:d.pipe(B((e,i)=>e.length===i.length)),isSeriesPositionSeprate:v}).pipe(a(r),u(async e=>e),y(e=>e.isSeriesPositionSeprate?e.computedData:[e.computedData[0]]),y((e,i)=>b.selectAll(`g.${h}`).data(e,n=>n[0]?n[0].seriesIndex:i).join("g").classed(h,!0))),l=R.pipe(a(r),y((e,i)=>e.selectAll(`g.${p}`).data([p]).join("g").classed(p,!0)));x({containerSelection:R,gridContainer:D}).pipe(a(r),u(async e=>e)).subscribe(e=>{e.containerSelection.attr("transform",(i,n)=>{const f=e.gridContainer[n]??e.gridContainer[0],m=f.translate,C=f.scale;return`translate(${m[0]}, ${m[1]}) scale(${C[0]}, ${C[1]})`})}),x({axisSelection:l,gridAxesTransform:T}).pipe(a(r),u(async e=>e)).subscribe(e=>{e.axisSelection.style("transform",e.gridAxesTransform.value)});const P=x({fullParams:s,fullDataFormatter:c,gridAxesReverseTransform:z,gridContainer:D}).pipe(a(r),u(async e=>e),y(e=>{const i=`translate(${e.gridAxesReverseTransform.translate[0]}px, ${e.gridAxesReverseTransform.translate[1]}px)`,n=`rotate(${e.gridAxesReverseTransform.rotate}deg) rotateX(${e.gridAxesReverseTransform.rotateX}deg) rotateY(${e.gridAxesReverseTransform.rotateY}deg)`,f=`scale(${1/e.gridContainer[0].scale[0]}, ${1/e.gridContainer[0].scale[1]})`,C=`rotate(${e.fullDataFormatter.grid.groupAxis.position==="left"&&e.fullDataFormatter.grid.valueAxis.position==="top"||e.fullDataFormatter.grid.groupAxis.position==="right"&&e.fullDataFormatter.grid.valueAxis.position==="bottom"?e.fullParams.tickTextRotate+180:e.fullParams.tickTextRotate}deg)`;return`${i} ${n} ${f} ${C}`}),B()),V=new Y(e=>{x({fullDataFormatter:c,gridAxesSize:o,computedData:d}).pipe(a(r),u(async i=>i)).subscribe(i=>{const f=i.computedData[0]?i.computedData[0].length-1:0,m=i.fullDataFormatter.grid.groupAxis.scaleDomain[0]==="auto"?0-i.fullDataFormatter.grid.groupAxis.scalePadding:i.fullDataFormatter.grid.groupAxis.scaleDomain[0]-i.fullDataFormatter.grid.groupAxis.scalePadding,C=i.fullDataFormatter.grid.groupAxis.scaleDomain[1]==="auto"?f+i.fullDataFormatter.grid.groupAxis.scalePadding:i.fullDataFormatter.grid.groupAxis.scaleDomain[1]+i.fullDataFormatter.grid.groupAxis.scalePadding,w=i.computedData.map((E,I)=>E.filter((j,$)=>$>=m&&$<=C)),G=Z(w.flat());e.next(G)})}),S=new Y(e=>{x({fullDataFormatter:c,gridAxesSize:o,minAndMax:V}).pipe(a(r),u(async i=>i)).subscribe(i=>{const n=J({maxValue:i.minAndMax[1],minValue:i.minAndMax[0],axisWidth:i.gridAxesSize.height,scaleDomain:i.fullDataFormatter.grid.valueAxis.scaleDomain,scaleRange:i.fullDataFormatter.grid.valueAxis.scaleRange});e.next(n)})}),O=c.pipe(a(r),y(e=>{let i="start",n="hanging";return e.grid.valueAxis.position==="left"?(i="end",n="middle"):e.grid.valueAxis.position==="right"?(i="start",n="middle"):e.grid.valueAxis.position==="bottom"?(i="middle",n="hanging"):e.grid.valueAxis.position==="top"&&(i="middle",n="auto"),{textAnchor:i,dominantBaseline:n}})),t=c.pipe(a(r),y(e=>{let i="start",n="hanging";return e.grid.groupAxis.position==="bottom"?n="auto":e.grid.groupAxis.position==="top"?n="hanging":e.grid.groupAxis.position==="left"?i="start":e.grid.groupAxis.position==="right"&&(i="end"),e.grid.valueAxis.position==="left"?i="end":e.grid.valueAxis.position==="right"?i="start":e.grid.valueAxis.position==="bottom"?n="hanging":e.grid.valueAxis.position==="top"&&(n="auto"),{textAnchor:i,dominantBaseline:n}}));return x({axisSelection:l,fullParams:s,tickTextAlign:O,axisLabelAlign:t,computedData:d,gridAxesSize:o,fullDataFormatter:c,fullChartParams:k,valueScale:S,textTransform:P,minAndMax:V}).pipe(a(r),u(async e=>e)).subscribe(e=>{ee({selection:e.axisSelection,yAxisClassName:A,textClassName:F,fullParams:e.fullParams,tickTextAlign:e.tickTextAlign,axisLabelAlign:e.axisLabelAlign,gridAxesSize:e.gridAxesSize,fullDataFormatter:e.fullDataFormatter,fullChartParams:e.fullChartParams,valueScale:e.valueScale,textTransform:e.textTransform,minAndMax:e.minAndMax})}),()=>{r.next(void 0)}};export{se as a,re as c};
