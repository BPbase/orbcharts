import{aa as ct,ab as mt,ac as B,ad as d,ae as tt,af as et,ag as w,ah as z,ai as g,aj as dt,ak as $t,al as gt,am as ft,an as L,ao as bt,ap as yt,aq as Dt,ar as Tt,c as At,as as ht,A as Lt,at as Ct,Q as C,S as P,t as b,m as y,o as j,n as _,N as Pt,au as xt,av as Gt,d as E,e as I,s as S,K as Bt,L as at,R as St,M as Ft,aw as Rt,P as Mt,l as rt,k as Ot}from"./CllDRATP.js";import{g as _t,a as Et,b as It,d as kt,e as Ut,f as Nt,h as zt,i as jt,j as wt,k as vt,l as Ht}from"./CpFhQu0e.js";import{c as Vt}from"./Bjf8oAlN.js";import{c as Wt}from"./C5mL2_O5.js";import{g as F}from"./CWRPK8C-.js";import{c as Xt}from"./BQnOvW4U.js";import{c as Yt}from"./BAxO_L5M.js";import{a as Qt,c as qt}from"./fpoLK5Sh.js";const Kt=({fullDataFormatter$:o,computedData$:i,layout$:r,fullChartParams$:e,event$:a})=>{const s=new ct,m=mt({datumList$:i.pipe(B(t=>t.flat().flat()),d(1)),fullChartParams$:e,event$:a}).pipe(d(1)),l=it({computedData$:i,fullDataFormatter$:o,layout$:r}).pipe(d(1));return tt({fullDataFormatter:o,computedData:i,multiGridContainer:l}).pipe(et(async t=>t),B(t=>{s.next(void 0);const n=t.fullDataFormatter.gridList[0]??w;return t.computedData.map((u,p)=>{const c=t.fullDataFormatter.gridList[p]??n,$={type:"grid",visibleFilter:t.fullDataFormatter.visibleFilter,grid:{...c},container:{...t.fullDataFormatter.container}},D=z($).pipe(g(s),d(1)),f=z(u).pipe(g(s),d(1)),k=D.pipe(B(N=>N.grid.separateSeries),dt(),d(1)),M=z(t.multiGridContainer[p]).pipe(g(s),d(1)),A=_t({fullDataFormatter$:D,layout$:r}).pipe(g(s),d(1)),T=Et({gridAxesTransform$:A}).pipe(g(s),d(1)),h=It({computedData$:f,fullDataFormatter$:D,layout$:r}).pipe(g(s),d(1)),O=kt({gridContainerPosition$:M,gridAxesTransform$:A,gridGraphicTransform$:h}),U=Ut({fullDataFormatter$:D,layout$:r}).pipe(g(s),d(1)),x=f.pipe(B(N=>N.flat())).pipe(g(s),d(1)),G=Nt({computedData$:f}).pipe(g(s),d(1)),ot=$t({datumList$:x}).pipe(g(s),d(1)),nt=gt({datumList$:x}).pipe(g(s),d(1)),lt=zt({computedData$:f}).pipe(g(s),d(1)),Y=jt({computedData$:f,fullDataFormatter$:D,layout$:r}).pipe(g(s),d(1)),ut=wt({computedLayoutData$:Y}).pipe(g(s),d(1)),pt=vt({computedData$:f,isSeriesSeprate$:k}).pipe(d(1));return{isSeriesSeprate$:k,gridContainerPosition$:M,gridAxesTransform$:A,gridAxesReverseTransform$:T,gridGraphicTransform$:h,gridGraphicReverseScale$:O,gridAxesSize$:U,gridHighlight$:m,seriesLabels$:G,SeriesDataMap$:ot,GroupDataMap$:nt,dataFormatter$:D,computedData$:f,computedLayoutData$:Y,visibleComputedData$:lt,visibleComputedLayoutData$:ut,computedStackedData$:pt}})}))},it=({computedData$:o,fullDataFormatter$:i,layout$:r})=>tt({computedData:o,fullDataFormatter:i,layout:r}).pipe(et(async e=>e),B(e=>{const a=e.fullDataFormatter.gridList[0]??w,s=e.computedData.reduce((n,u,p)=>{const $=(e.fullDataFormatter.gridList[p]??a).separateSeries?u.length:e.fullDataFormatter.separateGrid?1:0;return n+$},0)||1,m=ft(e.layout,e.fullDataFormatter.container,s);let l=0;return e.computedData.map((n,u)=>{const p=e.fullDataFormatter.gridList[u]??a,c=n.map(($,D)=>{const f=m[l];return p.separateSeries&&(l+=1),f});return!p.separateSeries&&e.fullDataFormatter.separateGrid&&(l+=1),c})})),Jt=o=>{const i=L(o,{visibleFilter:{toBeTypes:["Function"]},gridList:{toBeTypes:["object[]"]},container:{toBeTypes:["object"]},separateGrid:{toBeTypes:["boolean"]}});if(o.gridList){const e=o.gridList.map((a,s)=>{const m=L(a,{seriesDirection:{toBe:'"row" | "column"',test:l=>l==="row"||l==="column"},rowLabels:{toBeTypes:["string[]"]},columnLabels:{toBeTypes:["string[]"]},valueAxis:{toBeTypes:["object"]},groupAxis:{toBeTypes:["object"]},separateSeries:{toBeTypes:["boolean"]}});if(m.status==="error")return m;if(a.valueAxis){const l=L(a.valueAxis,{position:{toBe:'"top" | "bottom" | "left" | "right"',test:t=>t==="top"||t==="bottom"||t==="left"||t==="right"},scaleDomain:{toBe:'[number | "min" | "auto", number | "max" | "auto"]',test:t=>Array.isArray(t)&&t.length===2&&(typeof t[0]=="number"||t[0]==="min"||t[0]==="auto")&&(typeof t[1]=="number"||t[1]==="max"||t[1]==="auto")},scaleRange:{toBe:"[number, number]",test:t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&typeof t[1]=="number"},label:{toBeTypes:["string"]}});if(l.status==="error")return l}else if(a.groupAxis){const l=L(a.groupAxis,{position:{toBe:'"top" | "bottom" | "left" | "right"',test:t=>t==="top"||t==="bottom"||t==="left"||t==="right"},scaleDomain:{toBe:'[number, number | "max"]',test:t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&(typeof t[1]=="number"||t[1]==="max")},scalePadding:{toBeTypes:["number"]},label:{toBeTypes:["string"]}});if(l.status==="error")return l}return{status:"success",columnName:"",expectToBe:""}}).find(a=>a.status==="error");if(e)return e}if(o.container){const r=L(o.container,{gap:{toBeTypes:["number"]},rowAmount:{toBeTypes:["number"]},columnAmount:{toBeTypes:["number"]}});if(r.status==="error")return r}return i},Zt=o=>{const{data:i=[],dataFormatter:r,chartParams:e}=o;if(!i.length)return[];let a=[];try{const s=r.gridList[0]||w,m=i.map((p,c)=>r.gridList[c]||s),l=i.map((p,c)=>Ht(p,m[c])),t=r.separateGrid?l.map((p,c)=>bt({transposedDataGrid:p,dataFormatterGrid:m[c],chartType:"multiGrid"})):l.map((p,c)=>yt({transposedDataGrid:p,dataFormatterGrid:m[c],chartType:"multiGrid",gridIndex:c})),n=new Map;let u=0;t.flat().forEach((p,c)=>{if(!n.has(p)){const $=Dt(u,e);n.set(p,$),u++}}),a=l.map((p,c)=>{const $=t[c],D=Tt({transposedDataGrid:p,dataFormatterGrid:m[c],chartType:"multiGrid",gridIndex:c});let f=0;return p.map((M,A)=>M.map((T,h)=>{const O=At("multiGrid",c,A,h),U=D[h],x=$[A],G={id:T.id?T.id:O,index:f,label:T.label?T.label:O,description:T.description??"",data:T.data,value:T.value,gridIndex:c,seriesIndex:A,seriesLabel:x,groupIndex:h,groupLabel:U,color:n.get(x),visible:!0};return G.visible=r.visibleFilter(G,o),f++,G}))})}catch(s){throw Error(s)}return a},te=o=>L({data:o},{data:{toBe:"DataGrid[]",test:r=>Array.isArray(r)}}),ee=({subject:o,observer:i})=>{const r=ht(i.fullChartParams$).pipe(d(1)),e=Kt({fullDataFormatter$:i.fullDataFormatter$,computedData$:i.computedData$,layout$:i.layout$,fullChartParams$:i.fullChartParams$,event$:o.event$}).pipe(d(1)),a=it({computedData$:i.computedData$,fullDataFormatter$:i.fullDataFormatter$,layout$:i.layout$});return{fullParams$:i.fullParams$,fullChartParams$:i.fullChartParams$,fullDataFormatter$:i.fullDataFormatter$,computedData$:i.computedData$,layout$:i.layout$,textSizePx$:r,multiGridContainerPosition$:a,multiGridEachDetail$:e}};class fe extends Lt{constructor(i,r){super({defaultDataFormatter:Ct,dataFormatterValidator:Jt,computedDataFn:Zt,dataValidator:te,contextObserverCallback:ee},i,r)}}const st="MultiGridLegend",ae={name:st,defaultParams:Pt,layerIndex:xt,validator:(o,{validateColumns:i})=>{const r=i(o,{placement:{toBe:'"top" | "top-start" | "top-end" | "bottom" | "bottom-start" | "bottom-end" | "left" | "left-start" | "left-end" | "right" | "right-start" | "right-end"',test:e=>["top","top-start","top-end","bottom","bottom-start","bottom-end","left","left-start","left-end","right","right-start","right-end"].includes(e)},padding:{toBeTypes:["number"]},backgroundFill:{toBeOption:"ColorType"},backgroundStroke:{toBeOption:"ColorType"},gap:{toBeTypes:["number"]},listRectWidth:{toBeTypes:["number"]},listRectHeight:{toBeTypes:["number"]},listRectRadius:{toBeTypes:["number"]},gridList:{toBeTypes:["object[]"]},textColorType:{toBeOption:"ColorType"}});if(o.gridList){const a=o.gridList.map((s,m)=>i(s,{listRectWidth:{toBeTypes:["number"]},listRectHeight:{toBeTypes:["number"]},listRectRadius:{toBeTypes:["number"]}})).find(s=>s.status==="error");if(a)return a}return r}},be=C(ae)(({selection:o,rootSelection:i,observer:r,subject:e})=>{const a=new P,s=r.multiGridEachDetail$.pipe(b(a),y(n=>n.map((p,c)=>p.SeriesDataMap$.pipe(y($=>Array.from($.keys()))))),j(n=>_(n)),y(n=>n.flat())),m=_({fullParams:r.fullParams$,computedData:r.computedData$}).pipe(b(a),j(async n=>n),y(n=>n.computedData.map((u,p)=>{const c=Gt(n.fullParams.gridList[p]??{},{listRectWidth:n.fullParams.listRectWidth,listRectHeight:n.fullParams.listRectHeight,listRectRadius:n.fullParams.listRectRadius});return u.map($=>c)}).flat())),l=_({fullParams:r.fullParams$,seriesList:m}).pipe(b(a),j(async n=>n),y(n=>({...n.fullParams,seriesList:n.seriesList}))),t=Vt(st,{rootSelection:i,seriesLabels$:s,fullParams$:l,layout$:r.layout$,fullChartParams$:r.fullChartParams$,textSizePx$:r.textSizePx$});return()=>{a.next(void 0),t()}}),R=o=>{const i=o.fullParams$.pipe(y(r=>r.gridIndexes),E(),I(1));return _({multiGridEachDetail:o.multiGridEachDetail$,gridIndexes:i}).pipe(y(r=>r.gridIndexes==="all"?r.multiGridEachDetail:r.gridIndexes.map(e=>r.multiGridEachDetail[e]??r.multiGridEachDetail[0])))},v="MultiBars",Q=F(v,"grid"),re={name:v,defaultParams:Bt,layerIndex:at,validator:(o,{validateColumns:i})=>i(o,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},barWidth:{toBeTypes:["number"]},barPadding:{toBeTypes:["number"]},barGroupPadding:{toBeTypes:["number"]},barRadius:{toBeTypes:["number","boolean"]}})},ye=C(re)(({selection:o,name:i,subject:r,observer:e})=>{const a=new P,s=[];return R(e).pipe(b(a)).subscribe(l=>{s.forEach(t=>t()),o.selectAll(`g.${Q}`).data(l).join("g").attr("class",Q).each((t,n,u)=>{const p=S(u[n]),c=t.dataFormatter$.pipe(b(a),y($=>$.grid.separateSeries),E(),I(1));s[n]=Wt(v,{selection:p,computedData$:t.computedData$,visibleComputedData$:t.visibleComputedData$,computedLayoutData$:t.computedLayoutData$,visibleComputedLayoutData$:t.visibleComputedLayoutData$,seriesLabels$:t.seriesLabels$,SeriesDataMap$:t.SeriesDataMap$,GroupDataMap$:t.GroupDataMap$,fullParams$:e.fullParams$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridGraphicTransform$:t.gridGraphicTransform$,gridGraphicReverseScale$:t.gridGraphicReverseScale$,gridAxesSize$:t.gridAxesSize$,gridHighlight$:t.gridHighlight$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:c,event$:r.event$})})}),()=>{a.next(void 0),s.forEach(l=>l())}}),H="MultiLines",q=F(H,"grid"),ie={name:H,defaultParams:St,layerIndex:at,validator:(o,{validateColumns:i})=>i(o,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},lineCurve:{toBeTypes:["string"]},lineWidth:{toBeTypes:["number"]}})},De=C(ie)(({selection:o,rootSelection:i,name:r,subject:e,observer:a})=>{const s=new P,m=[],l=a.multiGridContainerPosition$.pipe(b(s),y(n=>n.flat()));return R(a).pipe(b(s)).subscribe(n=>{m.forEach(u=>u()),o.selectAll(`g.${q}`).data(n).join("g").attr("class",q).each((u,p,c)=>{const $=S(c[p]);m[p]=Xt(H,{selection:$,computedData$:u.computedData$,computedLayoutData$:u.computedLayoutData$,visibleComputedData$:u.visibleComputedData$,visibleComputedLayoutData$:u.visibleComputedLayoutData$,seriesLabels$:u.seriesLabels$,SeriesDataMap$:u.SeriesDataMap$,GroupDataMap$:u.GroupDataMap$,fullDataFormatter$:u.dataFormatter$,fullParams$:a.fullParams$,fullChartParams$:a.fullChartParams$,gridAxesTransform$:u.gridAxesTransform$,gridGraphicTransform$:u.gridGraphicTransform$,gridAxesSize$:u.gridAxesSize$,gridHighlight$:u.gridHighlight$,gridContainerPosition$:u.gridContainerPosition$,allContainerPosition$:l,layout$:a.layout$,event$:e.event$})})}),()=>{s.next(void 0),m.forEach(n=>n())}}),V="MultiDots",K=F(V,"grid"),se={name:V,defaultParams:Ft,layerIndex:Rt,validator:(o,{validateColumns:i})=>i(o,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},radius:{toBeTypes:["number"]},fillColorType:{toBeOption:"ColorType"},strokeColorType:{toBeOption:"ColorType"},strokeWidth:{toBeTypes:["number"]},onlyShowHighlighted:{toBeTypes:["boolean"]}})},Te=C(se)(({selection:o,name:i,subject:r,observer:e})=>{const a=new P,s=[];return R(e).pipe(b(a)).subscribe(l=>{s.forEach(t=>t()),o.selectAll(`g.${K}`).data(l).join("g").attr("class",K).each((t,n,u)=>{const p=S(u[n]);s[n]=Yt(V,{selection:p,computedData$:t.computedData$,visibleComputedData$:t.visibleComputedData$,computedLayoutData$:t.computedLayoutData$,visibleComputedLayoutData$:t.visibleComputedLayoutData$,seriesLabels$:t.seriesLabels$,SeriesDataMap$:t.SeriesDataMap$,GroupDataMap$:t.GroupDataMap$,fullParams$:e.fullParams$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridGraphicTransform$:t.gridGraphicTransform$,gridGraphicReverseScale$:t.gridGraphicReverseScale$,gridAxesSize$:t.gridAxesSize$,gridHighlight$:t.gridHighlight$,gridContainerPosition$:t.gridContainerPosition$,event$:r.event$})})}),()=>{a.next(void 0),s.forEach(l=>l())}}),W="MultiGroupAxis",J=F(W,"grid"),oe={name:W,defaultParams:Mt,layerIndex:rt,validator:(o,{validateColumns:i})=>i(o,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},labelOffset:{toBe:"[number, number]",test:e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="number"&&typeof e[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBe:'number | null | "all"',test:e=>e===null||e==="all"||typeof e=="number"},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}})},Ae=C(oe)(({selection:o,name:i,subject:r,observer:e})=>{const a=new P,s=[];return R(e).pipe(b(a)).subscribe(l=>{s.forEach(t=>t()),o.selectAll(`g.${J}`).data(l).join("g").attr("class",J).each((t,n,u)=>{const p=S(u[n]),c=t.dataFormatter$.pipe(b(a),y($=>$.grid.separateSeries),E(),I(1));s[n]=Qt(W,{selection:p,computedData$:t.computedData$,fullParams$:e.fullParams$,fullDataFormatter$:t.dataFormatter$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridAxesReverseTransform$:t.gridAxesReverseTransform$,gridAxesSize$:t.gridAxesSize$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:c,textSizePx$:e.textSizePx$})})}),()=>{a.next(void 0),s.forEach(l=>l())}}),X="MultiValueAxis",Z=F(X,"grid"),ne={name:X,defaultParams:Ot,layerIndex:rt,validator:(o,{validateColumns:i})=>i(o,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(a=>typeof a=="number")},labelOffset:{toBe:"[number, number]",test:e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="number"&&typeof e[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBeTypes:["number","null"]},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}})},he=C(ne)(({selection:o,name:i,subject:r,observer:e})=>{const a=new P,s=[];return R(e).pipe(b(a)).subscribe(l=>{s.forEach(t=>t()),o.selectAll(`g.${Z}`).data(l).join("g").attr("class",Z).each((t,n,u)=>{const p=S(u[n]),c=t.dataFormatter$.pipe(b(a),y($=>$.grid.separateSeries),E(),I(1));s[n]=qt(X,{selection:p,computedData$:t.computedData$,fullParams$:e.fullParams$,fullDataFormatter$:t.dataFormatter$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridAxesReverseTransform$:t.gridAxesReverseTransform$,gridAxesSize$:t.gridAxesSize$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:c})})}),()=>{a.next(void 0),s.forEach(l=>l())}});export{ye as M,Te as a,be as b,Ae as c,De as d,he as e,fe as f,R as m};
