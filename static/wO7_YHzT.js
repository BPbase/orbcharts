import{av as J,bs as q,az as K,ax as Z,bt as B,aC as L,aD as G,aE as C,aA as X,aH as T,bu as R,aG as W,aK as E,bv as Q,bw as H,bx as _,m as v,b as w,k as A,l as y,s as V,d as Y,S as ee,ar as te,t as re,by as N,g as I}from"./ZOIXw5Nq.js";import{c as O,d as oe}from"./B67HsDFx.js";function ae(p,i){if(!p.length)return[];try{const l=p.reduce((s,t)=>t.length>s?t.length:s,0),c=p.map((s,t)=>{if(s.length===l)return s;const o=Object.assign([],s);for(let n=o.length;n<l;n++)o[n]=null;return o}).map((s,t)=>s.map((o,n)=>o==null?{id:"",label:"",data:{},value:null}:typeof o=="number"?{id:"",label:"",data:{},value:o}:{id:o.id??"",label:o.label??"",data:o.data??{},value:o.value}));return B(i.seriesDirection,c)}catch{return[]}}const ue=p=>{const{data:i=[],dataFormatter:l,chartParams:a}=p;if(!i.length)return[];let c;try{const r=ae(i,l),s=J({transposedDataGrid:r,dataFormatterGrid:l,chartType:"grid"}),t=q({transposedDataGrid:r,dataFormatterGrid:l,chartType:"grid"});let o=0;c=r.map((n,d)=>n.map((g,u)=>{const f=K("grid",0,d,u),m=t[u],D={id:g.id?g.id:f,index:o,label:g.label?g.label:f,description:g.description??"",data:g.data,value:g.value,gridIndex:0,seriesIndex:d,seriesLabel:s[d],groupIndex:u,groupLabel:m,color:Z(d,a),visible:!0};return D.visible=l.visibleFilter(D,p),o++,D}))}catch(r){throw Error(r)}return c},pe=({computedData$:p,fullDataFormatter$:i,layout$:l})=>{function a(r,s,t){const o=s.groupAxis.position==="top"||s.groupAxis.position==="bottom"?t.width:t.height,n=r[0]?r[0].length-1:0;return O({maxValue:n,minValue:0,axisWidth:o,scaleDomain:[0,n],scaleRange:[0,1]})}function c(r,s,t){const o=s.valueAxis.position==="left"||s.valueAxis.position==="right"?t.height:t.width,n=r.flat();let[d,g]=_(n);return d===g&&g===0&&(g=1),O({maxValue:g,minValue:d,axisWidth:o,scaleDomain:["auto","auto"],scaleRange:[0,1]})}return L({computedData:p,fullDataFormatter:i,layout:l}).pipe(G(async r=>r),C(r=>{const s=a(r.computedData,r.fullDataFormatter,r.layout),t=c(r.computedData,r.fullDataFormatter,r.layout),o=t(0);return r.computedData.map((n,d)=>n.map((g,u)=>{const f=s(u),m=t(g.value??0);return{...g,axisX:f,axisY:m,axisYFromZero:m-o}}))}))},ne=({fullDataFormatter$:p,layout$:i})=>{const l=new X;function a({xAxisPosition:s,yAxisPosition:t,width:o,height:n}){return(s==="bottom"||s==="top")&&(t==="left"||t==="right")?{width:o,height:n}:(s==="left"||s==="right")&&(t==="bottom"||t==="top")?{width:n,height:o}:{width:o,height:n}}const c=p.pipe(C(s=>s.groupAxis.position),T()),r=p.pipe(C(s=>s.valueAxis.position),T());return new R(s=>{L({groupAxisPosition:c,valueAxisPosition:r,layout:i}).pipe(W(l),G(async t=>t)).subscribe(t=>{const o=a({xAxisPosition:t.groupAxisPosition,yAxisPosition:t.valueAxisPosition,width:t.layout.width,height:t.layout.height});return s.next(o),function(){l.next(void 0)}})})},ge=({fullDataFormatter$:p,containerSize$:i})=>ne({fullDataFormatter$:p,layout$:i}),me=({computedData$:p})=>p.pipe(C(i=>i.filter(l=>l.length).map(l=>l[0].seriesLabel)),T((i,l)=>JSON.stringify(i).length===JSON.stringify(l).length)),fe=({computedData$:p})=>p.pipe(C(i=>i.map(a=>a.filter(c=>c.visible==!0)).filter(a=>a.length))),de=({computedAxesData$:p})=>p.pipe(C(i=>i.map(a=>a.filter(c=>c.visible==!0)).filter(a=>a.length))),be=({computedData$:p,fullDataFormatter$:i,layout$:l})=>L({computedData:p,fullDataFormatter:i,layout:l}).pipe(G(async c=>c),C(c=>{if(c.computedData.length===0)return[{slotIndex:0,rowIndex:0,columnIndex:0,translate:[0,0],scale:[1,1]}];if(c.fullDataFormatter.separateSeries)return E(c.layout,c.fullDataFormatter.container,c.computedData.length);{const r=E(c.layout,c.fullDataFormatter.container,1);return c.computedData.map((s,t)=>r[0])}})),xe=({isSeriesSeprate$:p,computedData$:i})=>{const l=i.pipe(C(a=>{const c=new Array(a[0]?a[0].length:0).fill(null).map((s,t)=>a.reduce((o,n)=>{if(n&&n[t]){const d=n[t].value==null||n[t].visible==!1?0:n[t].value;return o+d}return o},0));return a.map((s,t)=>s.map((o,n)=>({...o,value:c[n]})))}));return p.pipe(G(a=>Q(()=>a,i,l)))},De=({computedData$:p,fullDataFormatter$:i})=>L({computedData:p,fullDataFormatter:i}).pipe(G(async l=>l),C(l=>{const a=l.fullDataFormatter.groupAxis,c=l.computedData[0]?l.computedData[0].length-1:0,r=a.scaleDomain[0]-a.scalePadding,s=a.scaleDomain[1]==="max"?c+a.scalePadding:a.scaleDomain[1]+a.scalePadding;return[r,s]})),he=({computedData$:p,groupScaleDomainValue$:i})=>L({computedData:p,groupScaleDomainValue:i}).pipe(C(l=>{const a=l.computedData.map((r,s)=>r.filter((t,o)=>o>=l.groupScaleDomainValue[0]&&o<=l.groupScaleDomainValue[1]&&t.visible==!0));return H(a)})),ve=({fullDataFormatter$:p,layout$:i})=>{const l=new X;function a({xAxis:c,yAxis:r,width:s,height:t}){if(!c||!r)return{translate:[0,0],scale:[1,1],rotate:0,rotateX:0,rotateY:0,value:""};let o=0,n=0,d=0,g=0,u=0;return c.position==="bottom"?r.position==="left"?(g=180,n=t):r.position==="right"?(g=180,u=180,o=s,n=t):(g=180,n=t):c.position==="top"?r.position==="left"||(r.position==="right"?(u=180,o=s):(g=180,n=t)):c.position==="left"?r.position==="bottom"?(d=-90,n=t):r.position==="top"?(d=-90,u=180):(g=180,n=t):c.position==="right"?r.position==="bottom"?(d=-90,g=180,n=t,o=s):r.position==="top"?(d=-90,g=180,u=180,o=s):(g=180,n=t):(g=180,n=t),{translate:[o,n],scale:[1,1],rotate:d,rotateX:g,rotateY:u,value:`translate(${o}px, ${n}px) rotate(${d}deg) rotateX(${g}deg) rotateY(${u}deg)`}}return new R(c=>(L({fullDataFormatter:p,layout:i}).pipe(W(l),G(async r=>r)).subscribe(r=>{const s=a({xAxis:r.fullDataFormatter.groupAxis,yAxis:r.fullDataFormatter.valueAxis,width:r.layout.width,height:r.layout.height});c.next(s)}),function(){l.next(void 0)}))},Se=({gridAxesTransform$:p})=>p.pipe(C(i=>{const l=[0,0],a=[1/i.scale[0],1/i.scale[1]],c=i.rotate*-1,r=i.rotateX*-1,s=i.rotateY*-1;return{translate:l,scale:a,rotate:c,rotateX:r,rotateY:s,value:`translate(${l[0]}px, ${l[1]}px) rotateX(${r}deg) rotateY(${s}deg) rotate(${c}deg)`}})),Ae=({computedData$:p,groupScaleDomainValue$:i,filteredMinMaxValue$:l,fullDataFormatter$:a,layout$:c})=>{const r=new X;function s({data:t,groupAxis:o,valueAxis:n,groupScaleDomainValue:d,filteredMinMaxValue:g,width:u,height:f}){let m=0,D=0,e=0,b=0;const h=o.position==="top"||o.position==="bottom"?u:f,S=0,x=t[0]?t[0].length-1:0,P=O({maxValue:x,minValue:S,axisWidth:h,scaleDomain:d,scaleRange:[0,1]}),$=P(S),M=P(x);S==x?(m=0,e=1):(m=$,e=(M-$)/h),g[0]===g[1]&&g[1]===0&&(g[1]=1);const z=n.position==="left"||n.position==="right"?f:u,j=O({maxValue:g[1],minValue:g[0],axisWidth:z,scaleDomain:n.scaleDomain,scaleRange:n.scaleRange}),F=H(t);F[0]===F[1]&&F[1]===0&&(F[1]=1);const k=j(F[0]>0?0:F[0]),U=j(F[1]<0?0:F[1]);return D=k,b=(U-k)/z,{translate:[m,D],scale:[e,b],rotate:0,rotateX:0,rotateY:0,value:`translate(${m}px, ${D}px) scale(${e}, ${b})`}}return new R(t=>(L({computedData:p,groupScaleDomainValue:i,filteredMinMaxValue:l,fullDataFormatter:a,layout:c}).pipe(W(r),G(async o=>o)).subscribe(o=>{const n=s({data:o.computedData,groupAxis:o.fullDataFormatter.groupAxis,valueAxis:o.fullDataFormatter.valueAxis,groupScaleDomainValue:o.groupScaleDomainValue,filteredMinMaxValue:o.filteredMinMaxValue,width:o.layout.width,height:o.layout.height});t.next(n)}),function(){r.next(void 0)}))},ye=({gridContainerPosition$:p,gridAxesTransform$:i,gridGraphicTransform$:l})=>L({gridContainerPosition:p,gridAxesTransform:i,gridGraphicTransform:l}).pipe(G(async a=>a),C(a=>a.gridAxesTransform.rotate==0||a.gridAxesTransform.rotate==180?a.gridContainerPosition.map((c,r)=>[1/a.gridGraphicTransform.scale[0]/a.gridContainerPosition[r].scale[0],1/a.gridGraphicTransform.scale[1]/a.gridContainerPosition[r].scale[1]]):a.gridContainerPosition.map((c,r)=>[1/a.gridGraphicTransform.scale[0]/a.gridContainerPosition[r].scale[1],1/a.gridGraphicTransform.scale[1]/a.gridContainerPosition[r].scale[0]]))),$e=({selection:p,pluginName:i,clipPathID:l,seriesLabels$:a,gridContainerPosition$:c,gridAxesTransform$:r,gridGraphicTransform$:s})=>{const t=I(i,"series"),o=I(i,"axes"),n=I(i,"graphic"),d=a.pipe(v((m,D)=>p.selectAll(`g.${t}`).data(m,e=>e).join(e=>e.append("g").classed(t,!0).each((b,h,S)=>{V(S[h]).selectAll(`g.${o}`).data([h]).join(x=>x.append("g").classed(o,!0).attr("clip-path",`url(#${l})`).each((P,$,M)=>{V(M[$]).selectAll("defs").data([$]).join("defs"),V(M[$]).selectAll("g").data([$]).join("g").classed(n,!0)}),x=>x,x=>x.remove())}),e=>e,e=>e.remove())),w(1));A({seriesSelection:d,gridContainerPosition:c}).pipe(y(async m=>m)).subscribe(m=>{m.seriesSelection.transition().attr("transform",(D,e)=>{const b=m.gridContainerPosition[e]??m.gridContainerPosition[0],h=b.translate,S=b.scale;return`translate(${h[0]}, ${h[1]}) scale(${S[0]}, ${S[1]})`})});const g=A({seriesSelection:d,gridAxesTransform:r}).pipe(y(async m=>m),v(m=>m.seriesSelection.select(`g.${o}`).style("transform",m.gridAxesTransform.value)),w(1)),u=g.pipe(v(m=>m.select("defs")),w(1)),f=A({axesSelection:g,gridGraphicTransform:s}).pipe(y(async m=>m),v(m=>{const D=m.axesSelection.select(`g.${n}`);return D.transition().duration(50).style("transform",m.gridGraphicTransform.value),D}),w(1));return{seriesSelection$:d,axesSelection$:g,defsSelection$:u,graphicGSelection$:f}},Ce=({selection:p,pluginName:i,computedData$:l,gridContainerPosition$:a,isSeriesSeprate$:c})=>{const r=I(i,"container"),s=A({computedData:l.pipe(Y((t,o)=>t.length===o.length)),isSeriesSeprate:c}).pipe(y(async t=>t),v(t=>t.isSeriesSeprate?t.computedData:[t.computedData[0]]),v((t,o)=>p.selectAll(`g.${r}`).data(t,n=>n&&n[0]?n[0].seriesIndex:o).join("g").classed(r,!0)),w(1));return A({containerSelection:s,gridContainerPosition:a}).pipe(y(async t=>t)).subscribe(t=>{t.containerSelection.attr("transform",(o,n)=>{const d=t.gridContainerPosition[n]??t.gridContainerPosition[0],g=d.translate,u=d.scale;return`translate(${g[0]}, ${g[1]}) scale(${u[0]}, ${u[1]})`})}),s},Pe=({fullDataFormatter$:p,gridAxesSize$:i,computedData$:l,fullChartParams$:a,gridContainerPosition$:c,layout$:r})=>{const s=new ee,t=A({fullDataFormatter:p,gridAxesSize:i,computedData:l}).pipe(y(async u=>u),v(u=>{const f=u.computedData[0]?u.computedData[0].length-1:0,m=u.fullDataFormatter.groupAxis.scaleDomain[0]-u.fullDataFormatter.groupAxis.scalePadding,D=u.fullDataFormatter.groupAxis.scaleDomain[1]==="max"?f+u.fullDataFormatter.groupAxis.scalePadding:u.fullDataFormatter.groupAxis.scaleDomain[1]+u.fullDataFormatter.groupAxis.scalePadding;return[m,D]}),w(1)),o=A({fullDataFormatter:p,computedData:l}).pipe(y(async u=>u),v(u=>u.fullDataFormatter.seriesDirection==="row"?(u.computedData[0]??[]).map(f=>f.groupLabel):u.computedData.map(f=>f[0].groupLabel))),n=A({groupScaleDomain:t,groupLabels:o}).pipe(y(async u=>u),v(u=>u.groupLabels.filter((f,m)=>m>=u.groupScaleDomain[0]&&m<=u.groupScaleDomain[1]))),d=c.pipe(v(u=>u.reduce((m,D)=>D.columnIndex>m?D.columnIndex:m,0)+1),Y()),g=c.pipe(v(u=>u.reduce((m,D)=>D.rowIndex>m?D.rowIndex:m,0)+1),Y());return new te(u=>{A({dataFormatter:p,axisSize:i,fullChartParams:a,scaleRangeGroupLabels:n,groupLabels:o,groupScaleDomain:t,columnAmount:d,rowAmount:g,layout:r}).pipe(re(s),y(async f=>f)).subscribe(f=>{const m=f.dataFormatter.valueAxis.position==="right"||f.dataFormatter.valueAxis.position==="bottom",D=N({axisLabels:f.scaleRangeGroupLabels,axisWidth:f.axisSize.width,padding:f.dataFormatter.groupAxis.scalePadding,reverse:m}),e=h=>f.dataFormatter.groupAxis.position==="bottom"||f.dataFormatter.groupAxis.position==="top"?h.offsetX-f.fullChartParams.padding.left:h.offsetY-f.fullChartParams.padding.top,b=h=>{const S={offsetX:h.offsetX*f.columnAmount%f.layout.rootWidth,offsetY:h.offsetY*f.rowAmount%f.layout.rootHeight},x=e(S),P=D(x),$=Math.ceil(f.groupScaleDomain[0]),M=P+$;return{groupIndex:M,groupLabel:f.groupLabels[M]??""}};return u.next(b),function(){s.next(void 0)}})})},Fe=({rootSelection:p,fullDataFormatter$:i,containerSize$:l,gridAxesContainerSize$:a,computedData$:c,gridContainerPosition$:r,layout$:s})=>{const t=oe(p,"mousemove"),o=A({fullDataFormatter:i,computedData:c}).pipe(y(async e=>e),v(e=>{const b=e.computedData[0]?e.computedData[0].length-1:0,h=e.fullDataFormatter.groupAxis.scaleDomain[0]-e.fullDataFormatter.groupAxis.scalePadding,S=e.fullDataFormatter.groupAxis.scaleDomain[1]==="max"?b+e.fullDataFormatter.groupAxis.scalePadding:e.fullDataFormatter.groupAxis.scaleDomain[1]+e.fullDataFormatter.groupAxis.scalePadding;return[h,S]}),w(1)),n=A({fullDataFormatter:i,computedData:c}).pipe(y(async e=>e),v(e=>e.fullDataFormatter.seriesDirection==="row"?(e.computedData[0]??[]).map(b=>b.groupLabel):e.computedData.map(b=>b[0].groupLabel))),d=A({groupScaleDomain:o,groupLabels:n}).pipe(y(async e=>e),v(e=>e.groupLabels.filter((b,h)=>h>=e.groupScaleDomain[0]&&h<=e.groupScaleDomain[1]))),g=i.pipe(v(e=>e.valueAxis.position==="right"||e.valueAxis.position==="bottom")),u=A({reverse:g,gridAxesContainerSize:a,scaleRangeGroupLabels:d,fullDataFormatter:i}).pipe(y(async e=>e),v(e=>N({axisLabels:e.scaleRangeGroupLabels,axisWidth:e.gridAxesContainerSize.width,padding:e.fullDataFormatter.groupAxis.scalePadding,reverse:e.reverse}))),f=A({fullDataFormatter:i,rootMousemove:t,gridContainerPosition:r,layout:s}).pipe(y(async e=>e),v(e=>{if(e.fullDataFormatter.groupAxis.position==="bottom"||e.fullDataFormatter.groupAxis.position==="top"){let b=e.rootMousemove.offsetX;const S=e.gridContainerPosition.map((x,P)=>{var $;return[x.translate[0],(($=e.gridContainerPosition[P+1])==null?void 0:$.translate[0])??e.layout.rootWidth]}).filter(x=>x[0]<x[1]).find(x=>b>=x[0]&&b<=x[1]);return S&&(b=b-S[0]),b-e.layout.left}else{let b=e.rootMousemove.offsetY;const S=e.gridContainerPosition.map((x,P)=>{var $;return[x.translate[1],(($=e.gridContainerPosition[P+1])==null?void 0:$.translate[1])??e.layout.rootHeight]}).filter(x=>x[0]<x[1]).find(x=>b>=x[0]&&b<=x[1]);return S&&(b=b-S[0]),b-e.layout.top}})),m=A({xIndexScale:u,axisValue:f,groupScaleDomain:o}).pipe(y(async e=>e),v(e=>{const b=e.xIndexScale(e.axisValue),h=Math.ceil(e.groupScaleDomain[0]);return b+h})),D=A({groupIndex:m,groupLabels:n}).pipe(y(async e=>e),v(e=>e.groupLabels[e.groupIndex]??""));return A({groupIndex:m,groupLabel:D}).pipe(y(async e=>e),v(e=>({groupIndex:e.groupIndex,groupLabel:e.groupLabel})))};export{ge as a,me as b,ae as c,fe as d,pe as e,de as f,ne as g,xe as h,De as i,he as j,ve as k,Se as l,Ae as m,ye as n,$e as o,Pe as p,Fe as q,be as r,ue as s,Ce as t};
