import{S as I,$ as G,o as F,t as $,p as x,m as p,e as h,M as v,s as S}from"./CzjhHakb.js";import{c as w}from"./DkqUpMvk.js";import{m as C}from"./LeROuoJL.js";import{g as L}from"./u-UBqIpB.js";import{o as T}from"./O1thvzHA.js";function O(l){let s=Math.floor(Math.sqrt(l)),n=Math.ceil(l/s);for(;s*n<l;)n++;return{rowAmount:s,columnAmount:n}}function P(l,s,n){const{gap:a}=s,{rowAmount:o,columnAmount:r}=s.rowAmount*s.columnAmount>=n?s:O(n);return new Array(n).fill(null).map((f,c)=>{const m=c%r,u=Math.floor(c/r),t=(l.width-a*(r-1))/r,e=(l.height-a*(o-1))/o,i=m*t+m*a,d=u*e+u*a,D=[i,d],g=[t/l.width,e/l.height];return{slotIndex:c,rowIndex:u,columnIndex:m,translate:D,scale:g}})}const y=({fullDataFormatter$:l,layout$:s})=>{const n=new I;function a({xAxis:o,yAxis:r,width:f,height:c}){if(!o||!r)return{translate:[0,0],scale:[1,1],rotate:0,rotateX:0,rotateY:0,value:""};let m=0,u=0,t=0,e=0,i=0;return o.position==="bottom"?r.position==="left"?(e=180,u=c):r.position==="right"?(e=180,i=180,m=f,u=c):(e=180,u=c):o.position==="top"?r.position==="left"||(r.position==="right"?(i=180,m=f):(e=180,u=c)):o.position==="left"?r.position==="bottom"?(t=-90,u=c):r.position==="top"?(t=-90,i=180):(e=180,u=c):o.position==="right"?r.position==="bottom"?(t=-90,e=180,u=c,m=f):r.position==="top"?(t=-90,e=180,i=180,m=f):(e=180,u=c):(e=180,u=c),{translate:[m,u],scale:[1,1],rotate:t,rotateX:e,rotateY:i,value:`translate(${m}px, ${u}px) rotate(${t}deg) rotateX(${e}deg) rotateY(${i}deg)`}}return new G(o=>(F({fullDataFormatter:l,layout:s}).pipe($(n),x(async r=>r)).subscribe(r=>{const f=a({xAxis:r.fullDataFormatter.grid.groupAxis,yAxis:r.fullDataFormatter.grid.valueAxis,width:r.layout.width,height:r.layout.height});o.next(f)}),function(){n.next(void 0)}))},X=({gridAxesTransform$:l})=>l.pipe(p(s=>{const n=[0,0],a=[1/s.scale[0],1/s.scale[1]],o=s.rotate*-1,r=s.rotateX*-1,f=s.rotateY*-1;return{translate:n,scale:a,rotate:o,rotateX:r,rotateY:f,value:`translate(${n[0]}px, ${n[1]}px) rotate(${o}deg) rotateX(${r}deg) rotateY(${f}deg)`}})),M=({computedData$:l,fullDataFormatter$:s,layout$:n})=>F({computedData:l,fullDataFormatter:s,layout:n}).pipe(x(async o=>o),p(o=>{if(o.fullDataFormatter.grid.separateSeries)return P(o.layout,o.fullDataFormatter.container,o.computedData.length);{const r=P(o.layout,o.fullDataFormatter.container,1);return o.computedData.map((f,c)=>r[0])}})),A="OverlappingValueAxes",b=L(A,"grid"),j=h(A,v)(({selection:l,name:s,subject:n,observer:a})=>{const o=new I,r=[],f=a.fullParams$.pipe($(o),p(t=>t.gridIndexes[0])),c=a.fullParams$.pipe($(o),p(t=>t.gridIndexes[1])),m=F({firstGridIndex:f,secondGridIndex:c,fullDataFormatter:a.fullDataFormatter$}).pipe($(o),x(async t=>t),p(t=>{t.fullDataFormatter.gridList[t.secondGridIndex]||(t.fullDataFormatter.gridList[t.secondGridIndex]=Object.assign({},t.fullDataFormatter.gridList[t.firstGridIndex]));const e=t.fullDataFormatter.gridList[t.firstGridIndex].valueAxis.position;let i=e;return e==="left"?i="right":e==="bottom"?i="top":e==="top"?i="bottom":e==="right"&&(i="left"),{type:"grid",visibleFilter:t.fullDataFormatter.visibleFilter,grid:{...t.fullDataFormatter.gridList[t.secondGridIndex],valueAxis:{...t.fullDataFormatter.gridList[t.secondGridIndex].valueAxis,position:i}},container:{...t.fullDataFormatter.container}}}));return T(a).pipe($(o),p(t=>({...t,fullParams$:t.fullParams$.pipe(p(e=>(e.gridIndexes.length>2&&(e.gridIndexes.length=2),e)))})),x(t=>C(t)),p(t=>t.map((e,i)=>{if(i===0)return e;const d=y({fullDataFormatter$:m,layout$:a.layout$}),D=X({gridAxesTransform$:d}),g=M({computedData$:e.computedData$,fullDataFormatter$:m,layout$:a.layout$});return{...e,gridAxesTransform$:d,gridAxesReverseTransform$:D,gridContainerPosition$:g}}))).pipe($(o)).subscribe(t=>{r.forEach(e=>e()),l.selectAll(`g.${b}`).data(t).join("g").attr("class",b).each((e,i,d)=>{if(i>1)return;const D=S(d[i]);r[i]=w(A,{selection:D,computedData$:e.computedData$,fullParams$:a.fullParams$.pipe(p(g=>i===0?g.firstAxis:g.secondAxis)),fullDataFormatter$:e.dataFormatter$,fullChartParams$:a.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridAxesReverseTransform$:e.gridAxesReverseTransform$,gridAxesSize$:e.gridAxesSize$,gridContainerPosition$:e.gridContainerPosition$,isSeriesSeprate$:e.isSeriesSeprate$})})}),()=>{o.next(void 0),r.forEach(t=>t())}});export{j as O,X as a,M as b,y as g};
