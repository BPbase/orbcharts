import{v as A,S as b,t as a,m as n,j as B,k as g,s as F,g as D,Z as C,i as L,w as k,l as I,r as P}from"./DFL_iQJX.js";import{c as O}from"./DyWp5Od5.js";import{m as h}from"./CYDKtMSz.js";import{o as G}from"./CNYLKIQy.js";const d="OverlappingValueAxes",x=D(d,"grid"),S={name:d,defaultParams:C,layerIndex:L,validator:(s,{validateColumns:l})=>{const y=l(s,{firstAxis:{toBeTypes:["object"]},secondAxis:{toBeTypes:["object"]},gridIndexes:{toBe:"[number, number]",test:r=>Array.isArray(r)&&r.length===2}});if(s.firstAxis){const r=l(s.firstAxis,{labelOffset:{toBe:"[number, number]",test:i=>Array.isArray(i)&&i.length===2&&typeof i[0]=="number"&&typeof i[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBeTypes:["number"]},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}});if(r.status==="error")return r}if(s.secondAxis){const r=l(s.secondAxis,{labelOffset:{toBe:"[number, number]",test:i=>Array.isArray(i)&&i.length===2&&typeof i[0]=="number"&&typeof i[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBeTypes:["number"]},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}});if(r.status==="error")return r}return y}},M=A(S)(({selection:s,name:l,subject:y,observer:r})=>{const i=new b,c=[],T=r.fullParams$.pipe(a(i),n(e=>e.gridIndexes[0])),$=r.fullParams$.pipe(a(i),n(e=>e.gridIndexes[1])),f=B({firstGridIndex:T,secondGridIndex:$,fullDataFormatter:r.fullDataFormatter$}).pipe(a(i),g(async e=>e),n(e=>{e.fullDataFormatter.gridList[e.secondGridIndex]||(e.fullDataFormatter.gridList[e.secondGridIndex]=Object.assign({},e.fullDataFormatter.gridList[e.firstGridIndex]));const t=e.fullDataFormatter.gridList[e.firstGridIndex].valueAxis.position;let o=t;return t==="left"?o="right":t==="bottom"?o="top":t==="top"?o="bottom":t==="right"&&(o="left"),{type:"grid",visibleFilter:e.fullDataFormatter.visibleFilter,...e.fullDataFormatter.gridList[e.secondGridIndex],valueAxis:{...e.fullDataFormatter.gridList[e.secondGridIndex].valueAxis,position:o},container:{...e.fullDataFormatter.container}}}));return G(r).pipe(a(i),n(e=>({...e,fullParams$:e.fullParams$.pipe(n(t=>(t.gridIndexes.length>2&&(t.gridIndexes.length=2),t)))})),g(e=>h(e)),n(e=>e.map((t,o)=>{if(o===0)return t;const p=k({fullDataFormatter$:f,layout$:r.layout$}),m=I({gridAxesTransform$:p}),u=P({computedData$:t.computedData$,fullDataFormatter$:f,layout$:r.layout$});return{...t,dataFormatter$:f,gridAxesTransform$:p,gridAxesReverseTransform$:m,gridContainerPosition$:u}}))).pipe(a(i)).subscribe(e=>{c.forEach(t=>t()),s.selectAll(`g.${x}`).data(e).join("g").attr("class",x).each((t,o,p)=>{if(o>1)return;const m=F(p[o]);c[o]=O(d,{selection:m,computedData$:t.computedData$,filteredMinMaxValue$:t.filteredMinMaxValue$,fullParams$:r.fullParams$.pipe(n(u=>o===0?u.firstAxis:u.secondAxis)),fullDataFormatter$:t.dataFormatter$,fullChartParams$:r.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridAxesReverseTransform$:t.gridAxesReverseTransform$,gridAxesSize$:t.gridAxesSize$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:t.isSeriesSeprate$})})}),()=>{i.next(void 0),c.forEach(e=>e())}});export{M as O};
