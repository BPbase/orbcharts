import{T as Y,U as ue,V as pe,H as ge,W as de,F as $e,X as me,Y as se,Z as oe,$ as H,a0 as K,a1 as Z,J as L,a2 as J,I as he,K as fe,a3 as De,L as Se,a4 as be,S as F,f as C,t as A,s as x,m as T,e as V,c as M,p as E,a5 as xe}from"./Czm2CNpZ.js";import{c as Le,b as Ae,d as ye,i as Te,e as Ge,f as Pe,h as Ce,j as Me,k as Fe,l as Re,m as Ie,n as ve,a as ke,o as _e}from"./CgW5LUy5.js";import{e as Ee,b as q,g as v,i as Oe,s as z}from"./CB2cfhTk.js";import{c as Ue}from"./BpbZ-aDY.js";import{c as we}from"./DS2-8Vo0.js";import{b as ze,c as He}from"./CV1EpQKa.js";function Ve({context:i,gridIndex:l,transposedDataGrid:r,gridSeriesLabels:u,SeriesLabelColorMap:g}){const{data:t=[],dataFormatter:h,chartParams:o,layout:e}=i;if(!t.length)return[];const a=Ae(r,h,e),p=de({transposedDataGrid:r,dataFormatter:h,chartType:"multiGrid",gridIndex:l}),d=ye(r,h,e),S=r.map((b,$)=>d[$](0));let s=0;return r.map((b,$)=>b.map((D,G)=>{const P=$e("multiGrid",l,$,G),R=p[G],n=u[$],k=d[$],_=k(D.value??0),O=S[$],U={id:D.id?D.id:P,index:s,label:D.label?D.label:P,description:D.description??"",data:D.data,value:D.value,gridIndex:l,seriesIndex:$,seriesLabel:n,groupIndex:G,groupLabel:R,color:g.get(n),axisX:a(G),axisY:_,axisYFromZero:_-O,visible:D._visible};return s++,U}))}const je=({data:i=[],dataFormatter:l,chartParams:r,layout:u})=>{if(!i.length)return[];let g=[];try{const t=l.gridList[0]||Y,h=i.map((s,m)=>({type:"grid",grid:{...l.gridList[m]||t},container:{...l.container}})),o=i.map((s,m)=>({data:s,dataFormatter:h[m],chartParams:r,layout:u})),e=i.map((s,m)=>Le(o[m])),a=new Set(h.map(b=>b.grid.slotIndex)).size!==h.length?ue:pe,p=e.map((s,m)=>a({transposedDataGrid:s,dataFormatter:h[m],chartType:"multiGrid",gridIndex:m})),d=new Map;let S=0;p.flat().forEach((s,m)=>{if(!d.has(s)){const b=ge(S,r);d.set(s,b),S++}}),g=i.map((s,m)=>Ve({context:o[m],gridIndex:m,transposedDataGrid:e[m],gridSeriesLabels:p[m],SeriesLabelColorMap:d}))}catch(t){throw Error(t)}return g},Ne=({fullDataFormatter$:i,computedData$:l,layout$:r,fullChartParams$:u,event$:g})=>{function t({gridDataFormatter$:o,gridComputedData$:e,layout$:a,fullChartParams$:p,event$:d}){const S=Te({computedData$:e,fullDataFormatter$:o}).pipe(L(1)),s=Ge({computedData$:e,fullDataFormatter$:o,fullChartParams$:p,layout$:a}).pipe(L(1)),m=Pe({fullDataFormatter$:o,layout$:a}).pipe(L(1)),b=Ce({gridAxesTransform$:m}).pipe(L(1)),$=Me({computedData$:e,fullDataFormatter$:o,layout$:a}).pipe(L(1)),D=Fe({gridContainer$:s,gridAxesTransform$:m,gridGraphicTransform$:$}),G=Re({fullDataFormatter$:o,layout$:a}).pipe(L(1)),P=e.pipe(H(U=>U.flat())).pipe(L(1)),R=he({datumList$:P,fullChartParams$:p,event$:d}).pipe(L(1)),n=Ie({computedData$:e}),k=fe({datumList$:P}).pipe(L(1)),_=De({datumList$:P}).pipe(L(1)),O=ve({computedData$:e}).pipe(L(1));return{isSeriesPositionSeprate$:S,gridContainer$:s,gridAxesTransform$:m,gridAxesReverseTransform$:b,gridGraphicTransform$:$,gridGraphicReverseScale$:D,gridAxesSize$:G,gridHighlight$:R,existedSeriesLabels$:n,SeriesDataMap$:k,GroupDataMap$:_,visibleComputedData$:O}}const h=new me;return se({fullDataFormatter:i,computedData:l}).pipe(oe(async o=>o),H(o=>{h.next(void 0);const e=o.fullDataFormatter.gridList[0]??Y;return o.computedData.map((a,p)=>{const S={type:"grid",grid:{...o.fullDataFormatter.gridList[p]??e},container:{...o.fullDataFormatter.container}},s=K(S).pipe(Z(h),L(1)),m=K(a).pipe(Z(h),L(1));return t({gridDataFormatter$:s,gridComputedData$:m,layout$:r,fullChartParams$:u,event$:g})})}))},Be=({computedData$:i,fullDataFormatter$:l,fullChartParams$:r,layout$:u})=>se({computedData:i,fullDataFormatter:l,fullChartParams:r,layout:u}).pipe(oe(async t=>t),H(t=>{const h=t.fullDataFormatter.gridList[0]??Y;return t.computedData.map((e,a)=>{const p=t.fullDataFormatter.gridList[a]??h;if(!!(p.seriesSlotIndexes&&p.seriesSlotIndexes.length===e.length))return e.map((S,s)=>{const m=p.seriesSlotIndexes[s]%t.fullDataFormatter.container.columnAmount,b=Math.floor(p.seriesSlotIndexes[s]/t.fullDataFormatter.container.columnAmount),{translate:$,scale:D}=J(t.layout,t.fullDataFormatter.container,b,m);return{slotIndex:p.seriesSlotIndexes[s],rowIndex:b,columnIndex:m,translate:$,scale:D}});{const S=p.slotIndex%t.fullDataFormatter.container.columnAmount,s=Math.floor(p.slotIndex/t.fullDataFormatter.container.columnAmount);return e.map((m,b)=>{const{translate:$,scale:D}=J(t.layout,t.fullDataFormatter.container,s,S);return{slotIndex:p.slotIndex,rowIndex:s,columnIndex:S,translate:$,scale:D}})}})})),We=({subject:i,observer:l})=>{const r=Ne({fullDataFormatter$:l.fullDataFormatter$,computedData$:l.computedData$,layout$:l.layout$,fullChartParams$:l.fullChartParams$,event$:i.event$}).pipe(L(1)),u=Be({computedData$:l.computedData$,fullDataFormatter$:l.fullDataFormatter$,fullChartParams$:l.fullChartParams$,layout$:l.layout$});return{fullParams$:l.fullParams$,fullChartParams$:l.fullChartParams$,fullDataFormatter$:l.fullDataFormatter$,computedData$:l.computedData$,layout$:l.layout$,multiGridEachDetail$:r,multiGridContainer$:u}};class ct extends Se{constructor(l,r){super({defaultDataFormatter:be,computedDataFn:je,contextObserverFn:We},l,r)}}function Xe({graphicGSelection:i,circleGClassName:l,circleClassName:r,data:u,fullParams:g,fullChartParams:t,graphicReverseScale:h}){const o=p=>{const d=p.size();return t.transitionDuration/d};let e=0;return i.each((p,d,S)=>{M(S[d]).selectAll("g").data(u[d],s=>s.id).join(s=>(e=o(s),s.append("g").classed(l,!0)),s=>s,s=>s.remove()).attr("transform",s=>`translate(${s.axisX}, ${s.axisY})`).each((s,m,b)=>{M(b[m]).selectAll("circle").data([s]).join($=>$.append("circle").style("cursor","pointer").style("vector-effect","non-scaling-stroke").classed(r,!0).attr("opacity",0).transition().delay((D,G)=>m*e).attr("opacity",1),$=>$.transition().duration(50).attr("opacity",1),$=>$.remove()).attr("r",g.radius).attr("fill",($,D)=>q({datum:$,colorType:g.fillColorType,fullChartParams:t})).attr("stroke",($,D)=>q({datum:$,colorType:g.strokeColorType,fullChartParams:t})).attr("stroke-width",g.strokeWidth).attr("transform",`scale(${h[d][0]??1}, ${h[d][1]??1})`)})}),i.selectAll(`circle.${r}`)}function Ye({selection:i,ids:l,onlyShowHighlighted:r,fullChartParams:u}){if(i.interrupt("highlight"),!l.length){i.transition("highlight").duration(200).style("opacity",r===!0?0:1);return}i.each((g,t,h)=>{l.includes(g.id)?M(h[t]).style("opacity",1).transition("highlight").duration(200):M(h[t]).style("opacity",r===!0?0:u.styles.unhighlightedOpacity).transition("highlight").duration(200)})}function Ke({defsSelection:i,clipPathData:l}){i.selectAll("clipPath").data(l).join(r=>r.append("clipPath"),r=>r,r=>r.remove()).attr("id",r=>r.id).each((r,u,g)=>{M(g[u]).selectAll("rect").data([r]).join("rect").attr("x",0).attr("y",0).attr("width",t=>t.width).attr("height",t=>t.height)})}const Ze=(i,{selection:l,computedData$:r,visibleComputedData$:u,existedSeriesLabels$:g,SeriesDataMap$:t,GroupDataMap$:h,fullParams$:o,fullChartParams$:e,gridAxesTransform$:a,gridGraphicTransform$:p,gridGraphicReverseScale$:d,gridAxesSize$:S,gridHighlight$:s,gridContainer$:m,event$:b})=>{const $=new F,D=Ee(i,"clipPath-box"),G=v(i,"circleG"),P=v(i,"circle"),R=new F,{seriesSelection$:n,axesSelection$:k,defsSelection$:_,graphicGSelection$:O}=ke({selection:l,pluginName:i,clipPathID:D,existedSeriesLabels$:g,gridContainer$:m,gridAxesTransform$:a,gridGraphicTransform$:p}),U=C({computedData:r,gridGraphicReverseScale:d}).pipe(A($),x(async c=>c),T(c=>c.computedData.map((I,y)=>c.gridGraphicReverseScale[y])));C({defsSelection:_,gridAxesSize:S}).pipe(A($),x(async c=>c)).subscribe(c=>{const I=[{id:D,width:c.gridAxesSize.width,height:c.gridAxesSize.height}];Ke({defsSelection:c.defsSelection,clipPathData:I})});const le=e.pipe(A($),T(c=>c.highlightTarget),V());C({graphicGSelection:O,computedData:r,visibleComputedData:u,SeriesDataMap:t,GroupDataMap:h,graphicReverseScale:U,fullChartParams:e,fullParams:o,highlightTarget:le}).pipe(A($),x(async c=>c)).subscribe(c=>{const I=Xe({graphicGSelection:c.graphicGSelection,circleGClassName:G,circleClassName:P,data:c.visibleComputedData,fullParams:c.fullParams,fullChartParams:c.fullChartParams,graphicReverseScale:c.graphicReverseScale});I.on("mouseover",(y,f)=>{y.stopPropagation(),b.next({type:"grid",eventName:"mouseover",pluginName:i,highlightTarget:c.highlightTarget,datum:f,series:c.SeriesDataMap.get(f.seriesLabel),seriesIndex:f.seriesIndex,seriesLabel:f.seriesLabel,groups:c.GroupDataMap.get(f.groupLabel),groupIndex:f.groupIndex,groupLabel:f.groupLabel,event:y,data:c.computedData})}).on("mousemove",(y,f)=>{y.stopPropagation(),b.next({type:"grid",eventName:"mousemove",pluginName:i,highlightTarget:c.highlightTarget,data:c.computedData,datum:f,series:c.SeriesDataMap.get(f.seriesLabel),seriesIndex:f.seriesIndex,seriesLabel:f.seriesLabel,groups:c.GroupDataMap.get(f.groupLabel),groupIndex:f.groupIndex,groupLabel:f.groupLabel,event:y})}).on("mouseout",(y,f)=>{y.stopPropagation(),b.next({type:"grid",eventName:"mouseout",pluginName:i,highlightTarget:c.highlightTarget,datum:f,series:c.SeriesDataMap.get(f.seriesLabel),seriesIndex:f.seriesIndex,seriesLabel:f.seriesLabel,groups:c.GroupDataMap.get(f.groupLabel),groupIndex:f.groupIndex,groupLabel:f.groupLabel,event:y,data:c.computedData})}).on("click",(y,f)=>{y.stopPropagation(),b.next({type:"grid",eventName:"click",pluginName:i,highlightTarget:c.highlightTarget,datum:f,series:c.SeriesDataMap.get(f.seriesLabel),seriesIndex:f.seriesIndex,seriesLabel:f.seriesLabel,groups:c.GroupDataMap.get(f.groupLabel),groupIndex:f.groupIndex,groupLabel:f.groupLabel,event:y,data:c.computedData})}),R.next(I)});const ne=s.subscribe(),ce=o.pipe(A($),T(c=>c.onlyShowHighlighted),V());return e.pipe(A($),x(c=>C({graphicSelection:R,highlight:s,onlyShowHighlighted:ce,fullChartParams:e}).pipe(A($),x(async I=>I)))).subscribe(c=>{Ye({selection:c.graphicSelection,ids:c.highlight,onlyShowHighlighted:c.onlyShowHighlighted,fullChartParams:c.fullChartParams})}),()=>{$.next(void 0),ne.unsubscribe()}},Je={position:"right",justify:"end",padding:28,backgroundFill:"none",backgroundStroke:"none",gap:10,listRectWidth:14,listRectHeight:14,listRectRadius:0,gridList:[{listRectWidth:14,listRectHeight:14,listRectRadius:0}]},qe={labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!0,axisLineColorType:"primary",tickFormat:i=>i,tickLineVisible:!0,tickPadding:20,tickFullLine:!1,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary",gridIndexes:[0]},Qe={labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!1,axisLineColorType:"primary",ticks:4,tickFormat:",.0f",tickLineVisible:!0,tickPadding:20,tickFullLine:!0,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary",gridIndexes:[0]},et={barWidth:0,barPadding:1,barGroupPadding:40,barRadius:!1,gridIndexes:[0]},ut={barWidth:0,barGroupPadding:10,barRadius:!1,gridIndexes:[0]},pt={barWidth:0,barPadding:1,barGroupPadding:20,linearGradientOpacity:[1,0],gridIndexes:[0]},tt={lineCurve:"curveLinear",lineWidth:2,gridIndexes:[1]},rt={radius:4,fillColorType:"white",strokeColorType:"series",strokeWidth:2,onlyShowHighlighted:!1,gridIndexes:[1]},gt={firstAxis:{labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!1,axisLineColorType:"primary",ticks:4,tickFormat:",.0f",tickLineVisible:!0,tickPadding:20,tickFullLine:!0,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary"},secondAxis:{labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!1,axisLineColorType:"primary",ticks:4,tickFormat:",.0f",tickLineVisible:!0,tickPadding:20,tickFullLine:!0,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary"},gridIndexes:[0,1]},Q="MultiGridLegend",dt=E(Q,Je)(({selection:i,rootSelection:l,observer:r,subject:u})=>{const g=new F,t=r.multiGridEachDetail$.pipe(A(g),T(a=>a.map((d,S)=>d.SeriesDataMap$.pipe(T(s=>Array.from(s.keys()))))),x(a=>C(a)),T(a=>a.flat())),h=C({fullParams:r.fullParams$,multiGrid:r.multiGridEachDetail$,computedData:r.computedData$}).pipe(A(g),x(async a=>a),T(a=>a.computedData.map((p,d)=>{const S=xe(a.fullParams.gridList[d]??{},{listRectWidth:a.fullParams.listRectWidth,listRectHeight:a.fullParams.listRectHeight,listRectRadius:a.fullParams.listRectRadius});return p.map(s=>S)}).flat())),o=C({fullParams:r.fullParams$,seriesList:h}).pipe(A(g),x(async a=>a),T(a=>({...a.fullParams,seriesList:a.seriesList}))),e=Oe(Q,{rootSelection:l,seriesLabels$:t,fullParams$:o,layout$:r.layout$,fullChartParams$:r.fullChartParams$});return()=>{g.next(void 0),e()}}),w=i=>{const l=i.fullParams$.pipe(T(u=>u.gridIndexes),V(),z(1)),r=new F;return l.pipe(T(u=>u.map(g=>{r.next(void 0);const t=_e(g).pipe(A(r),z(1)),h=C({computedData:i.computedData$,gridIndex:t}).pipe(A(r),T(n=>n.computedData[n.gridIndex]??n.computedData[0])),o=C({fullDataFormatter:i.fullDataFormatter$,gridIndex:t}).pipe(A(r),T(n=>{const k=n.fullDataFormatter.gridList[0];return{type:"grid",grid:{...n.fullDataFormatter.gridList[n.gridIndex]??k},container:{...n.fullDataFormatter.container}}})),e=C({multiGridEachDetail:i.multiGridEachDetail$,gridIndex:t}).pipe(A(r),x(async n=>n),T(n=>n.multiGridEachDetail[n.gridIndex]??n.multiGridEachDetail[0]),z(1)),a=e.pipe(x(n=>n.isSeriesPositionSeprate$)),p=e.pipe(x(n=>n.gridContainer$)),d=e.pipe(x(n=>n.gridAxesTransform$)),S=e.pipe(x(n=>n.gridAxesReverseTransform$)),s=e.pipe(x(n=>n.gridAxesSize$)),m=e.pipe(x(n=>n.gridGraphicTransform$)),b=e.pipe(x(n=>n.gridGraphicReverseScale$)),$=e.pipe(x(n=>n.gridHighlight$)),D=e.pipe(x(n=>n.existedSeriesLabels$)),G=e.pipe(x(n=>n.SeriesDataMap$)),P=e.pipe(x(n=>n.GroupDataMap$)),R=e.pipe(x(n=>n.visibleComputedData$));return{gridComputedData$:h,gridDataFormatter$:o,gridAxesTransform$:d,gridGraphicTransform$:m,gridGraphicReverseScale$:b,gridAxesReverseTransform$:S,gridAxesSize$:s,gridHighlight$:$,existedSeriesLabels$:D,SeriesDataMap$:G,GroupDataMap$:P,visibleComputedData$:R,isSeriesPositionSeprate$:a,gridContainer$:p}})))},j="MultiBars",ee=v(j,"grid"),$t=E(j,et)(({selection:i,name:l,subject:r,observer:u})=>{const g=new F,t=[];return w(u).subscribe(o=>{t.forEach(e=>e()),i.selectAll(`g.${ee}`).data(o).join("g").attr("class",ee).each((e,a,p)=>{const d=M(p[a]);t[a]=Ue(j,{selection:d,computedData$:e.gridComputedData$,visibleComputedData$:e.visibleComputedData$,existedSeriesLabels$:e.existedSeriesLabels$,SeriesDataMap$:e.SeriesDataMap$,GroupDataMap$:e.GroupDataMap$,fullParams$:u.fullParams$,fullChartParams$:u.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridGraphicTransform$:e.gridGraphicTransform$,gridGraphicReverseScale$:e.gridGraphicReverseScale$,gridAxesSize$:e.gridAxesSize$,gridHighlight$:e.gridHighlight$,gridContainer$:e.gridContainer$,isSeriesPositionSeprate$:e.isSeriesPositionSeprate$,event$:r.event$})})}),()=>{g.next(void 0),t.forEach(o=>o())}}),N="MultiLines",te=v(N,"grid"),mt=E(N,tt)(({selection:i,name:l,subject:r,observer:u})=>{const g=new F,t=[];return w(u).subscribe(o=>{t.forEach(e=>e()),i.selectAll(`g.${te}`).data(o).join("g").attr("class",te).each((e,a,p)=>{const d=M(p[a]);t[a]=we(N,{selection:d,computedData$:e.gridComputedData$,existedSeriesLabels$:e.existedSeriesLabels$,SeriesDataMap$:e.SeriesDataMap$,GroupDataMap$:e.GroupDataMap$,fullDataFormatter$:e.gridDataFormatter$,fullParams$:u.fullParams$,fullChartParams$:u.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridGraphicTransform$:e.gridGraphicTransform$,gridAxesSize$:e.gridAxesSize$,gridHighlight$:e.gridHighlight$,gridContainer$:e.gridContainer$,event$:r.event$})})}),()=>{g.next(void 0),t.forEach(o=>o())}}),B="MultiDots",re=v(B,"grid"),ht=E(B,rt)(({selection:i,name:l,subject:r,observer:u})=>{const g=new F,t=[];return w(u).subscribe(o=>{t.forEach(e=>e()),i.selectAll(`g.${re}`).data(o).join("g").attr("class",re).each((e,a,p)=>{const d=M(p[a]);t[a]=Ze(B,{selection:d,computedData$:e.gridComputedData$,visibleComputedData$:e.visibleComputedData$,existedSeriesLabels$:e.existedSeriesLabels$,SeriesDataMap$:e.SeriesDataMap$,GroupDataMap$:e.GroupDataMap$,fullParams$:u.fullParams$,fullChartParams$:u.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridGraphicTransform$:e.gridGraphicTransform$,gridGraphicReverseScale$:e.gridGraphicReverseScale$,gridAxesSize$:e.gridAxesSize$,gridHighlight$:e.gridHighlight$,gridContainer$:e.gridContainer$,event$:r.event$})})}),()=>{g.next(void 0),t.forEach(o=>o())}}),W="MultiGroupAxis",ae=v(W,"grid"),ft=E(W,qe)(({selection:i,name:l,subject:r,observer:u})=>{const g=new F,t=[];return w(u).subscribe(o=>{t.forEach(e=>e()),i.selectAll(`g.${ae}`).data(o).join("g").attr("class",ae).each((e,a,p)=>{const d=M(p[a]);t[a]=ze(W,{selection:d,computedData$:e.gridComputedData$,fullParams$:u.fullParams$,fullDataFormatter$:e.gridDataFormatter$,fullChartParams$:u.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridAxesReverseTransform$:e.gridAxesReverseTransform$,gridAxesSize$:e.gridAxesSize$,gridContainer$:e.gridContainer$,isSeriesPositionSeprate$:e.isSeriesPositionSeprate$})})}),()=>{g.next(void 0),t.forEach(o=>o())}}),X="MultiValueAxis",ie=v(X,"grid"),Dt=E(X,Qe)(({selection:i,name:l,subject:r,observer:u})=>{const g=new F,t=[];return w(u).subscribe(o=>{t.forEach(e=>e()),i.selectAll(`g.${ie}`).data(o).join("g").attr("class",ie).each((e,a,p)=>{const d=M(p[a]);t[a]=He(X,{selection:d,computedData$:e.gridComputedData$,fullParams$:u.fullParams$,fullDataFormatter$:e.gridDataFormatter$,fullChartParams$:u.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridAxesReverseTransform$:e.gridAxesReverseTransform$,gridAxesSize$:e.gridAxesSize$,gridContainer$:e.gridContainer$,isSeriesPositionSeprate$:e.isSeriesPositionSeprate$})})}),()=>{g.next(void 0),t.forEach(o=>o())}}),St=[[[1205,850,930,1111,1500],[735,900,880,1035,1120]],[[55,60,50,70,75],[35,40,45,65,80]]];export{ut as D,ct as M,pt as a,ft as b,Ze as c,Dt as d,$t as e,dt as f,St as g,mt as h,ht as i,gt as j,w as m};
