import{S as X,i as p,d as V,t as l,j as d,m as x,c as W,s as Y,at as H,O as G,al as J}from"./hQFDSd1w.js";import{h as C,n as K,i as I,g as M,o as Q,q as Z}from"./CrPrLvvz.js";const B=6;function _({selection:u,xAxisClassName:h,groupingLabelClassName:m,params:s,tickTextAlign:c,axisLabelAlign:k,gridAxesSize:b,fullDataFormatter:z,chartParams:n,groupScale:S,groupScaleDomain:T,groupLabels:o,textTransform:f}){const A=u.selectAll(`g.${h}`).data([s]).join("g").classed(h,!0);u.selectAll(`g.${m}`).data([s]).join("g").classed(m,!0).each((a,F,R)=>{Y(R[F]).selectAll("text").data([a]).join(g=>g.append("text").style("font-weight","bold"),g=>g,g=>g.remove()).attr("text-anchor",k.textAnchor).attr("dominant-baseline",k.dominantBaseline).attr("font-size",n.styles.textSize).style("fill",C(s.labelColorType,n)).style("transform",f).text(g=>z.grid.groupAxis.label)}).attr("transform",a=>`translate(${b.width+a.tickPadding+s.labelOffset[0]}, ${-a.tickPadding-B-s.labelOffset[1]})`);const v=Math.floor(T[1])-Math.ceil(T[0])+1,L=K(S).scale(S).ticks(s.ticks==="all"||s.ticks>v?v:s.ticks).tickSize(s.tickFullLine==!0?-b.height:B).tickSizeOuter(0).tickFormat(a=>{const F=o[a]??"";return I(F,s.tickFormat)}).tickPadding(s.tickPadding),$=A.transition().duration(100).call(L);return $.selectAll("line").style("fill","none").style("stroke",s.tickLineVisible==!0?C(s.tickColorType,n):"none").style("stroke-dasharray",s.tickFullLineDasharray).attr("pointer-events","none"),$.selectAll("path").style("fill","none").style("stroke",s.axisLineVisible==!0?C(s.axisLineColorType,n):"none").style("shape-rendering","crispEdges"),A.selectAll("text").attr("font-size",n.styles.textSize).style("color",C(s.tickTextColorType,n)).attr("text-anchor",c.textAnchor).attr("dominant-baseline",c.dominantBaseline).attr("transform-origin",`0 -${s.tickPadding+B}`).style("transform",f),A}const oe=(u,{selection:h,computedData$:m,fullParams$:s,fullDataFormatter$:c,fullChartParams$:k,gridAxesTransform$:b,gridAxesReverseTransform$:z,gridAxesSize$:n,gridContainerPosition$:S,isSeriesSeprate$:T})=>{const o=new X,f=M(u,"container"),A=M(u,"xAxisG"),v=M(u,"xAxis"),L=M(u,"groupingLabel"),$=p({computedData:m.pipe(V((e,i)=>e.length===i.length)),isSeriesSeprate:T}).pipe(l(o),d(async e=>e),x(e=>e.isSeriesSeprate?e.computedData:[e.computedData[0]]),x((e,i)=>h.selectAll(`g.${f}`).data(e,r=>r[0]?r[0].seriesIndex:i).join("g").classed(f,!0))),a=$.pipe(l(o),x((e,i)=>e.selectAll(`g.${A}`).data([A]).join("g").classed(A,!0)));p({containerSelection:$,gridContainerPosition:S}).pipe(l(o),d(async e=>e)).subscribe(e=>{e.containerSelection.attr("transform",(i,r)=>{const D=e.gridContainerPosition[r]??e.gridContainerPosition[0],y=D.translate,P=D.scale;return`translate(${y[0]}, ${y[1]}) scale(${P[0]}, ${P[1]})`})}),p({axisSelection:a,gridAxesTransform:b}).pipe(l(o),d(async e=>e)).subscribe(e=>{e.axisSelection.style("transform",e.gridAxesTransform.value)});const F=p({fullParams:s,fullDataFormatter:c,gridAxesReverseTransform:z,gridContainerPosition:S}).pipe(l(o),d(async e=>e),x(e=>{const i=`translate(${e.gridAxesReverseTransform.translate[0]}px, ${e.gridAxesReverseTransform.translate[1]}px)`,r=`rotate(${e.gridAxesReverseTransform.rotate}deg) rotateX(${e.gridAxesReverseTransform.rotateX}deg) rotateY(${e.gridAxesReverseTransform.rotateY}deg)`,D=`scale(${1/e.gridContainerPosition[0].scale[0]}, ${1/e.gridContainerPosition[0].scale[1]})`,P=`rotate(${e.fullDataFormatter.grid.groupAxis.position==="left"&&e.fullDataFormatter.grid.valueAxis.position==="top"||e.fullDataFormatter.grid.groupAxis.position==="right"&&e.fullDataFormatter.grid.valueAxis.position==="bottom"?e.fullParams.tickTextRotate+180:e.fullParams.tickTextRotate}deg)`;return`${i} ${r} ${D} ${P}`}),V()),R=p({fullDataFormatter:c,gridAxesSize:n,computedData:m}).pipe(l(o),d(async e=>e),x(e=>{const r=e.computedData[0]?e.computedData[0].length-1:0,D=e.fullDataFormatter.grid.groupAxis.scaleDomain[0]==="auto"?0-e.fullDataFormatter.grid.groupAxis.scalePadding:e.fullDataFormatter.grid.groupAxis.scaleDomain[0]-e.fullDataFormatter.grid.groupAxis.scalePadding,y=e.fullDataFormatter.grid.groupAxis.scaleDomain[1]==="auto"?r+e.fullDataFormatter.grid.groupAxis.scalePadding:e.fullDataFormatter.grid.groupAxis.scaleDomain[1]+e.fullDataFormatter.grid.groupAxis.scalePadding;return[D,y]}),W(1)),g=p({groupScaleDomain:R,gridAxesSize:n}).pipe(l(o),d(async e=>e),x(e=>H().domain(e.groupScaleDomain).range([0,e.gridAxesSize.width]))),j=m.pipe(x(e=>(e[0]??[]).map(i=>i.groupLabel))),w=p({fullDataFormatter:c,fullParams:s}).pipe(l(o),d(async e=>e),x(e=>{let i="middle",r="hanging";return e.fullDataFormatter.grid.groupAxis.position==="bottom"?(i=e.fullParams.tickTextRotate?"end":"middle",r="hanging"):e.fullDataFormatter.grid.groupAxis.position==="top"?(i=e.fullParams.tickTextRotate?"end":"middle",r="auto"):e.fullDataFormatter.grid.groupAxis.position==="left"?(i="end",r="middle"):e.fullDataFormatter.grid.groupAxis.position==="right"&&(i="start",r="middle"),{textAnchor:i,dominantBaseline:r}})),t=c.pipe(l(o),x(e=>{let i="start",r="hanging";return e.grid.groupAxis.position==="bottom"?r="hanging":e.grid.groupAxis.position==="top"?r="auto":e.grid.groupAxis.position==="left"?i="end":e.grid.groupAxis.position==="right"&&(i="start"),e.grid.valueAxis.position==="left"?i="start":e.grid.valueAxis.position==="right"?i="end":e.grid.valueAxis.position==="bottom"?r="auto":e.grid.valueAxis.position==="top"&&(r="hanging"),{textAnchor:i,dominantBaseline:r}}));return p({axisSelection:a,params:s,tickTextAlign:w,axisLabelAlign:t,gridAxesSize:n,fullDataFormatter:c,chartParams:k,groupScale:g,groupScaleDomain:R,groupLabels:j,textTransform:F}).pipe(l(o),d(async e=>e)).subscribe(e=>{_({selection:e.axisSelection,xAxisClassName:v,groupingLabelClassName:L,params:e.params,tickTextAlign:e.tickTextAlign,axisLabelAlign:e.axisLabelAlign,gridAxesSize:e.gridAxesSize,fullDataFormatter:e.fullDataFormatter,chartParams:e.chartParams,groupScale:e.groupScale,groupScaleDomain:e.groupScaleDomain,groupLabels:e.groupLabels,textTransform:e.textTransform})}),()=>{o.next(void 0)}},E=6;function N({selection:u,yAxisClassName:h,textClassName:m,fullParams:s,tickTextAlign:c,axisLabelAlign:k,gridAxesSize:b,fullDataFormatter:z,fullChartParams:n,valueScale:S,textTransform:T,minAndMax:o}){const f=u.selectAll(`g.${h}`).data([s]).join("g").classed(h,!0);u.selectAll(`g.${m}`).data([s]).join("g").classed(m,!0).each((a,F,R)=>{Y(R[F]).selectAll("text").data([a]).join(g=>g.append("text").style("font-weight","bold"),g=>g,g=>g.remove()).attr("text-anchor",k.textAnchor).attr("dominant-baseline",k.dominantBaseline).attr("font-size",n.styles.textSize).style("fill",C(s.labelColorType,n)).style("transform",T).text(g=>z.grid.valueAxis.label)}).attr("transform",a=>`translate(${-a.tickPadding+s.labelOffset[0]}, ${b.height+a.tickPadding+s.labelOffset[1]})`);const A=o[1]-o[0],v=Q(S).scale(S).ticks(A>s.ticks?s.ticks:o[0]===0&&o[1]===0?1:Math.ceil(A)).tickFormat(a=>I(a,s.tickFormat)).tickSize(s.tickFullLine==!0?-b.width:E).tickPadding(s.tickPadding),L=f.transition().duration(100).call(v);return L.selectAll("line").style("fill","none").style("stroke",s.tickLineVisible==!0?C(s.tickColorType,n):"none").style("stroke-dasharray",s.tickFullLineDasharray).attr("pointer-events","none"),L.selectAll("path").style("fill","none").style("stroke",s.axisLineVisible==!0?C(s.axisLineColorType,n):"none").style("shape-rendering","crispEdges"),f.selectAll("text").attr("font-size",n.styles.textSize).style("color",C(s.tickTextColorType,n)).attr("text-anchor",c.textAnchor).attr("dominant-baseline",c.dominantBaseline).attr("transform-origin",`-${s.tickPadding+E} 0`).style("transform",T),f}const re=(u,{selection:h,computedData$:m,fullParams$:s,fullDataFormatter$:c,fullChartParams$:k,gridAxesTransform$:b,gridAxesReverseTransform$:z,gridAxesSize$:n,gridContainerPosition$:S,isSeriesSeprate$:T})=>{const o=new X,f=M(u,"container"),A=M(u,"yAxisG"),v=M(u,"yAxis"),L=M(u,"text"),$=p({computedData:m.pipe(V((t,e)=>t.length===e.length)),isSeriesSeprate:T}).pipe(l(o),d(async t=>t),x(t=>t.isSeriesSeprate?t.computedData:[t.computedData[0]]),x((t,e)=>h.selectAll(`g.${f}`).data(t,i=>i[0]?i[0].seriesIndex:e).join("g").classed(f,!0))),a=$.pipe(l(o),x((t,e)=>t.selectAll(`g.${A}`).data([A]).join("g").classed(A,!0)));p({containerSelection:$,gridContainerPosition:S}).pipe(l(o),d(async t=>t)).subscribe(t=>{t.containerSelection.attr("transform",(e,i)=>{const r=t.gridContainerPosition[i]??t.gridContainerPosition[0],D=r.translate,y=r.scale;return`translate(${D[0]}, ${D[1]}) scale(${y[0]}, ${y[1]})`})}),p({axisSelection:a,gridAxesTransform:b}).pipe(l(o),d(async t=>t)).subscribe(t=>{t.axisSelection.style("transform",t.gridAxesTransform.value)});const F=p({fullParams:s,fullDataFormatter:c,gridAxesReverseTransform:z,gridContainerPosition:S}).pipe(l(o),d(async t=>t),x(t=>{const e=`translate(${t.gridAxesReverseTransform.translate[0]}px, ${t.gridAxesReverseTransform.translate[1]}px)`,i=`rotate(${t.gridAxesReverseTransform.rotate}deg) rotateX(${t.gridAxesReverseTransform.rotateX}deg) rotateY(${t.gridAxesReverseTransform.rotateY}deg)`,r=`scale(${1/t.gridContainerPosition[0].scale[0]}, ${1/t.gridContainerPosition[0].scale[1]})`,y=`rotate(${t.fullDataFormatter.grid.groupAxis.position==="left"&&t.fullDataFormatter.grid.valueAxis.position==="top"||t.fullDataFormatter.grid.groupAxis.position==="right"&&t.fullDataFormatter.grid.valueAxis.position==="bottom"?t.fullParams.tickTextRotate+180:t.fullParams.tickTextRotate}deg)`;return`${e} ${i} ${r} ${y}`}),V()),R=new G(t=>{p({fullDataFormatter:c,gridAxesSize:n,computedData:m}).pipe(l(o),d(async e=>e)).subscribe(e=>{const r=e.computedData[0]?e.computedData[0].length-1:0,D=e.fullDataFormatter.grid.groupAxis.scaleDomain[0]==="auto"?0-e.fullDataFormatter.grid.groupAxis.scalePadding:e.fullDataFormatter.grid.groupAxis.scaleDomain[0]-e.fullDataFormatter.grid.groupAxis.scalePadding,y=e.fullDataFormatter.grid.groupAxis.scaleDomain[1]==="auto"?r+e.fullDataFormatter.grid.groupAxis.scalePadding:e.fullDataFormatter.grid.groupAxis.scaleDomain[1]+e.fullDataFormatter.grid.groupAxis.scalePadding,P=e.computedData.map((q,ee)=>q.filter((te,O)=>O>=D&&O<=y)),U=Z(P.flat());t.next(U)})}),g=new G(t=>{p({fullDataFormatter:c,gridAxesSize:n,minAndMax:R}).pipe(l(o),d(async e=>e)).subscribe(e=>{const i=J({maxValue:e.minAndMax[1],minValue:e.minAndMax[0],axisWidth:e.gridAxesSize.height,scaleDomain:e.fullDataFormatter.grid.valueAxis.scaleDomain,scaleRange:e.fullDataFormatter.grid.valueAxis.scaleRange});t.next(i)})}),j=c.pipe(l(o),x(t=>{let e="start",i="hanging";return t.grid.valueAxis.position==="left"?(e="end",i="middle"):t.grid.valueAxis.position==="right"?(e="start",i="middle"):t.grid.valueAxis.position==="bottom"?(e="middle",i="hanging"):t.grid.valueAxis.position==="top"&&(e="middle",i="auto"),{textAnchor:e,dominantBaseline:i}})),w=c.pipe(l(o),x(t=>{let e="start",i="hanging";return t.grid.groupAxis.position==="bottom"?i="auto":t.grid.groupAxis.position==="top"?i="hanging":t.grid.groupAxis.position==="left"?e="start":t.grid.groupAxis.position==="right"&&(e="end"),t.grid.valueAxis.position==="left"?e="end":t.grid.valueAxis.position==="right"?e="start":t.grid.valueAxis.position==="bottom"?i="hanging":t.grid.valueAxis.position==="top"&&(i="auto"),{textAnchor:e,dominantBaseline:i}}));return p({axisSelection:a,fullParams:s,tickTextAlign:j,axisLabelAlign:w,computedData:m,gridAxesSize:n,fullDataFormatter:c,fullChartParams:k,valueScale:g,textTransform:F,minAndMax:R}).pipe(l(o),d(async t=>t)).subscribe(t=>{N({selection:t.axisSelection,yAxisClassName:v,textClassName:L,fullParams:t.fullParams,tickTextAlign:t.tickTextAlign,axisLabelAlign:t.axisLabelAlign,gridAxesSize:t.gridAxesSize,fullDataFormatter:t.fullDataFormatter,fullChartParams:t.fullChartParams,valueScale:t.valueScale,textTransform:t.textTransform,minAndMax:t.minAndMax})}),()=>{o.next(void 0)}};export{oe as a,re as c};
