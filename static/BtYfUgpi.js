import{e as f,h as U,S as D,t as u,m as c,b as C,c as S,i as N,d as L,j as x,k as z,s as A,l as B,n as j,o as H,p as w}from"./Bj-Bl9V3.js";import{c as O}from"./C6aT9cyB.js";import{c as V}from"./Dq5DcDzY.js";import{g as h}from"./wVpfmAyl.js";import{c as k}from"./nEOVXsd6.js";import{c as W}from"./B2yEHQn8.js";import{a as X,c as q}from"./CrfW9Y0_.js";const E="MultiGridLegend",ta=f(E,U)(({selection:o,rootSelection:m,observer:t,subject:i})=>{const s=new D,r=t.multiGridEachDetail$.pipe(u(s),c(e=>e.map((n,g)=>n.SeriesDataMap$.pipe(c(p=>Array.from(p.keys()))))),C(e=>S(e)),c(e=>e.flat())),d=S({fullParams:t.fullParams$,computedData:t.computedData$}).pipe(u(s),C(async e=>e),c(e=>e.computedData.map(($,n)=>{const g=N(e.fullParams.gridList[n]??{},{listRectWidth:e.fullParams.listRectWidth,listRectHeight:e.fullParams.listRectHeight,listRectRadius:e.fullParams.listRectRadius});return $.map(p=>g)}).flat())),l=S({fullParams:t.fullParams$,seriesList:d}).pipe(u(s),C(async e=>e),c(e=>({...e.fullParams,seriesList:e.seriesList}))),a=O(E,{rootSelection:m,seriesLabels$:r,fullParams$:l,layout$:t.layout$,fullChartParams$:t.fullChartParams$,textSizePx$:t.textSizePx$});return()=>{s.next(void 0),a()}}),P=o=>{const m=o.fullParams$.pipe(c(t=>t.gridIndexes),L(),x(1));return S({multiGridEachDetail:o.multiGridEachDetail$,gridIndexes:m}).pipe(c(t=>t.gridIndexes==="all"?t.multiGridEachDetail:t.gridIndexes.map(i=>t.multiGridEachDetail[i]??t.multiGridEachDetail[0])))},G="MultiBars",R=h(G,"grid"),ia=f(G,z)(({selection:o,name:m,subject:t,observer:i})=>{const s=new D,r=[];return P(i).pipe(u(s)).subscribe(l=>{r.forEach(a=>a()),o.selectAll(`g.${R}`).data(l).join("g").attr("class",R).each((a,e,$)=>{const n=A($[e]),g=a.dataFormatter$.pipe(u(s),c(p=>p.grid.separateSeries),L(),x(1));r[e]=V(G,{selection:n,computedData$:a.computedData$,visibleComputedData$:a.visibleComputedData$,computedLayoutData$:a.computedLayoutData$,visibleComputedLayoutData$:a.visibleComputedLayoutData$,seriesLabels$:a.seriesLabels$,SeriesDataMap$:a.SeriesDataMap$,GroupDataMap$:a.GroupDataMap$,fullParams$:i.fullParams$,fullChartParams$:i.fullChartParams$,gridAxesTransform$:a.gridAxesTransform$,gridGraphicTransform$:a.gridGraphicTransform$,gridGraphicReverseScale$:a.gridGraphicReverseScale$,gridAxesSize$:a.gridAxesSize$,gridHighlight$:a.gridHighlight$,gridContainerPosition$:a.gridContainerPosition$,isSeriesSeprate$:g,event$:t.event$})})}),()=>{s.next(void 0),r.forEach(l=>l())}}),b="MultiLines",_=h(b,"grid"),sa=f(b,B)(({selection:o,name:m,subject:t,observer:i})=>{const s=new D,r=[];return P(i).pipe(u(s)).subscribe(l=>{r.forEach(a=>a()),o.selectAll(`g.${_}`).data(l).join("g").attr("class",_).each((a,e,$)=>{const n=A($[e]);r[e]=k(b,{selection:n,computedData$:a.computedData$,computedLayoutData$:a.computedLayoutData$,visibleComputedData$:a.visibleComputedData$,visibleComputedLayoutData$:a.visibleComputedLayoutData$,seriesLabels$:a.seriesLabels$,SeriesDataMap$:a.SeriesDataMap$,GroupDataMap$:a.GroupDataMap$,fullDataFormatter$:a.dataFormatter$,fullParams$:i.fullParams$,fullChartParams$:i.fullChartParams$,gridAxesTransform$:a.gridAxesTransform$,gridGraphicTransform$:a.gridGraphicTransform$,gridAxesSize$:a.gridAxesSize$,gridHighlight$:a.gridHighlight$,gridContainerPosition$:a.gridContainerPosition$,event$:t.event$})})}),()=>{s.next(void 0),r.forEach(l=>l())}}),M="MultiDots",F=h(M,"grid"),ra=f(M,j)(({selection:o,name:m,subject:t,observer:i})=>{const s=new D,r=[];return P(i).pipe(u(s)).subscribe(l=>{r.forEach(a=>a()),o.selectAll(`g.${F}`).data(l).join("g").attr("class",F).each((a,e,$)=>{const n=A($[e]);r[e]=W(M,{selection:n,computedData$:a.computedData$,visibleComputedData$:a.visibleComputedData$,computedLayoutData$:a.computedLayoutData$,visibleComputedLayoutData$:a.visibleComputedLayoutData$,seriesLabels$:a.seriesLabels$,SeriesDataMap$:a.SeriesDataMap$,GroupDataMap$:a.GroupDataMap$,fullParams$:i.fullParams$,fullChartParams$:i.fullChartParams$,gridAxesTransform$:a.gridAxesTransform$,gridGraphicTransform$:a.gridGraphicTransform$,gridGraphicReverseScale$:a.gridGraphicReverseScale$,gridAxesSize$:a.gridAxesSize$,gridHighlight$:a.gridHighlight$,gridContainerPosition$:a.gridContainerPosition$,event$:t.event$})})}),()=>{s.next(void 0),r.forEach(l=>l())}}),T="MultiGroupAxis",v=h(T,"grid"),la=f(T,H)(({selection:o,name:m,subject:t,observer:i})=>{const s=new D,r=[];return P(i).pipe(u(s)).subscribe(l=>{r.forEach(a=>a()),o.selectAll(`g.${v}`).data(l).join("g").attr("class",v).each((a,e,$)=>{const n=A($[e]),g=a.dataFormatter$.pipe(u(s),c(p=>p.grid.separateSeries),L(),x(1));r[e]=X(T,{selection:n,computedData$:a.computedData$,fullParams$:i.fullParams$,fullDataFormatter$:a.dataFormatter$,fullChartParams$:i.fullChartParams$,gridAxesTransform$:a.gridAxesTransform$,gridAxesReverseTransform$:a.gridAxesReverseTransform$,gridAxesSize$:a.gridAxesSize$,gridContainerPosition$:a.gridContainerPosition$,isSeriesSeprate$:g})})}),()=>{s.next(void 0),r.forEach(l=>l())}}),y="MultiValueAxis",I=h(y,"grid"),oa=f(y,w)(({selection:o,name:m,subject:t,observer:i})=>{const s=new D,r=[];return P(i).pipe(u(s)).subscribe(l=>{r.forEach(a=>a()),o.selectAll(`g.${I}`).data(l).join("g").attr("class",I).each((a,e,$)=>{const n=A($[e]),g=a.dataFormatter$.pipe(u(s),c(p=>p.grid.separateSeries),L(),x(1));r[e]=q(y,{selection:n,computedData$:a.computedData$,fullParams$:i.fullParams$,fullDataFormatter$:a.dataFormatter$,fullChartParams$:i.fullChartParams$,gridAxesTransform$:a.gridAxesTransform$,gridAxesReverseTransform$:a.gridAxesReverseTransform$,gridAxesSize$:a.gridAxesSize$,gridContainerPosition$:a.gridContainerPosition$,isSeriesSeprate$:g})})}),()=>{s.next(void 0),r.forEach(l=>l())}});export{ia as M,sa as a,ra as b,ta as c,la as d,oa as e,P as m};
