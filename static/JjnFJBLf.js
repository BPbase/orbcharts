import{a as U,p as se,t as l,m as u,d as L,k as h,l as b,b as oe,aT as O,s as M,bf as ne,b8 as pe,g as ce,S as le,ac as ge}from"./DthhAFdh.js";import{o as ue}from"./07J1XIoE.js";const V=.3;function he({axisWidth:a,groupAmount:n,barGroupPadding:s=0}){const g=(n>1?a/(n-1):a)-s;return g>1?g:1}function de(a,n){return a<=1?0:n/(a-1)*V}function be(a,n){return a<=1?n:n*(1-V)}function me({graphicGSelection:a,rectClassName:n,barData:s,zeroY:i,groupLabels:g,params:p,chartParams:B,barWidth:P,transformedBarRadius:R,delayGroup:I,transitionItem:Y,isSeriesSeprate:G}){const W=P/2;return a.each((F,S,z)=>{M(z[S]).selectAll(`rect.${n}`).data(s[S]??[],o=>o.id).join(o=>o.append("rect").classed(n,!0).attr("cursor","pointer").attr("height",$=>1),o=>o,o=>o.remove()).attr("transform",(o,$)=>`translate(${(o?o.axisX:0)-W}, 0)`).attr("fill",o=>o.color).attr("y",o=>i).attr("x",o=>0).attr("width",P).attr("rx",R[S][0]??1).attr("ry",R[S][1]??1).transition().duration(Y).ease(pe(B.transitionEase)).delay((o,$)=>o.groupIndex*I).attr("y",o=>o._barStartY).attr("height",o=>Math.abs(o._barHeight)||1)}),a.selectAll(`rect.${n}`)}function xe({defsSelection:a,clipPathData:n}){a.selectAll("clipPath").data(n).join(s=>s.append("clipPath"),s=>s,s=>s.remove()).attr("id",s=>s.id).each((s,i,g)=>{M(g[i]).selectAll("rect").data([s]).join(p=>p.append("rect"),p=>p,p=>p.remove()).attr("x",0).attr("y",0).attr("width",p=>p.width).attr("height",p=>p.height)})}function De({selection:a,ids:n,fullChartParams:s}){if(a.interrupt("highlight"),!n.length){a.transition("highlight").duration(200).style("opacity",1);return}a.each((i,g,p)=>{n.includes(i.id)?M(p[g]).style("opacity",1):M(p[g]).style("opacity",s.styles.unhighlightedOpacity)})}const Se=(a,{selection:n,computedData$:s,computedAxesData$:i,visibleComputedData$:g,visibleComputedAxesData$:p,seriesLabels$:B,SeriesDataMap$:P,GroupDataMap$:R,fullParams$:I,fullDataFormatter$:Y,fullChartParams$:G,gridAxesTransform$:W,gridGraphicTransform$:v,gridGraphicReverseScale$:F,gridAxesSize$:S,gridHighlight$:z,gridContainerPosition$:o,isSeriesSeprate$:$,event$:T})=>{const c=new U,k=se(a,"clipPath-box"),K=ce(a,"rect"),{seriesSelection$:ye,axesSelection$:$e,defsSelection$:X,graphicGSelection$:q}=ue({selection:n,pluginName:a,clipPathID:k,seriesLabels$:B,gridContainerPosition$:o,gridAxesTransform$:W,gridGraphicTransform$:v}),w=p.pipe(l(c),u(e=>e[0]&&e[0][0]?e[0][0].axisY-e[0][0].axisYFromZero:0),L()),_=h({computedData:s,params:I,axisSize:S,isSeriesSeprate:$}).pipe(l(c),b(async e=>e),u(e=>e.params.barWidth?e.params.barWidth:he({axisWidth:e.axisSize.width,groupAmount:e.computedData[0]?e.computedData[0].length:0,barGroupPadding:e.params.barGroupPadding})),L()),J=h({computedData:s,barWidth:_,params:I,gridGraphicReverseScale:F}).pipe(l(c),b(async e=>e),u(e=>{const t=e.barWidth/2,r=e.params.barRadius===!0?t:e.params.barRadius===!1?0:typeof e.params.barRadius=="number"?e.params.barRadius:0;return e.computedData.map((m,d)=>{const x=e.gridGraphicReverseScale[d]??e.gridGraphicReverseScale[0],A=r*x[0],f=r*x[1];return[A,f]})})),C=g.pipe(l(c),u(e=>{const t=new Set;return e.forEach(r=>{r.forEach(m=>{t.add(m.groupLabel)})}),Array.from(t)}),oe(1)),H=G.pipe(l(c),u(e=>e.transitionDuration),L()),Q=new O(e=>{h({groupLabels:C,transitionDuration:H}).pipe(b(async t=>t)).subscribe(t=>{const r=de(t.groupLabels.length,t.transitionDuration);e.next(r)})}).pipe(l(c),L()),N=new O(e=>{h({groupLabels:C,transitionDuration:H}).pipe(b(async t=>t)).subscribe(t=>{const r=be(t.groupLabels.length,t.transitionDuration);e.next(r)})}).pipe(l(c),L()),ee=h({computedData:s,dataFormatter:Y}).pipe(l(c),b(async e=>e),u(e=>{const t=e.computedData[0]?e.computedData[0].length-1:0,r=e.dataFormatter.groupAxis.scaleDomain[0],m=e.dataFormatter.groupAxis.scaleDomain[1]==="max"?t:e.dataFormatter.groupAxis.scaleDomain[1];return[r,m]})),re=h({visibleComputedAxesData:p,groupScaleDomain:ee}).pipe(l(c),b(async e=>e),u(e=>{const t=e.groupScaleDomain[0],r=e.groupScaleDomain[1],d=e.visibleComputedAxesData.map(D=>D.filter((y,Le)=>y.groupIndex>=t&&y.groupIndex<=r)).flat();if(d.length<=1)return 1;const x=d.reduce((D,y)=>y.value>D.value?y:D,d[0]),A=x.groupIndex,f=d.filter(D=>D.groupIndex===A).reduce((D,y)=>D+y.value,0);return x.value/f})),te=h({computedAxesData:i,yRatio:re,zeroY:w}).pipe(l(c),u(e=>{let t=e.computedAxesData[0]?e.computedAxesData[0].map(()=>e.zeroY):[];return e.computedAxesData.map((r,m)=>r.map((d,x)=>{const A=t[x];let f=0;return d.visible&&(f=d.axisYFromZero*e.yRatio,t[x]=t[x]+f),{...d,_barStartY:A,_barHeight:f}}))})),ae=h({computedAxesData:i,zeroY:w}).pipe(l(c),u(e=>e.computedAxesData.map((t,r)=>t.map((m,d)=>({...m,_barStartY:e.zeroY,_barHeight:m.axisYFromZero}))))),ie=$.pipe(b(e=>ne(()=>e,ae,te)));h({defsSelection:X,gridAxesSize:S}).pipe(l(c),b(async e=>e)).subscribe(e=>{const t=[{id:k,width:e.gridAxesSize.width,height:e.gridAxesSize.height}];xe({defsSelection:e.defsSelection,clipPathData:t})});const E=G.pipe(l(c),u(e=>e.highlightTarget),L()),j=h({graphicGSelection:q,graphicData:ie,zeroY:w,groupLabels:C,params:I,chartParams:G,highlightTarget:E,barWidth:_,transformedBarRadius:J,delayGroup:Q,transitionItem:N,isSeriesSeprate:$}).pipe(l(c),b(async e=>e),u(e=>me({graphicGSelection:e.graphicGSelection,rectClassName:K,barData:e.graphicData,zeroY:e.zeroY,groupLabels:e.groupLabels,params:e.params,chartParams:e.chartParams,barWidth:e.barWidth,transformedBarRadius:e.transformedBarRadius,delayGroup:e.delayGroup,transitionItem:e.transitionItem,isSeriesSeprate:e.isSeriesSeprate})));return h({barSelection:j,computedData:s,highlightTarget:E,SeriesDataMap:P,GroupDataMap:R}).subscribe(e=>{e.barSelection.on("mouseover",(t,r)=>{t.stopPropagation(),T.next({type:"grid",eventName:"mouseover",pluginName:a,highlightTarget:e.highlightTarget,datum:r,gridIndex:r.gridIndex,series:e.SeriesDataMap.get(r.seriesLabel),seriesIndex:r.seriesIndex,seriesLabel:r.seriesLabel,group:e.GroupDataMap.get(r.groupLabel),groupIndex:r.groupIndex,groupLabel:r.groupLabel,event:t,data:e.computedData})}).on("mousemove",(t,r)=>{t.stopPropagation(),T.next({type:"grid",eventName:"mousemove",pluginName:a,highlightTarget:e.highlightTarget,datum:r,gridIndex:r.gridIndex,series:e.SeriesDataMap.get(r.seriesLabel),seriesIndex:r.seriesIndex,seriesLabel:r.seriesLabel,group:e.GroupDataMap.get(r.groupLabel),groupIndex:r.groupIndex,groupLabel:r.groupLabel,event:t,data:e.computedData})}).on("mouseout",(t,r)=>{t.stopPropagation(),T.next({type:"grid",eventName:"mouseout",pluginName:a,highlightTarget:e.highlightTarget,datum:r,gridIndex:r.gridIndex,series:e.SeriesDataMap.get(r.seriesLabel),seriesIndex:r.seriesIndex,seriesLabel:r.seriesLabel,group:e.GroupDataMap.get(r.groupLabel),groupIndex:r.groupIndex,groupLabel:r.groupLabel,event:t,data:e.computedData})}).on("click",(t,r)=>{t.stopPropagation(),T.next({type:"grid",eventName:"click",pluginName:a,highlightTarget:e.highlightTarget,datum:r,gridIndex:r.gridIndex,series:e.SeriesDataMap.get(r.seriesLabel),seriesIndex:r.seriesIndex,seriesLabel:r.seriesLabel,group:e.GroupDataMap.get(r.groupLabel),groupIndex:r.groupIndex,groupLabel:r.groupLabel,event:t,data:e.computedData})})}),h({barSelection:j,highlight:z.pipe(u(e=>e.map(t=>t.id))),fullChartParams:G}).pipe(l(c),b(async e=>e)).subscribe(e=>{De({selection:e.barSelection,ids:e.highlight,fullChartParams:e.fullChartParams})}),()=>{c.next(void 0)}},Z="StackedBars",fe={name:Z,defaultParams:ge,layerIndex:5,validator:(a,{validateColumns:n})=>n(a,{barWidth:{toBeTypes:["number"]},barGroupPadding:{toBeTypes:["number"]},barRadius:{toBeTypes:["number","boolean"]}})},Ae=le(fe)(({selection:a,name:n,subject:s,observer:i})=>{const g=new U,p=Se(Z,{selection:a,computedData$:i.computedData$,computedAxesData$:i.computedAxesData$,visibleComputedData$:i.visibleComputedData$,visibleComputedAxesData$:i.visibleComputedAxesData$,seriesLabels$:i.seriesLabels$,SeriesDataMap$:i.SeriesDataMap$,GroupDataMap$:i.GroupDataMap$,fullParams$:i.fullParams$,fullDataFormatter$:i.fullDataFormatter$,fullChartParams$:i.fullChartParams$,gridAxesTransform$:i.gridAxesTransform$,gridGraphicTransform$:i.gridGraphicTransform$,gridGraphicReverseScale$:i.gridGraphicReverseScale$,gridAxesSize$:i.gridAxesSize$,gridHighlight$:i.gridHighlight$,gridContainerPosition$:i.gridContainerPosition$,isSeriesSeprate$:i.isSeriesSeprate$,event$:s.event$});return()=>{g.next(void 0),p()}});export{Ae as S,Se as c};
