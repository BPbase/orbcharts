import{K as Y,L as ce,M as ue,E as pe,N as ge,B as de,P as me,Q as se,R as oe,T as H,U as K,V as Z,G as y,W as Q,F as $e,H as he,X as fe,I as De,Y as xe,S as R,e as P,t as T,s as b,m as A,d as V,c as M,v as E,Z as Se}from"./BpcKryD-.js";import{c as be,b as Le,d as Ae,i as ye,e as Te,f as Ge,h as Pe,j as Ce,k as Me,l as Fe,m as Re,n as Ie,a as ve}from"./4_nDscJ4.js";import{c as ke}from"./DlSMjF2j.js";import{c as _e}from"./dDdR8ly1.js";import{e as Ee,b as q,g as v,s as z}from"./fnY6dSo8.js";import{c as Oe}from"./BlQXvoyv.js";import{a as Ue,c as we}from"./Q1eIUkJd.js";import{o as ze}from"./ydwatUDO.js";function He({context:a,gridIndex:l,transposedDataGrid:i,gridSeriesLabels:p,SeriesLabelColorMap:u}){const{data:r=[],dataFormatter:h,chartParams:s,layout:e}=a;if(!r.length)return[];const t=Le(i,h,e),g=ge({transposedDataGrid:i,dataFormatter:h,chartType:"multiGrid",gridIndex:l}),d=Ae(i,h,e),x=i.map((S,m)=>d[m](0));let o=0;return i.map((S,m)=>S.map((D,G)=>{const C=de("multiGrid",l,m,G),I=g[G],c=p[m],k=d[m],_=k(D.value??0),O=x[m],U={id:D.id?D.id:C,index:o,label:D.label?D.label:C,description:D.description??"",data:D.data,value:D.value,gridIndex:l,seriesIndex:m,seriesLabel:c,groupIndex:G,groupLabel:I,color:u.get(c),axisX:t(G),axisY:_,axisYFromZero:_-O,visible:D._visible};return o++,U}))}const Ve=({data:a=[],dataFormatter:l,chartParams:i,layout:p})=>{if(!a.length)return[];let u=[];try{const r=l.gridList[0]||Y,h=a.map((o,f)=>({type:"grid",grid:{...l.gridList[f]||r},container:{...l.container}})),s=a.map((o,f)=>({data:o,dataFormatter:h[f],chartParams:i,layout:p})),e=a.map((o,f)=>be(s[f])),t=new Set(h.map(S=>S.grid.slotIndex)).size!==h.length?ce:ue,g=e.map((o,f)=>t({transposedDataGrid:o,dataFormatter:h[f],chartType:"multiGrid",gridIndex:f})),d=new Map;let x=0;g.flat().forEach((o,f)=>{if(!d.has(o)){const S=pe(x,i);d.set(o,S),x++}}),u=a.map((o,f)=>He({context:s[f],gridIndex:f,transposedDataGrid:e[f],gridSeriesLabels:g[f],SeriesLabelColorMap:d}))}catch(r){throw Error(r)}return u},je=({fullDataFormatter$:a,computedData$:l,layout$:i,fullChartParams$:p,event$:u})=>{function r({gridDataFormatter$:s,gridComputedData$:e,layout$:t,fullChartParams$:g,event$:d}){const x=ye({computedData$:e,fullDataFormatter$:s}).pipe(y(1)),o=Te({computedData$:e,fullDataFormatter$:s,fullChartParams$:g,layout$:t}).pipe(y(1)),f=Ge({fullDataFormatter$:s,layout$:t}).pipe(y(1)),S=Pe({gridAxesTransform$:f}).pipe(y(1)),m=Ce({computedData$:e,fullDataFormatter$:s,layout$:t}).pipe(y(1)),D=Me({gridContainer$:o,gridAxesTransform$:f,gridGraphicTransform$:m}),G=Fe({fullDataFormatter$:s,layout$:t}).pipe(y(1)),C=e.pipe(H(U=>U.flat())).pipe(y(1)),I=$e({datumList$:C,fullChartParams$:g,event$:d}).pipe(y(1)),c=Re({computedData$:e}),k=he({datumList$:C}).pipe(y(1)),_=fe({datumList$:C}).pipe(y(1)),O=Ie({computedData$:e}).pipe(y(1));return{isSeriesPositionSeprate$:x,gridContainer$:o,gridAxesTransform$:f,gridAxesReverseTransform$:S,gridGraphicTransform$:m,gridGraphicReverseScale$:D,gridAxesSize$:G,gridHighlight$:I,existSeriesLabels$:c,SeriesDataMap$:k,GroupDataMap$:_,visibleComputedData$:O}}const h=new me;return se({fullDataFormatter:a,computedData:l}).pipe(oe(async s=>s),H(s=>{h.next(void 0);const e=s.fullDataFormatter.gridList[0]??Y;return s.computedData.map((t,g)=>{const x={type:"grid",grid:{...s.fullDataFormatter.gridList[g]??e},container:{...s.fullDataFormatter.container}},o=K(x).pipe(Z(h),y(1)),f=K(t).pipe(Z(h),y(1));return r({gridDataFormatter$:o,gridComputedData$:f,layout$:i,fullChartParams$:p,event$:u})})}))},Ne=({computedData$:a,fullDataFormatter$:l,fullChartParams$:i,layout$:p})=>se({computedData:a,fullDataFormatter:l,fullChartParams:i,layout:p}).pipe(oe(async r=>r),H(r=>{const h=r.fullDataFormatter.gridList[0]??Y;return r.computedData.map((e,t)=>{const g=r.fullDataFormatter.gridList[t]??h;if(!!(g.seriesSlotIndexes&&g.seriesSlotIndexes.length===e.length))return e.map((x,o)=>{const f=g.seriesSlotIndexes[o]%r.fullDataFormatter.container.columnAmount,S=Math.floor(g.seriesSlotIndexes[o]/r.fullDataFormatter.container.columnAmount),{translate:m,scale:D}=Q(r.layout,r.fullDataFormatter.container,S,f);return{slotIndex:g.seriesSlotIndexes[o],rowIndex:S,columnIndex:f,translate:m,scale:D}});{const x=g.slotIndex%r.fullDataFormatter.container.columnAmount,o=Math.floor(g.slotIndex/r.fullDataFormatter.container.columnAmount);return e.map((f,S)=>{const{translate:m,scale:D}=Q(r.layout,r.fullDataFormatter.container,o,x);return{slotIndex:g.slotIndex,rowIndex:o,columnIndex:x,translate:m,scale:D}})}})})),Be=({subject:a,observer:l})=>{const i=je({fullDataFormatter$:l.fullDataFormatter$,computedData$:l.computedData$,layout$:l.layout$,fullChartParams$:l.fullChartParams$,event$:a.event$}).pipe(y(1)),p=Ne({computedData$:l.computedData$,fullDataFormatter$:l.fullDataFormatter$,fullChartParams$:l.fullChartParams$,layout$:l.layout$});return{fullParams$:l.fullParams$,fullChartParams$:l.fullChartParams$,fullDataFormatter$:l.fullDataFormatter$,computedData$:l.computedData$,layout$:l.layout$,multiGridEachDetail$:i,multiGridContainer$:p}};class ut extends De{constructor(l,i){super({defaultDataFormatter:xe,computedDataFn:Ve,contextObserverFn:Be},l,i)}}function We({graphicGSelection:a,circleGClassName:l,circleClassName:i,data:p,fullParams:u,fullChartParams:r,graphicReverseScale:h}){const s=g=>{const d=g.size();return r.transitionDuration/d};let e=0;return a.each((g,d,x)=>{M(x[d]).selectAll("g").data(p[d],o=>o.id).join(o=>(e=s(o),o.append("g").classed(l,!0)),o=>o,o=>o.remove()).attr("transform",o=>`translate(${o.axisX}, ${o.axisY})`).each((o,f,S)=>{M(S[f]).selectAll("circle").data([o]).join(m=>m.append("circle").style("cursor","pointer").style("vector-effect","non-scaling-stroke").classed(i,!0).attr("opacity",0).transition().delay((D,G)=>f*e).attr("opacity",1),m=>m.transition().duration(50).attr("opacity",1),m=>m.remove()).attr("r",u.radius).attr("fill",(m,D)=>q({datum:m,colorType:u.fillColorType,fullChartParams:r})).attr("stroke",(m,D)=>q({datum:m,colorType:u.strokeColorType,fullChartParams:r})).attr("stroke-width",u.strokeWidth).attr("transform",`scale(${h[d][0]??1}, ${h[d][1]??1})`)})}),a.selectAll(`circle.${i}`)}function Xe({selection:a,ids:l,onlyShowHighlighted:i,fullChartParams:p}){if(a.interrupt("highlight"),!l.length){a.transition("highlight").duration(200).style("opacity",i===!0?0:1);return}a.each((u,r,h)=>{l.includes(u.id)?M(h[r]).style("opacity",1).transition("highlight").duration(200):M(h[r]).style("opacity",i===!0?0:p.styles.unhighlightedOpacity).transition("highlight").duration(200)})}function Ye({defsSelection:a,clipPathData:l}){a.selectAll("clipPath").data(l).join(i=>i.append("clipPath"),i=>i,i=>i.remove()).attr("id",i=>i.id).each((i,p,u)=>{M(u[p]).selectAll("rect").data([i]).join("rect").attr("x",0).attr("y",0).attr("width",r=>r.width).attr("height",r=>r.height)})}const Ke=(a,{selection:l,computedData$:i,visibleComputedData$:p,existSeriesLabels$:u,SeriesDataMap$:r,GroupDataMap$:h,fullParams$:s,fullChartParams$:e,gridAxesTransform$:t,gridGraphicTransform$:g,gridGraphicReverseScale$:d,gridAxesSize$:x,gridHighlight$:o,gridContainer$:f,event$:S})=>{const m=new R,D=Ee(a,"clipPath-box"),G=v(a,"circleG"),C=v(a,"circle"),I=new R,{seriesSelection$:c,axesSelection$:k,defsSelection$:_,graphicGSelection$:O}=ve({selection:l,pluginName:a,clipPathID:D,existSeriesLabels$:u,gridContainer$:f,gridAxesTransform$:t,gridGraphicTransform$:g}),U=P({computedData:i,gridGraphicReverseScale:d}).pipe(T(m),b(async n=>n),A(n=>n.computedData.map((F,L)=>n.gridGraphicReverseScale[L])));P({defsSelection:_,gridAxesSize:x}).pipe(T(m),b(async n=>n)).subscribe(n=>{const F=[{id:D,width:n.gridAxesSize.width,height:n.gridAxesSize.height}];Ye({defsSelection:n.defsSelection,clipPathData:F})});const le=e.pipe(T(m),A(n=>n.highlightTarget),V());P({graphicGSelection:O,computedData:i,visibleComputedData:p,SeriesDataMap:r,GroupDataMap:h,graphicReverseScale:U,fullChartParams:e,fullParams:s,highlightTarget:le}).pipe(T(m),b(async n=>n)).subscribe(n=>{const F=We({graphicGSelection:n.graphicGSelection,circleGClassName:G,circleClassName:C,data:n.visibleComputedData,fullParams:n.fullParams,fullChartParams:n.fullChartParams,graphicReverseScale:n.graphicReverseScale});F.on("mouseover",(L,$)=>{L.stopPropagation(),S.next({type:"grid",eventName:"mouseover",pluginName:a,highlightTarget:n.highlightTarget,datum:$,gridIndex:$.gridIndex,series:n.SeriesDataMap.get($.seriesLabel),seriesIndex:$.seriesIndex,seriesLabel:$.seriesLabel,groups:n.GroupDataMap.get($.groupLabel),groupIndex:$.groupIndex,groupLabel:$.groupLabel,event:L,data:n.computedData})}).on("mousemove",(L,$)=>{L.stopPropagation(),S.next({type:"grid",eventName:"mousemove",pluginName:a,highlightTarget:n.highlightTarget,data:n.computedData,datum:$,gridIndex:$.gridIndex,series:n.SeriesDataMap.get($.seriesLabel),seriesIndex:$.seriesIndex,seriesLabel:$.seriesLabel,groups:n.GroupDataMap.get($.groupLabel),groupIndex:$.groupIndex,groupLabel:$.groupLabel,event:L})}).on("mouseout",(L,$)=>{L.stopPropagation(),S.next({type:"grid",eventName:"mouseout",pluginName:a,highlightTarget:n.highlightTarget,datum:$,gridIndex:$.gridIndex,series:n.SeriesDataMap.get($.seriesLabel),seriesIndex:$.seriesIndex,seriesLabel:$.seriesLabel,groups:n.GroupDataMap.get($.groupLabel),groupIndex:$.groupIndex,groupLabel:$.groupLabel,event:L,data:n.computedData})}).on("click",(L,$)=>{L.stopPropagation(),S.next({type:"grid",eventName:"click",pluginName:a,highlightTarget:n.highlightTarget,datum:$,gridIndex:$.gridIndex,series:n.SeriesDataMap.get($.seriesLabel),seriesIndex:$.seriesIndex,seriesLabel:$.seriesLabel,groups:n.GroupDataMap.get($.groupLabel),groupIndex:$.groupIndex,groupLabel:$.groupLabel,event:L,data:n.computedData})}),I.next(F)});const ne=s.pipe(T(m),A(n=>n.onlyShowHighlighted),V());return e.pipe(T(m),b(n=>P({graphicSelection:I,highlight:o.pipe(A(F=>F.map(L=>L.id))),onlyShowHighlighted:ne,fullChartParams:e}).pipe(T(m),b(async F=>F)))).subscribe(n=>{Xe({selection:n.graphicSelection,ids:n.highlight,onlyShowHighlighted:n.onlyShowHighlighted,fullChartParams:n.fullChartParams})}),()=>{m.next(void 0)}},Ze={position:"right",justify:"end",padding:28,backgroundFill:"none",backgroundStroke:"none",gap:10,listRectWidth:14,listRectHeight:14,listRectRadius:0,gridList:[{listRectWidth:14,listRectHeight:14,listRectRadius:0}],textColorType:"primary"},Qe={labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!0,axisLineColorType:"primary",tickFormat:a=>a,tickLineVisible:!0,tickPadding:20,tickFullLine:!1,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary",gridIndexes:[0]},qe={labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!1,axisLineColorType:"primary",ticks:4,tickFormat:",.0f",tickLineVisible:!0,tickPadding:20,tickFullLine:!0,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary",gridIndexes:[0]},Je={barWidth:0,barPadding:1,barGroupPadding:40,barRadius:!1,gridIndexes:[0]},pt={barWidth:0,barGroupPadding:10,barRadius:!1,gridIndexes:[0]},gt={barWidth:0,barPadding:1,barGroupPadding:20,linearGradientOpacity:[1,0],gridIndexes:[0]},et={lineCurve:"curveLinear",lineWidth:2,gridIndexes:[1]},dt={lineCurve:"curveLinear",linearGradientOpacity:[1,0],gridIndexes:[1]},tt={radius:4,fillColorType:"white",strokeColorType:"series",strokeWidth:2,onlyShowHighlighted:!1,gridIndexes:[1]},mt={firstAxis:{labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!1,axisLineColorType:"primary",ticks:4,tickFormat:",.0f",tickLineVisible:!0,tickPadding:20,tickFullLine:!0,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary"},secondAxis:{labelOffset:[0,0],labelColorType:"primary",axisLineVisible:!1,axisLineColorType:"primary",ticks:4,tickFormat:",.0f",tickLineVisible:!0,tickPadding:20,tickFullLine:!0,tickFullLineDasharray:"none",tickColorType:"secondary",tickTextRotate:0,tickTextColorType:"primary"},gridIndexes:[0,1]},J="MultiGridLegend",$t=E(J,Ze)(({selection:a,rootSelection:l,observer:i,subject:p})=>{const u=new R,r=i.multiGridEachDetail$.pipe(T(u),A(t=>t.map((d,x)=>d.SeriesDataMap$.pipe(A(o=>Array.from(o.keys()))))),b(t=>P(t)),A(t=>t.flat())),h=P({fullParams:i.fullParams$,multiGrid:i.multiGridEachDetail$,computedData:i.computedData$}).pipe(T(u),b(async t=>t),A(t=>t.computedData.map((g,d)=>{const x=Se(t.fullParams.gridList[d]??{},{listRectWidth:t.fullParams.listRectWidth,listRectHeight:t.fullParams.listRectHeight,listRectRadius:t.fullParams.listRectRadius});return g.map(o=>x)}).flat())),s=P({fullParams:i.fullParams$,seriesList:h}).pipe(T(u),b(async t=>t),A(t=>({...t.fullParams,seriesList:t.seriesList}))),e=ke(J,{rootSelection:l,seriesLabels$:r,fullParams$:s,layout$:i.layout$,fullChartParams$:i.fullChartParams$});return()=>{u.next(void 0),e()}}),w=a=>{const l=a.fullParams$.pipe(A(u=>u.gridIndexes),V(),z(1)),i=new R,p=a.multiGridEachDetail$.pipe(b(u=>P(u.map(r=>r.gridHighlight$))),A(u=>u.flat()),z(1));return l.pipe(A(u=>u.map(r=>{i.next(void 0);const h=ze(r).pipe(T(i),z(1)),s=P({computedData:a.computedData$,gridIndex:h}).pipe(T(i),A(c=>c.computedData[c.gridIndex]??c.computedData[0])),e=P({fullDataFormatter:a.fullDataFormatter$,gridIndex:h}).pipe(T(i),A(c=>{const k=c.fullDataFormatter.gridList[0];return{type:"grid",grid:{...c.fullDataFormatter.gridList[c.gridIndex]??k},container:{...c.fullDataFormatter.container}}})),t=P({multiGridEachDetail:a.multiGridEachDetail$,gridIndex:h}).pipe(T(i),b(async c=>c),A(c=>c.multiGridEachDetail[c.gridIndex]??c.multiGridEachDetail[0]),z(1)),g=t.pipe(b(c=>c.isSeriesPositionSeprate$)),d=t.pipe(b(c=>c.gridContainer$)),x=t.pipe(b(c=>c.gridAxesTransform$)),o=t.pipe(b(c=>c.gridAxesReverseTransform$)),f=t.pipe(b(c=>c.gridAxesSize$)),S=t.pipe(b(c=>c.gridGraphicTransform$)),m=t.pipe(b(c=>c.gridGraphicReverseScale$)),D=t.pipe(b(c=>c.existSeriesLabels$)),G=t.pipe(b(c=>c.SeriesDataMap$)),C=t.pipe(b(c=>c.GroupDataMap$)),I=t.pipe(b(c=>c.visibleComputedData$));return{gridComputedData$:s,gridDataFormatter$:e,gridAxesTransform$:x,gridGraphicTransform$:S,gridGraphicReverseScale$:m,gridAxesReverseTransform$:o,gridAxesSize$:f,gridHighlight$:p,existSeriesLabels$:D,SeriesDataMap$:G,GroupDataMap$:C,visibleComputedData$:I,isSeriesPositionSeprate$:g,gridContainer$:d}})))},j="MultiBars",ee=v(j,"grid"),ht=E(j,Je)(({selection:a,name:l,subject:i,observer:p})=>{const u=new R,r=[];return w(p).subscribe(s=>{r.forEach(e=>e()),a.selectAll(`g.${ee}`).data(s).join("g").attr("class",ee).each((e,t,g)=>{const d=M(g[t]);r[t]=_e(j,{selection:d,computedData$:e.gridComputedData$,visibleComputedData$:e.visibleComputedData$,existSeriesLabels$:e.existSeriesLabels$,SeriesDataMap$:e.SeriesDataMap$,GroupDataMap$:e.GroupDataMap$,fullParams$:p.fullParams$,fullChartParams$:p.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridGraphicTransform$:e.gridGraphicTransform$,gridGraphicReverseScale$:e.gridGraphicReverseScale$,gridAxesSize$:e.gridAxesSize$,gridHighlight$:e.gridHighlight$,gridContainer$:e.gridContainer$,isSeriesPositionSeprate$:e.isSeriesPositionSeprate$,event$:i.event$})})}),()=>{u.next(void 0),r.forEach(s=>s())}}),N="MultiLines",te=v(N,"grid"),ft=E(N,et)(({selection:a,name:l,subject:i,observer:p})=>{const u=new R,r=[];return w(p).subscribe(s=>{r.forEach(e=>e()),a.selectAll(`g.${te}`).data(s).join("g").attr("class",te).each((e,t,g)=>{const d=M(g[t]);r[t]=Oe(N,{selection:d,computedData$:e.gridComputedData$,existSeriesLabels$:e.existSeriesLabels$,SeriesDataMap$:e.SeriesDataMap$,GroupDataMap$:e.GroupDataMap$,fullDataFormatter$:e.gridDataFormatter$,fullParams$:p.fullParams$,fullChartParams$:p.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridGraphicTransform$:e.gridGraphicTransform$,gridAxesSize$:e.gridAxesSize$,gridHighlight$:e.gridHighlight$,gridContainer$:e.gridContainer$,event$:i.event$})})}),()=>{u.next(void 0),r.forEach(s=>s())}}),B="MultiDots",re=v(B,"grid"),Dt=E(B,tt)(({selection:a,name:l,subject:i,observer:p})=>{const u=new R,r=[];return w(p).subscribe(s=>{r.forEach(e=>e()),a.selectAll(`g.${re}`).data(s).join("g").attr("class",re).each((e,t,g)=>{const d=M(g[t]);r[t]=Ke(B,{selection:d,computedData$:e.gridComputedData$,visibleComputedData$:e.visibleComputedData$,existSeriesLabels$:e.existSeriesLabels$,SeriesDataMap$:e.SeriesDataMap$,GroupDataMap$:e.GroupDataMap$,fullParams$:p.fullParams$,fullChartParams$:p.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridGraphicTransform$:e.gridGraphicTransform$,gridGraphicReverseScale$:e.gridGraphicReverseScale$,gridAxesSize$:e.gridAxesSize$,gridHighlight$:e.gridHighlight$,gridContainer$:e.gridContainer$,event$:i.event$})})}),()=>{u.next(void 0),r.forEach(s=>s())}}),W="MultiGroupAxis",ie=v(W,"grid"),xt=E(W,Qe)(({selection:a,name:l,subject:i,observer:p})=>{const u=new R,r=[];return w(p).subscribe(s=>{r.forEach(e=>e()),a.selectAll(`g.${ie}`).data(s).join("g").attr("class",ie).each((e,t,g)=>{const d=M(g[t]);r[t]=Ue(W,{selection:d,computedData$:e.gridComputedData$,fullParams$:p.fullParams$,fullDataFormatter$:e.gridDataFormatter$,fullChartParams$:p.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridAxesReverseTransform$:e.gridAxesReverseTransform$,gridAxesSize$:e.gridAxesSize$,gridContainer$:e.gridContainer$,isSeriesPositionSeprate$:e.isSeriesPositionSeprate$})})}),()=>{u.next(void 0),r.forEach(s=>s())}}),X="MultiValueAxis",ae=v(X,"grid"),St=E(X,qe)(({selection:a,name:l,subject:i,observer:p})=>{const u=new R,r=[];return w(p).subscribe(s=>{r.forEach(e=>e()),a.selectAll(`g.${ae}`).data(s).join("g").attr("class",ae).each((e,t,g)=>{const d=M(g[t]);r[t]=we(X,{selection:d,computedData$:e.gridComputedData$,fullParams$:p.fullParams$,fullDataFormatter$:e.gridDataFormatter$,fullChartParams$:p.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridAxesReverseTransform$:e.gridAxesReverseTransform$,gridAxesSize$:e.gridAxesSize$,gridContainer$:e.gridContainer$,isSeriesPositionSeprate$:e.isSeriesPositionSeprate$})})}),()=>{u.next(void 0),r.forEach(s=>s())}}),bt=[[[1205,850,930,1111,1500],[735,900,880,1035,1120]],[[55,60,50,70,75],[35,40,45,65,80]]];export{pt as D,ut as M,gt as a,dt as b,Ke as c,xt as d,St as e,ht as f,$t as g,bt as h,ft as i,Dt as j,mt as k,w as m};
