import{a0 as W,a1 as na,a2 as ca,a3 as ua,a4 as ma,c as $a,a5 as pa,a6 as da,a7 as x,a8 as $,a9 as aa,aa as ta,ab as N,ac as g,ad as ga,ae as Da,af as fa,ag as ha,ah as Ga,A as Aa,ai as ba,e as P,I as La,S,t as f,m as h,p as j,o as E,aj as Pa,h as _,i as O,G as Sa,s as M,K as Ca,H as Fa,J as xa,l as Ma}from"./BDGWi0VX.js";import{a as Ta,g as ya,b as va,d as Ra,e as Ea,f as _a,s as Oa,h as Ua,i as Ia,j as za,k as Na}from"./DxfMbjbg.js";import{c as ja}from"./DYZKcGZL.js";import{c as wa}from"./CDy86HuF.js";import{g as T}from"./CQwdZll9.js";import{c as Ba}from"./BBWxnvZZ.js";import{c as Ha}from"./D5hn8ZkN.js";import{a as ka,c as Va}from"./sGy0DaUD.js";const Wa=m=>{const{data:n=[],dataFormatter:r,chartParams:i}=m;if(!n.length)return[];let s=[];try{const e=r.gridList[0]||W,d=n.map((o,c)=>r.gridList[c]||e),u=n.map((o,c)=>Ta(o,d[c])),a=r.separateGrid?u.map((o,c)=>na({transposedDataGrid:o,dataFormatterGrid:d[c],chartType:"multiGrid"})):u.map((o,c)=>ca({transposedDataGrid:o,dataFormatterGrid:d[c],chartType:"multiGrid",gridIndex:c})),t=new Map;let l=0;a.flat().forEach((o,c)=>{if(!t.has(o)){const p=ua(l,i);t.set(o,p),l++}}),s=u.map((o,c)=>{const p=a[c],G=ma({transposedDataGrid:o,dataFormatterGrid:d[c],chartType:"multiGrid",gridIndex:c});let D=0;return o.map((v,b)=>v.map((A,L)=>{const R=$a("multiGrid",c,b,L),I=G[L],C=p[b],F={id:A.id?A.id:R,index:D,label:A.label?A.label:R,description:A.description??"",data:A.data,value:A.value,gridIndex:c,seriesIndex:b,seriesLabel:C,groupIndex:L,groupLabel:I,color:t.get(C),visible:!0};return F.visible=r.visibleFilter(F,m),D++,F}))})}catch(e){throw Error(e)}return s},Xa=({fullDataFormatter$:m,computedData$:n,layout$:r,fullChartParams$:i,event$:s})=>{const e=new pa,d=da({datumList$:n.pipe(x(a=>a.flat().flat()),$(1)),fullChartParams$:i,event$:s}).pipe($(1)),u=ea({computedData$:n,fullDataFormatter$:m,layout$:r}).pipe($(1));return aa({fullDataFormatter:m,computedData:n,multiGridContainer:u}).pipe(ta(async a=>a),x(a=>{e.next(void 0);const t=a.fullDataFormatter.gridList[0]??W;return a.computedData.map((l,o)=>{const c=a.fullDataFormatter.gridList[o]??t,p={type:"grid",visibleFilter:a.fullDataFormatter.visibleFilter,grid:{...c},container:{...a.fullDataFormatter.container}},G=N(p).pipe(g(e),$(1)),D=N(l).pipe(g(e),$(1)),U=G.pipe(x(z=>z.grid.separateSeries),ga(),$(1)),v=N(a.multiGridContainer[o]).pipe(g(e),$(1)),b=ya({fullDataFormatter$:G,layout$:r}).pipe(g(e),$(1)),A=va({gridAxesTransform$:b}).pipe(g(e),$(1)),L=Ra({computedData$:D,fullDataFormatter$:G,layout$:r}).pipe(g(e),$(1)),R=Ea({gridContainerPosition$:v,gridAxesTransform$:b,gridGraphicTransform$:L}),I=_a({fullDataFormatter$:G,layout$:r}).pipe(g(e),$(1)),C=D.pipe(x(z=>z.flat())).pipe(g(e),$(1)),F=Oa({computedData$:D}).pipe(g(e),$(1)),ra=Da({datumList$:C}).pipe(g(e),$(1)),ia=fa({datumList$:C}).pipe(g(e),$(1)),sa=Ua({computedData$:D}).pipe(g(e),$(1)),X=Ia({computedData$:D,fullDataFormatter$:G,layout$:r}).pipe(g(e),$(1)),la=za({computedLayoutData$:X}).pipe(g(e),$(1)),oa=Na({computedData$:D,isSeriesSeprate$:U}).pipe($(1));return{isSeriesSeprate$:U,gridContainerPosition$:v,gridAxesTransform$:b,gridAxesReverseTransform$:A,gridGraphicTransform$:L,gridGraphicReverseScale$:R,gridAxesSize$:I,gridHighlight$:d,seriesLabels$:F,SeriesDataMap$:ra,GroupDataMap$:ia,dataFormatter$:G,computedData$:D,computedLayoutData$:X,visibleComputedData$:sa,visibleComputedLayoutData$:la,computedStackedData$:oa}})}))},ea=({computedData$:m,fullDataFormatter$:n,layout$:r})=>aa({computedData:m,fullDataFormatter:n,layout:r}).pipe(ta(async i=>i),x(i=>{const s=i.fullDataFormatter.gridList[0]??W,e=i.computedData.reduce((t,l,o)=>{const p=(i.fullDataFormatter.gridList[o]??s).separateSeries?l.length:i.fullDataFormatter.separateGrid?1:0;return t+p},0)||1,d=ha(i.layout,i.fullDataFormatter.container,e);let u=0;const a=i.computedData.map((t,l)=>{const o=i.fullDataFormatter.gridList[l]??s,c=t.map((p,G)=>{const D=d[u];return o.separateSeries&&(u+=1),D});return!o.separateSeries&&i.fullDataFormatter.separateGrid&&(u+=1),c});return console.log("gridContainerPositionArr",a),a})),Ja=({subject:m,observer:n})=>{const r=Ga(n.fullChartParams$).pipe($(1)),i=Xa({fullDataFormatter$:n.fullDataFormatter$,computedData$:n.computedData$,layout$:n.layout$,fullChartParams$:n.fullChartParams$,event$:m.event$}).pipe($(1)),s=ea({computedData$:n.computedData$,fullDataFormatter$:n.fullDataFormatter$,layout$:n.layout$});return{fullParams$:n.fullParams$,fullChartParams$:n.fullChartParams$,fullDataFormatter$:n.fullDataFormatter$,computedData$:n.computedData$,layout$:n.layout$,textSizePx$:r,multiGridContainerPosition$:s,multiGridEachDetail$:i}};class rt extends Aa{constructor(n,r){super({defaultDataFormatter:ba,computedDataFn:Wa,contextObserverFn:Ja},n,r)}}const J="MultiGridLegend",it=P(J,La)(({selection:m,rootSelection:n,observer:r,subject:i})=>{const s=new S,e=r.multiGridEachDetail$.pipe(f(s),h(t=>t.map((o,c)=>o.SeriesDataMap$.pipe(h(p=>Array.from(p.keys()))))),j(t=>E(t)),h(t=>t.flat())),d=E({fullParams:r.fullParams$,computedData:r.computedData$}).pipe(f(s),j(async t=>t),h(t=>t.computedData.map((l,o)=>{const c=Pa(t.fullParams.gridList[o]??{},{listRectWidth:t.fullParams.listRectWidth,listRectHeight:t.fullParams.listRectHeight,listRectRadius:t.fullParams.listRectRadius});return l.map(p=>c)}).flat())),u=E({fullParams:r.fullParams$,seriesList:d}).pipe(f(s),j(async t=>t),h(t=>({...t.fullParams,seriesList:t.seriesList}))),a=ja(J,{rootSelection:n,seriesLabels$:e,fullParams$:u,layout$:r.layout$,fullChartParams$:r.fullChartParams$,textSizePx$:r.textSizePx$});return()=>{s.next(void 0),a()}}),y=m=>{const n=m.fullParams$.pipe(h(r=>r.gridIndexes),_(),O(1));return E({multiGridEachDetail:m.multiGridEachDetail$,gridIndexes:n}).pipe(h(r=>r.gridIndexes==="all"?r.multiGridEachDetail:r.gridIndexes.map(i=>r.multiGridEachDetail[i]??r.multiGridEachDetail[0])))},w="MultiBars",K=T(w,"grid"),st=P(w,Sa)(({selection:m,name:n,subject:r,observer:i})=>{const s=new S,e=[];return y(i).pipe(f(s)).subscribe(u=>{e.forEach(a=>a()),m.selectAll(`g.${K}`).data(u).join("g").attr("class",K).each((a,t,l)=>{const o=M(l[t]),c=a.dataFormatter$.pipe(f(s),h(p=>p.grid.separateSeries),_(),O(1));e[t]=wa(w,{selection:o,computedData$:a.computedData$,visibleComputedData$:a.visibleComputedData$,computedLayoutData$:a.computedLayoutData$,visibleComputedLayoutData$:a.visibleComputedLayoutData$,seriesLabels$:a.seriesLabels$,SeriesDataMap$:a.SeriesDataMap$,GroupDataMap$:a.GroupDataMap$,fullParams$:i.fullParams$,fullChartParams$:i.fullChartParams$,gridAxesTransform$:a.gridAxesTransform$,gridGraphicTransform$:a.gridGraphicTransform$,gridGraphicReverseScale$:a.gridGraphicReverseScale$,gridAxesSize$:a.gridAxesSize$,gridHighlight$:a.gridHighlight$,gridContainerPosition$:a.gridContainerPosition$,isSeriesSeprate$:c,event$:r.event$})})}),()=>{s.next(void 0),e.forEach(u=>u())}}),B="MultiLines",q=T(B,"grid"),lt=P(B,Ca)(({selection:m,rootSelection:n,name:r,subject:i,observer:s})=>{const e=new S,d=[],u=s.multiGridContainerPosition$.pipe(f(e),h(t=>t.flat()));return y(s).pipe(f(e)).subscribe(t=>{d.forEach(l=>l()),m.selectAll(`g.${q}`).data(t).join("g").attr("class",q).each((l,o,c)=>{const p=M(c[o]);d[o]=Ba(B,{selection:p,computedData$:l.computedData$,computedLayoutData$:l.computedLayoutData$,visibleComputedData$:l.visibleComputedData$,visibleComputedLayoutData$:l.visibleComputedLayoutData$,seriesLabels$:l.seriesLabels$,SeriesDataMap$:l.SeriesDataMap$,GroupDataMap$:l.GroupDataMap$,fullDataFormatter$:l.dataFormatter$,fullParams$:s.fullParams$,fullChartParams$:s.fullChartParams$,gridAxesTransform$:l.gridAxesTransform$,gridGraphicTransform$:l.gridGraphicTransform$,gridAxesSize$:l.gridAxesSize$,gridHighlight$:l.gridHighlight$,gridContainerPosition$:l.gridContainerPosition$,allContainerPosition$:u,layout$:s.layout$,event$:i.event$})})}),()=>{e.next(void 0),d.forEach(t=>t())}}),H="MultiDots",Q=T(H,"grid"),ot=P(H,Fa)(({selection:m,name:n,subject:r,observer:i})=>{const s=new S,e=[];return y(i).pipe(f(s)).subscribe(u=>{e.forEach(a=>a()),m.selectAll(`g.${Q}`).data(u).join("g").attr("class",Q).each((a,t,l)=>{const o=M(l[t]);e[t]=Ha(H,{selection:o,computedData$:a.computedData$,visibleComputedData$:a.visibleComputedData$,computedLayoutData$:a.computedLayoutData$,visibleComputedLayoutData$:a.visibleComputedLayoutData$,seriesLabels$:a.seriesLabels$,SeriesDataMap$:a.SeriesDataMap$,GroupDataMap$:a.GroupDataMap$,fullParams$:i.fullParams$,fullChartParams$:i.fullChartParams$,gridAxesTransform$:a.gridAxesTransform$,gridGraphicTransform$:a.gridGraphicTransform$,gridGraphicReverseScale$:a.gridGraphicReverseScale$,gridAxesSize$:a.gridAxesSize$,gridHighlight$:a.gridHighlight$,gridContainerPosition$:a.gridContainerPosition$,event$:r.event$})})}),()=>{s.next(void 0),e.forEach(u=>u())}}),k="MultiGroupAxis",Y=T(k,"grid"),nt=P(k,xa)(({selection:m,name:n,subject:r,observer:i})=>{const s=new S,e=[];return y(i).pipe(f(s)).subscribe(u=>{e.forEach(a=>a()),m.selectAll(`g.${Y}`).data(u).join("g").attr("class",Y).each((a,t,l)=>{const o=M(l[t]),c=a.dataFormatter$.pipe(f(s),h(p=>p.grid.separateSeries),_(),O(1));e[t]=ka(k,{selection:o,computedData$:a.computedData$,fullParams$:i.fullParams$,fullDataFormatter$:a.dataFormatter$,fullChartParams$:i.fullChartParams$,gridAxesTransform$:a.gridAxesTransform$,gridAxesReverseTransform$:a.gridAxesReverseTransform$,gridAxesSize$:a.gridAxesSize$,gridContainerPosition$:a.gridContainerPosition$,isSeriesSeprate$:c})})}),()=>{s.next(void 0),e.forEach(u=>u())}}),V="MultiValueAxis",Z=T(V,"grid"),ct=P(V,Ma)(({selection:m,name:n,subject:r,observer:i})=>{const s=new S,e=[];return y(i).pipe(f(s)).subscribe(u=>{e.forEach(a=>a()),m.selectAll(`g.${Z}`).data(u).join("g").attr("class",Z).each((a,t,l)=>{const o=M(l[t]),c=a.dataFormatter$.pipe(f(s),h(p=>p.grid.separateSeries),_(),O(1));e[t]=Va(V,{selection:o,computedData$:a.computedData$,fullParams$:i.fullParams$,fullDataFormatter$:a.dataFormatter$,fullChartParams$:i.fullChartParams$,gridAxesTransform$:a.gridAxesTransform$,gridAxesReverseTransform$:a.gridAxesReverseTransform$,gridAxesSize$:a.gridAxesSize$,gridContainerPosition$:a.gridContainerPosition$,isSeriesSeprate$:c})})}),()=>{s.next(void 0),e.forEach(u=>u())}});export{st as M,ot as a,it as b,nt as c,lt as d,ct as e,rt as f,y as m};
