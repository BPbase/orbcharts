import{at as T,ax as h,bC as M,bB as B,aC as P,aD as D,aE as g,aH as A,aL as x,aB as u,aN as C,bD as L,aO as F,bK as I,bL as O,S as R,t as S,m as _,a6 as k,aQ as v,a7 as w,as as H}from"./CUAujy1K.js";import{c as U}from"./CiHcmOf_.js";import{c as z}from"./BWBub9Md.js";const V=s=>T(s,{visibleFilter:{toBeTypes:["Function"]},categoryLabels:{toBeTypes:["string[]"]}}),j=s=>{const{data:t,dataFormatter:e,chartParams:a}=s,n=M();let c=[],d=[];try{let r=[],m=[];if(t.nodes)r=t.nodes,m=t.edges;else if(t[0])r=t[0],m=t[1];else return{nodes:[],edges:[]};const f=(()=>{const o=new Set(e.categoryLabels);for(let l of r){const i=l.categoryLabel??n;o.add(i)}for(let l of m){const i=l.categoryLabel??n;o.add(i)}return Array.from(o)})(),$=new Map(f.map((o,l)=>[o,l]));c=r.map((o,l)=>{const i=o.categoryLabel??n,y=$.get(i)??0,b={id:o.id,index:l,label:o.label??"",description:o.description??"",data:o.data??{},value:o.value??0,categoryIndex:y,categoryLabel:i,color:h(y,a),visible:!0};return b.visible=e.visibleFilter(b,s),b});const p=new Map(c.map(o=>[o.id,o]));d=m.map((o,l)=>{const i=p.get(o.start),y=p.get(o.end);return{edge:o,startNode:i,endNode:y}}).filter(({edge:o})=>{const l=p.get(o.start),i=p.get(o.end);return l!=null&&i!=null}).map(({edge:o,startNode:l,endNode:i},y)=>{const b=o.categoryLabel??n;return{id:o.id,index:y,label:o.label??"",description:o.description??"",data:o.data??{},value:o.value??0,categoryIndex:$.get(b),categoryLabel:b,color:h(y,a),startNode:l,endNode:i,visible:l.visible&&i.visible}})}catch(r){throw Error(r)}return{nodes:c,edges:d}},W=s=>T({data:s},{data:{toBe:"DataRelationshipObj | DataRelationshipList",test:e=>B(e)||Array.isArray(e)}}),J=(s,t)=>P({CategoryNodeMap:s,CategoryEdgeMap:t}).pipe(D(async e=>e),g(e=>[...Array.from(e.CategoryNodeMap.keys()),...Array.from(e.CategoryEdgeMap.keys())]),A((e,a)=>JSON.stringify(e)===JSON.stringify(a))),X=s=>s.pipe(g(t=>{const e=new Map;return t.nodes.forEach(a=>{e.set(a.id,a)}),e})),Y=s=>s.pipe(g(t=>{const e=new Map;return t.edges.forEach(a=>{e.set(a.id,a)}),e})),G=({computedData$:s,NodeMap$:t})=>P({computedData:s,NodeMap:t}).pipe(D(async e=>e),g(e=>({nodes:e.computedData.nodes.filter(a=>a.visible),edges:e.computedData.edges.filter(a=>a.visible).filter(a=>e.NodeMap.has(a.startNode.id)&&e.NodeMap.has(a.endNode.id))}))),K=({subject:s,observer:t})=>{const e=x(t.fullChartParams$).pipe(u(1)),a=C({datumList$:t.computedData$.pipe(g(p=>p.nodes)),fullChartParams$:t.fullChartParams$,event$:s.event$}).pipe(u(1)),n=C({datumList$:t.computedData$.pipe(g(p=>p.edges)),fullChartParams$:t.fullChartParams$,event$:s.event$}).pipe(u(1)),c=L({datumList$:t.computedData$.pipe(g(p=>p.nodes))}).pipe(u(1)),d=L({datumList$:t.computedData$.pipe(g(p=>p.edges))}).pipe(u(1)),r=X(t.computedData$).pipe(u(1)),m=Y(t.computedData$).pipe(u(1)),f=J(c,d).pipe(u(1)),$=G({computedData$:t.computedData$,NodeMap$:r}).pipe(u(1));return{fullParams$:t.fullParams$,fullChartParams$:t.fullChartParams$,fullDataFormatter$:t.fullDataFormatter$,computedData$:t.computedData$,layout$:t.layout$,textSizePx$:e,relationshipHighlightNodes$:a,relationshipHighlightEdges$:n,categoryLabels$:f,CategoryNodeMap$:c,CategoryEdgeMap$:d,NodeMap$:r,EdgeMap$:m,visibleComputedData$:$}};class ot extends F{constructor(t,e){super({defaultDataFormatter:I,dataFormatterValidator:V,computedDataFn:j,dataValidator:W,contextObserverCallback:K},t,e)}}const N="RelationshipLegend",Q={name:N,defaultParams:k,layerIndex:v,validator:(s,{validateColumns:t})=>t(s,{placement:{toBe:'"top" | "top-start" | "top-end" | "bottom" | "bottom-start" | "bottom-end" | "left" | "left-start" | "left-end" | "right" | "right-start" | "right-end"',test:a=>["top","top-start","top-end","bottom","bottom-start","bottom-end","left","left-start","left-end","right","right-start","right-end"].includes(a)},padding:{toBeTypes:["number"]},backgroundFill:{toBeOption:"ColorType"},backgroundStroke:{toBeOption:"ColorType"},gap:{toBeTypes:["number"]},listRectWidth:{toBeTypes:["number"]},listRectHeight:{toBeTypes:["number"]},listRectRadius:{toBeTypes:["number"]},textColorType:{toBeOption:"ColorType"}})},st=O(Q)(({selection:s,rootSelection:t,observer:e,subject:a})=>{const n=new R,c=e.fullParams$.pipe(S(n),_(r=>{const m=[{listRectWidth:r.listRectWidth,listRectHeight:r.listRectHeight,listRectRadius:r.listRectRadius}];return{...r,labelList:m}})),d=U(N,{rootSelection:t,legendLabels$:e.categoryLabels$,fullParams$:c,layout$:e.layout$,fullChartParams$:e.fullChartParams$,textSizePx$:e.textSizePx$});return()=>{n.next(void 0),d()}}),E="RelationshipTooltip",q={name:E,defaultParams:w,layerIndex:H,validator:(s,{validateColumns:t})=>t(s,{backgroundColorType:{toBeOption:"ColorType"},backgroundOpacity:{toBeTypes:["number"]},strokeColorType:{toBeOption:"ColorType"},offset:{toBe:"[number, number]",test:a=>Array.isArray(a)&&a.length===2&&typeof a[0]=="number"&&typeof a[1]=="number"},padding:{toBeTypes:["number"]},textColorType:{toBeOption:"ColorType"},renderFn:{toBeTypes:["Function"]}})},rt=O(q)(({selection:s,rootSelection:t,name:e,subject:a,observer:n})=>{const c=new R,d=z(E,{rootSelection:t,fullParams$:n.fullParams$,fullChartParams$:n.fullChartParams$,layout$:n.layout$,event$:a.event$});return()=>{c.next(void 0),d()}});export{st as R,rt as a,ot as b};
