import{c as y,aw as F,a3 as P,a7 as p,ad as C,a9 as D,aa as d,ax as b,ah as g,a8 as u,a6 as L,ae as O,A as v,ay as x}from"./B90BryHn.js";const A=n=>{const{data:e=[],dataFormatter:a,chartParams:i}=n;if(!e.length)return[];let r=[];try{const l=(t,s,c,o)=>{const m=y(a.type,s,c),$=a.seriesLabels[s]||F("series",s),f=P(s,i);return typeof t=="number"?{id:m,index:o,seq:0,label:m,description:"",data:{},value:t,seriesIndex:s,seriesLabel:$,color:f,visible:!0}:{id:t.id?t.id:m,index:o,seq:0,label:t.label?t.label:m,description:t.description,data:t.data??{},value:t.value,seriesIndex:s,seriesLabel:$,color:f,visible:!0}};r=e.map((t,s)=>Array.isArray(t)?t.map((c,o)=>l(c,s,o,r.length+o)):l(t,s,0,r.length)).flat().sort(a.sort??void 0).map((t,s)=>(t.seq=s,t)).map(t=>(t.visible=a.visibleFilter(t,n),t)).sort((t,s)=>t.index-s.index).reduce((t,s)=>(t[s.seriesIndex]||(t[s.seriesIndex]=[]),t[s.seriesIndex].push(s),t),[])}catch(l){throw Error(l)}return r},M=({fullDataFormatter$:n})=>n.pipe(p(e=>e.separateSeries),C()),q=({computedData$:n})=>n.pipe(p(e=>e.filter(a=>a.length).map(a=>a[0].seriesLabel)),C((e,a)=>JSON.stringify(e).length===JSON.stringify(a).length)),h=({computedData$:n})=>n.pipe(p(e=>e.map(a=>a.filter(i=>i.visible!=!1)))),w=({computedData$:n,fullDataFormatter$:e})=>D({computedData:n,fullDataFormatter:e}).pipe(d(async a=>a),p(a=>{const i=a.fullDataFormatter.sumSeries==!0?a.computedData.map(r=>[r.reduce((l,t)=>l==null?t:(l.value=l.value+t.value,l),null)]):a.computedData;return a.fullDataFormatter.separateSeries==!0?i.map(r=>r.sort((l,t)=>l.seq-t.seq)):[i.flat().sort((r,l)=>r.seq-l.seq)]})),E=({computedData$:n,fullDataFormatter$:e,layout$:a})=>D({computedData:n,fullDataFormatter:e,layout:a}).pipe(d(async r=>r),p(r=>r.fullDataFormatter.separateSeries?b(r.layout,r.fullDataFormatter.container,r.computedData.length):b(r.layout,r.fullDataFormatter.container,1))),R=({seriesContainerPosition$:n,seriesLabels$:e,separateSeries$:a})=>D({seriesContainerPosition:n,seriesLabels:e,separateSeries:a}).pipe(d(async i=>i),p(i=>i.separateSeries?new Map(i.seriesLabels.map((r,l)=>[r,i.seriesContainerPosition[l]??i.seriesContainerPosition[0]])):new Map(i.seriesLabels.map((r,l)=>[r,i.seriesContainerPosition[0]])))),T=({subject:n,observer:e})=>{const a=g(e.fullChartParams$).pipe(u(1)),i=M({fullDataFormatter$:e.fullDataFormatter$}),r=h({computedData$:e.computedData$}),l=w({computedData$:e.computedData$,fullDataFormatter$:e.fullDataFormatter$}).pipe(u(1)),t=h({computedData$:l}),s=e.computedData$.pipe(p(S=>S.flat())).pipe(u(1)),c=L({datumList$:s,fullChartParams$:e.fullChartParams$,event$:n.event$}).pipe(u(1)),o=q({computedData$:e.computedData$}),m=O({datumList$:s}).pipe(u(1)),$=E({computedData$:e.computedData$,fullDataFormatter$:e.fullDataFormatter$,layout$:e.layout$}).pipe(u(1)),f=R({seriesContainerPosition$:$,seriesLabels$:o,separateSeries$:i}).pipe(u(1));return{fullParams$:e.fullParams$,fullChartParams$:e.fullChartParams$,fullDataFormatter$:e.fullDataFormatter$,computedData$:e.computedData$,layout$:e.layout$,textSizePx$:a,visibleComputedData$:r,visibleComputedLayoutData$:t,separateSeries$:i,computedLayoutData$:l,seriesHighlight$:c,seriesLabels$:o,SeriesDataMap$:m,seriesContainerPosition$:$,SeriesContainerPositionMap$:f}};class z extends v{constructor(e,a){super({defaultDataFormatter:x,computedDataFn:A,contextObserverFn:T},e,a)}}export{z as S};
