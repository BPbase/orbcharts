import{ak as M,al as w,ai as $,ag as Y,aX as X,ao as R,ap as U,as as z,aY as J,aZ as E,a_ as Z,au as q,a$ as B,ay as K,aw as Q,b0 as _,m as h,c as P,k as S,l as A,b as I,s as O,S as ee,aE as te,t as re,b1 as H}from"./CJz0rwbW.js";import{c as V,d as ae}from"./DmmhaqEO.js";import{g as T}from"./D7qTWgnP.js";const ce=({computedData$:g,fullDataFormatter$:i,layout$:o})=>{function r(t,l,s){const a=l.grid.groupAxis.position==="top"||l.grid.groupAxis.position==="bottom"?s.width:s.height,c=t[0]?t[0].length-1:0;return V({maxValue:c,minValue:0,axisWidth:a,scaleDomain:[0,c],scaleRange:[0,1]})}function n(t,l,s){const a=l.grid.valueAxis.position==="left"||l.grid.valueAxis.position==="right"?s.height:s.width,c=t.flat(),[f,d]=Z(c);return V({maxValue:d,minValue:f,axisWidth:a,scaleDomain:["auto","auto"],scaleRange:[0,1]})}return M({computedData:g,fullDataFormatter:i,layout:o}).pipe(w(async t=>t),$(t=>{const l=r(t.computedData,t.fullDataFormatter,t.layout),s=n(t.computedData,t.fullDataFormatter,t.layout),a=s(0);return t.computedData.map((c,f)=>c.map((d,u)=>{const m=l(u),p=s(d.value??0);return{...d,axisX:m,axisY:p,axisYFromZero:p-a}}))}))},pe=({fullDataFormatter$:g,layout$:i})=>{const o=new Y;function r({xAxisPosition:n,yAxisPosition:t,width:l,height:s}){return(n==="bottom"||n==="top")&&(t==="left"||t==="right")?{width:l,height:s}:(n==="left"||n==="right")&&(t==="bottom"||t==="top")?{width:s,height:l}:{width:l,height:s}}return new X(n=>{M({fullDataFormatter:g,layout:i}).pipe(R(o),w(async t=>t)).subscribe(t=>{const l=r({xAxisPosition:t.fullDataFormatter.grid.groupAxis.position,yAxisPosition:t.fullDataFormatter.grid.valueAxis.position,width:t.layout.width,height:t.layout.height});return n.next(l),function(){o.next(void 0)}})})},ge=({computedData$:g})=>g.pipe($(i=>i.filter(o=>o.length).map(o=>o[0].seriesLabel)),U((i,o)=>JSON.stringify(i).length===JSON.stringify(o).length)),me=({computedData$:g})=>g.pipe($(i=>i.map(r=>r.filter(n=>n.visible==!0)).filter(r=>r.length))),de=({computedLayoutData$:g})=>g.pipe($(i=>i.map(r=>r.filter(n=>n.visible==!0)).filter(r=>r.length))),fe=({computedData$:g,fullDataFormatter$:i,layout$:o})=>M({computedData:g,fullDataFormatter:i,layout:o}).pipe(w(async n=>n),$(n=>{if(n.fullDataFormatter.grid.separateSeries)return z(n.layout,n.fullDataFormatter.container,n.computedData.length);{const t=z(n.layout,n.fullDataFormatter.container,1);return n.computedData.map((l,s)=>t[0])}})),xe=({isSeriesSeprate$:g,computedData$:i})=>{const o=i.pipe($(r=>{const n=new Array(r[0]?r[0].length:0).fill(null).map((l,s)=>r.reduce((a,c)=>{if(c&&c[s]){const f=c[s].value==null||c[s].visible==!1?0:c[s].value;return a+f}return a},0));return r.map((l,s)=>l.map((a,c)=>({...a,value:n[c]})))}));return g.pipe(w(r=>J(()=>r,i,o)))},be=({computedData$:g,fullDataFormatter$:i})=>M({computedData:g,fullDataFormatter:i}).pipe(w(async o=>o),$(o=>{const r=o.fullDataFormatter.grid.groupAxis,n=o.computedData[0]?o.computedData[0].length-1:0,t=r.scaleDomain[0]-r.scalePadding,l=r.scaleDomain[1]==="max"?n+r.scalePadding:r.scaleDomain[1]+r.scalePadding;return[t,l]})),De=({computedData$:g,groupScaleDomainValue$:i})=>M({computedData:g,groupScaleDomainValue:i}).pipe($(o=>{const r=o.computedData.map((t,l)=>t.filter((s,a)=>a>=o.groupScaleDomainValue[0]&&a<=o.groupScaleDomainValue[1]&&s.visible==!0));return E(r)})),he=({fullDataFormatter$:g,layout$:i})=>{const o=new Y;function r({xAxis:n,yAxis:t,width:l,height:s}){if(!n||!t)return{translate:[0,0],scale:[1,1],rotate:0,rotateX:0,rotateY:0,value:""};let a=0,c=0,f=0,d=0,u=0;return n.position==="bottom"?t.position==="left"?(d=180,c=s):t.position==="right"?(d=180,u=180,a=l,c=s):(d=180,c=s):n.position==="top"?t.position==="left"||(t.position==="right"?(u=180,a=l):(d=180,c=s)):n.position==="left"?t.position==="bottom"?(f=-90,c=s):t.position==="top"?(f=-90,u=180):(d=180,c=s):n.position==="right"?t.position==="bottom"?(f=-90,d=180,c=s,a=l):t.position==="top"?(f=-90,d=180,u=180,a=l):(d=180,c=s):(d=180,c=s),{translate:[a,c],scale:[1,1],rotate:f,rotateX:d,rotateY:u,value:`translate(${a}px, ${c}px) rotate(${f}deg) rotateX(${d}deg) rotateY(${u}deg)`}}return new X(n=>(M({fullDataFormatter:g,layout:i}).pipe(R(o),w(async t=>t)).subscribe(t=>{const l=r({xAxis:t.fullDataFormatter.grid.groupAxis,yAxis:t.fullDataFormatter.grid.valueAxis,width:t.layout.width,height:t.layout.height});n.next(l)}),function(){o.next(void 0)}))},ve=({gridAxesTransform$:g})=>g.pipe($(i=>{const o=[0,0],r=[1/i.scale[0],1/i.scale[1]],n=i.rotate*-1,t=i.rotateX*-1,l=i.rotateY*-1;return{translate:o,scale:r,rotate:n,rotateX:t,rotateY:l,value:`translate(${o[0]}px, ${o[1]}px) rotateX(${t}deg) rotateY(${l}deg) rotate(${n}deg)`}})),Se=({computedData$:g,groupScaleDomainValue$:i,filteredMinMaxValue$:o,fullDataFormatter$:r,layout$:n})=>{const t=new Y;function l({data:s,groupAxis:a,valueAxis:c,groupScaleDomainValue:f,filteredMinMaxValue:d,width:u,height:m}){let p=0,x=0,v=0,F=0;const e=a.position==="top"||a.position==="bottom"?u:m,b=0,D=s[0]?s[0].length-1:0,y=V({maxValue:D,minValue:b,axisWidth:e,scaleDomain:f,scaleRange:[0,1]}),L=y(b),G=y(D);b==D?(p=0,v=1):(p=L,v=(G-L)/e);const W=c.position==="left"||c.position==="right"?m:u,j=V({maxValue:d[1],minValue:d[0],axisWidth:W,scaleDomain:c.scaleDomain,scaleRange:c.scaleRange}),C=E(s);C[0]===C[1]&&(C[0]=C[1]-1);const k=j(C[0]>0?0:C[0]),N=j(C[1]<0?0:C[1]);return x=k,F=(N-k)/W,{translate:[p,x],scale:[v,F],rotate:0,rotateX:0,rotateY:0,value:`translate(${p}px, ${x}px) scale(${v}, ${F})`}}return new X(s=>(M({computedData:g,groupScaleDomainValue:i,filteredMinMaxValue:o,fullDataFormatter:r,layout:n}).pipe(R(t),w(async a=>a)).subscribe(a=>{const c=l({data:a.computedData,groupAxis:a.fullDataFormatter.grid.groupAxis,valueAxis:a.fullDataFormatter.grid.valueAxis,groupScaleDomainValue:a.groupScaleDomainValue,filteredMinMaxValue:a.filteredMinMaxValue,width:a.layout.width,height:a.layout.height});s.next(c)}),function(){t.next(void 0)}))},Ae=({gridContainerPosition$:g,gridAxesTransform$:i,gridGraphicTransform$:o})=>M({gridContainerPosition:g,gridAxesTransform:i,gridGraphicTransform:o}).pipe(w(async r=>r),$(r=>r.gridAxesTransform.rotate==0||r.gridAxesTransform.rotate==180?r.gridContainerPosition.map((n,t)=>[1/r.gridGraphicTransform.scale[0]/r.gridContainerPosition[t].scale[0],1/r.gridGraphicTransform.scale[1]/r.gridContainerPosition[t].scale[1]]):r.gridContainerPosition.map((n,t)=>[1/r.gridGraphicTransform.scale[0]/r.gridContainerPosition[t].scale[1],1/r.gridGraphicTransform.scale[1]/r.gridContainerPosition[t].scale[0]])));function oe(g,i){if(!g.length)return[];try{const o=g.reduce((l,s)=>s.length>l?s.length:l,0),n=g.map((l,s)=>{if(l.length===o)return l;const a=Object.assign([],l);for(let c=a.length;c<o;c++)a[c]=null;return a}).map((l,s)=>l.map((a,c)=>a==null?{id:"",label:"",data:{},value:null}:typeof a=="number"?{id:"",label:"",data:{},value:a}:{id:a.id??"",label:a.label??"",data:a.data??{},value:a.value}));return _(i.seriesDirection,n)}catch{return[]}}const ye=g=>{const{data:i=[],dataFormatter:o,chartParams:r}=g;if(!i.length)return[];let n;try{const t=oe(i,o.grid),l=q({transposedDataGrid:t,dataFormatterGrid:o.grid,chartType:"grid"}),s=B({transposedDataGrid:t,dataFormatterGrid:o.grid,chartType:"grid"});let a=0;n=t.map((c,f)=>c.map((d,u)=>{const m=K("grid",0,f,u),p=s[u],x={id:d.id?d.id:m,index:a,label:d.label?d.label:m,description:d.description??"",data:d.data,value:d.value,gridIndex:0,seriesIndex:f,seriesLabel:l[f],groupIndex:u,groupLabel:p,color:Q(f,r),visible:!0};return x.visible=o.visibleFilter(x,g),a++,x}))}catch(t){throw Error(t)}return n},Fe=({selection:g,pluginName:i,clipPathID:o,seriesLabels$:r,gridContainerPosition$:n,gridAxesTransform$:t,gridGraphicTransform$:l})=>{const s=T(i,"series"),a=T(i,"axes"),c=T(i,"graphic"),f=r.pipe(h((p,x)=>g.selectAll(`g.${s}`).data(p,v=>v).join(v=>v.append("g").classed(s,!0).each((F,e,b)=>{O(b[e]).selectAll(`g.${a}`).data([e]).join(D=>D.append("g").classed(a,!0).attr("clip-path",`url(#${o})`).each((y,L,G)=>{O(G[L]).selectAll("defs").data([L]).join("defs"),O(G[L]).selectAll("g").data([L]).join("g").classed(c,!0)}),D=>D,D=>D.remove())}),v=>v,v=>v.remove())),P(1));S({seriesSelection:f,gridContainerPosition:n}).pipe(A(async p=>p)).subscribe(p=>{p.seriesSelection.transition().attr("transform",(x,v)=>{const F=p.gridContainerPosition[v]??p.gridContainerPosition[0],e=F.translate,b=F.scale;return`translate(${e[0]}, ${e[1]}) scale(${b[0]}, ${b[1]})`})});const d=S({seriesSelection:f,gridAxesTransform:t}).pipe(A(async p=>p),h(p=>p.seriesSelection.select(`g.${a}`).style("transform",p.gridAxesTransform.value)),P(1)),u=d.pipe(h(p=>p.select("defs")),P(1)),m=S({axesSelection:d,gridGraphicTransform:l}).pipe(A(async p=>p),h(p=>{const x=p.axesSelection.select(`g.${c}`);return x.transition().duration(50).style("transform",p.gridGraphicTransform.value),x}),P(1));return{seriesSelection$:f,axesSelection$:d,defsSelection$:u,graphicGSelection$:m}},$e=({fullDataFormatter$:g,gridAxesSize$:i,computedData$:o,fullChartParams$:r,gridContainerPosition$:n,layout$:t})=>{const l=new ee,s=S({fullDataFormatter:g,gridAxesSize:i,computedData:o}).pipe(A(async u=>u),h(u=>{const m=u.computedData[0]?u.computedData[0].length-1:0,p=u.fullDataFormatter.grid.groupAxis.scaleDomain[0]-u.fullDataFormatter.grid.groupAxis.scalePadding,x=u.fullDataFormatter.grid.groupAxis.scaleDomain[1]==="max"?m+u.fullDataFormatter.grid.groupAxis.scalePadding:u.fullDataFormatter.grid.groupAxis.scaleDomain[1]+u.fullDataFormatter.grid.groupAxis.scalePadding;return[p,x]}),P(1)),a=S({fullDataFormatter:g,computedData:o}).pipe(A(async u=>u),h(u=>u.fullDataFormatter.grid.seriesDirection==="row"?(u.computedData[0]??[]).map(m=>m.groupLabel):u.computedData.map(m=>m[0].groupLabel))),c=S({groupScaleDomain:s,groupLabels:a}).pipe(A(async u=>u),h(u=>u.groupLabels.filter((m,p)=>p>=u.groupScaleDomain[0]&&p<=u.groupScaleDomain[1]))),f=n.pipe(h(u=>u.reduce((p,x)=>x.columnIndex>p?x.columnIndex:p,0)+1),I()),d=n.pipe(h(u=>u.reduce((p,x)=>x.rowIndex>p?x.rowIndex:p,0)+1),I());return new te(u=>{S({dataFormatter:g,axisSize:i,fullChartParams:r,scaleRangeGroupLabels:c,groupLabels:a,groupScaleDomain:s,columnAmount:f,rowAmount:d,layout:t}).pipe(re(l),A(async m=>m)).subscribe(m=>{const p=m.dataFormatter.grid.valueAxis.position==="right"||m.dataFormatter.grid.valueAxis.position==="bottom",x=H({axisLabels:m.scaleRangeGroupLabels,axisWidth:m.axisSize.width,padding:m.dataFormatter.grid.groupAxis.scalePadding,reverse:p}),v=e=>m.dataFormatter.grid.groupAxis.position==="bottom"||m.dataFormatter.grid.groupAxis.position==="top"?e.offsetX-m.fullChartParams.padding.left:e.offsetY-m.fullChartParams.padding.top,F=e=>{const b={offsetX:e.offsetX*m.columnAmount%m.layout.rootWidth,offsetY:e.offsetY*m.rowAmount%m.layout.rootHeight},D=v(b),y=x(D),L=Math.ceil(m.groupScaleDomain[0]),G=y+L;return{groupIndex:G,groupLabel:m.groupLabels[G]??""}};return u.next(F),function(){l.next(void 0)}})})},Le=({rootSelection:g,fullDataFormatter$:i,gridAxesSize$:o,computedData$:r,fullChartParams$:n,gridContainerPosition$:t,layout$:l})=>{const s=ae(g,"mousemove"),a=S({fullDataFormatter:i,gridAxesSize:o,computedData:r}).pipe(A(async e=>e),h(e=>{const b=e.computedData[0]?e.computedData[0].length-1:0,D=e.fullDataFormatter.grid.groupAxis.scaleDomain[0]-e.fullDataFormatter.grid.groupAxis.scalePadding,y=e.fullDataFormatter.grid.groupAxis.scaleDomain[1]==="max"?b+e.fullDataFormatter.grid.groupAxis.scalePadding:e.fullDataFormatter.grid.groupAxis.scaleDomain[1]+e.fullDataFormatter.grid.groupAxis.scalePadding;return[D,y]}),P(1)),c=S({fullDataFormatter:i,computedData:r}).pipe(A(async e=>e),h(e=>e.fullDataFormatter.grid.seriesDirection==="row"?(e.computedData[0]??[]).map(b=>b.groupLabel):e.computedData.map(b=>b[0].groupLabel))),f=S({groupScaleDomain:a,groupLabels:c}).pipe(A(async e=>e),h(e=>e.groupLabels.filter((b,D)=>D>=e.groupScaleDomain[0]&&D<=e.groupScaleDomain[1]))),d=i.pipe(h(e=>e.grid.valueAxis.position==="right"||e.grid.valueAxis.position==="bottom")),u=S({reverse:d,gridAxesSize:o,scaleRangeGroupLabels:f,fullDataFormatter:i}).pipe(A(async e=>e),h(e=>H({axisLabels:e.scaleRangeGroupLabels,axisWidth:e.gridAxesSize.width,padding:e.fullDataFormatter.grid.groupAxis.scalePadding,reverse:e.reverse}))),m=t.pipe(h(e=>e.reduce((D,y)=>y.columnIndex>D?y.columnIndex:D,0)+1),I()),p=t.pipe(h(e=>e.reduce((D,y)=>y.rowIndex>D?y.rowIndex:D,0)+1),I()),x=S({fullDataFormatter:i,fullChartParams:n,rootMousemove:s,columnAmount:m,rowAmount:p,layout:l}).pipe(A(async e=>e),h(e=>{const b={offsetX:e.rootMousemove.offsetX*e.columnAmount%e.layout.rootWidth,offsetY:e.rootMousemove.offsetY*e.rowAmount%e.layout.rootHeight};return e.fullDataFormatter.grid.groupAxis.position==="bottom"||e.fullDataFormatter.grid.groupAxis.position==="top"?b.offsetX-e.fullChartParams.padding.left:b.offsetY-e.fullChartParams.padding.top})),v=S({xIndexScale:u,axisValue:x,groupScaleDomain:a}).pipe(A(async e=>e),h(e=>{const b=e.xIndexScale(e.axisValue),D=Math.ceil(e.groupScaleDomain[0]);return b+D})),F=S({groupIndex:v,groupLabels:c}).pipe(A(async e=>e),h(e=>e.groupLabels[e.groupIndex]??""));return S({groupIndex:v,groupLabel:F}).pipe(A(async e=>e),h(e=>({groupIndex:e.groupIndex,groupLabel:e.groupLabel})))};export{ge as a,me as b,ce as c,de as d,xe as e,be as f,pe as g,De as h,he as i,ve as j,Se as k,Ae as l,oe as m,Fe as n,$e as o,Le as p,fe as q,ye as r};
